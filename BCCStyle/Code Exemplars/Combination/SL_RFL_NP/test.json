[
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring findOddWord(vector<string> &wordList)\n{\n    auto calculateDifferenceArray = [](const string &currentWord)\n    {\n        vector<int> differenceArray;\n        for(size_t index = 1; index < currentWord.size(); index++)\n        {\n            differenceArray.push_back(currentWord[index] - currentWord[index - 1]);\n        }\n        return differenceArray;\n    };\n\n    vector<vector<int>> differenceArrays;\n    for (int i = 0; i < wordList.size(); ++i)\n    {\n        const auto &currentWord = wordList[i];\n        differenceArrays.push_back(calculateDifferenceArray(currentWord));\n    }\n\n    int oddArrayIndex = -1;\n    for (int index = 1; index < differenceArrays.size(); index++)\n    {\n        int matchCount = 0;\n        for (int j = 0; j < differenceArrays[index].size(); j++)\n        {\n            if (differenceArrays[0][j] == differenceArrays[index][j])\n            {\n                matchCount++;\n            }\n        }\n\n        if (matchCount == 0)\n        {\n            oddArrayIndex = index;\n            break;\n        }\n    }\n\n    return wordList[oddArrayIndex];\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nstring findOddWord(vector<string> &wordList)\n{\n    auto calculateDifferenceArray= [](const string &currentWord)\n    {\n        vector<int> differenceArray;\n        for(size_t index= 1; index < currentWord.size(); index++)\n        {\n            differenceArray.push_back(currentWord[index] - currentWord[index - 1]);\n        }\n        return differenceArray;\n    };\n\n    vector<vector<int>> differenceArrays;\n    for(const auto &currentWord : wordList)\n    {\n        differenceArrays.push_back(calculateDifferenceArray(currentWord));\n    }\n\n    int oddArrayIndex= -1;\n    for(int index= 1; index < differenceArrays.size(); index++)\n    {\n        int matchCount= 0;\n        for(int j= 0; j < differenceArrays[index].size(); j++)\n        {\n            if(differenceArrays[0][j] == differenceArrays[index][j])\n            {\n                matchCount++;\n            }\n        }\n\n        if(matchCount == 0)\n        {\n            oddArrayIndex= index;\n            break;\n        }\n    }\n\n    return wordList[oddArrayIndex];\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countDifferences(const string &sourceWord, const string &targetWord)\n{\n    int differenceCount = 0;\n    for(int index = 0; index < sourceWord.size(); ++index)\n    {\n        if(sourceWord[index] != targetWord[index])\n        {\n            ++differenceCount;\n        }\n    }\n    return differenceCount;\n}\n\nvector<string> findMatchingWords(const vector<string> &queryWords, const vector<string> &dictionaryWords)\n{\n    vector<string> matchedWords;\n    for (int i = 0; i < queryWords.size(); ++i)\n    {\n        const string &query = queryWords[i];\n        for (int j = 0; j < dictionaryWords.size(); ++j)\n        {\n            const string &dictionaryWord = dictionaryWords[j];\n            if (countDifferences(query, dictionaryWord) <= 2)\n            {\n                matchedWords.push_back(query);\n                break;\n            }\n        }\n    }\n    return matchedWords;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint countDifferences(const string &sourceWord, const string &targetWord)\n{\n    int differenceCount = 0;\n    for(int index = 0; index < sourceWord.size(); ++index)\n    {\n        if(sourceWord[index] != targetWord[index])\n        {\n            ++differenceCount;\n        }\n    }\n    return differenceCount;\n}\n\nvector<string> findMatchingWords(const vector<string> &queryWords, const vector<string> &dictionaryWords)\n{\n    vector<string> matchedWords;\n    for(const string &query : queryWords)\n    {\n        for(const string &dictionaryWord : dictionaryWords)\n        {\n            if(countDifferences(query, dictionaryWord) <= 2)\n            {\n                matchedWords.push_back(query);\n                break;\n            }\n        }\n    }\n    return matchedWords;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint findMinSeededValue(vector<int> &numbers, int space)\n{\n    unordered_map<int, int> remainderCount;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int number = numbers[i];\n        remainderCount[number % space]++;\n    }\n    return max_element(remainderCount.begin(), remainderCount.end(), [](const auto &a, const auto &b)\n                       { return a.second < b.second || (a.second == b.second && a.first > b.first); })\n        ->first;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <vector>\n#include <unordered_map>\n#include <algorithm>\nusing namespace std;\n\nint findMinSeededValue(vector<int> &numbers, int space)\n{\n    unordered_map<int, int> remainderCount;\n    for(int number : numbers)\n    {\n        remainderCount[number % space]++;\n    }\n    return max_element(remainderCount.begin(), remainderCount.end(), [](const auto &a, const auto &b)\n                       { return a.second < b.second || (a.second == b.second && a.first > b.first); })\n        ->first;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findSecondGreater(const vector<int> &inputNumbers)\n{\n    int totalNumbers= inputNumbers.size();\n    vector<int> result(totalNumbers, -1);\n    for(int currentIndex= 0; currentIndex < totalNumbers; currentIndex++)\n    {\n        for(int nextIndex= currentIndex + 1, secondGreaterIndex= -1; nextIndex < totalNumbers; nextIndex++)\n        {\n            if(inputNumbers[nextIndex] > inputNumbers[currentIndex])\n            {\n                if(secondGreaterIndex == -1)\n                {\n                    secondGreaterIndex= nextIndex;\n                }\n                else\n                {\n                    result[currentIndex]= inputNumbers[nextIndex];\n                    break;\n                }\n            }\n        }\n    }\n    return result;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <vector>\nusing namespace std;\n\nvector<int> findSecondGreater(const vector<int> &inputNumbers)\n{\n    int totalNumbers= inputNumbers.size();\n    vector<int> result(totalNumbers, -1);\n    for(int currentIndex= 0; currentIndex < totalNumbers; currentIndex++)\n    {\n        for(int nextIndex= currentIndex + 1, secondGreaterIndex= -1; nextIndex < totalNumbers; nextIndex++)\n        {\n            if(inputNumbers[nextIndex] > inputNumbers[currentIndex])\n            {\n                if(secondGreaterIndex == -1)\n                {\n                    secondGreaterIndex= nextIndex;\n                }\n                else\n                {\n                    result[currentIndex]= inputNumbers[nextIndex];\n                    break;\n                }\n            }\n        }\n    }\n    return result;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint averageEvenDivisibleByThree(const vector<int> &numbers)\n{\n    int totalSum = 0;\n    int count = 0;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int number = numbers[i];\n        if (number % 2 == 0 && number % 3 == 0)\n        {\n            totalSum += number;\n            count++;\n        }\n    }\n    return count == 0 ? 0 : totalSum / count;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <vector>\nusing namespace std;\n\nint averageEvenDivisibleByThree(const vector<int> &numbers)\n{\n    int totalSum = 0;\n    int count = 0;\n    for(int number : numbers)\n    {\n        if(number % 2 == 0 && number % 3 == 0)\n        {\n            totalSum += number;\n            count++;\n        }\n    }\n    return count == 0 ? 0 : totalSum / count;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<string>> getHighestPopularity(vector<string> &creatorNames, vector<string> &videoIds, vector<int> &viewCounts)\n{\n    unordered_map<string, int> creatorPopularity;\n    unordered_map<string, pair<string, int>> mostViewedVideos;\n    for(int index = 0; index < creatorNames.size(); index++)\n    {\n        creatorPopularity[creatorNames[index]] += viewCounts[index];\n        if(!mostViewedVideos.count(creatorNames[index]) || viewCounts[index] > mostViewedVideos[creatorNames[index]].second || (viewCounts[index] == mostViewedVideos[creatorNames[index]].second && videoIds[index] < mostViewedVideos[creatorNames[index]].first))\n        {\n            mostViewedVideos[creatorNames[index]] = {videoIds[index], viewCounts[index]};\n        }\n    }\n\n    int maxPopularity = 0;\n    for(auto it = creatorPopularity.begin(); it != creatorPopularity.end(); ++it)\n    {\n        maxPopularity = max(maxPopularity, it->second);\n    }\n\n    vector<vector<string>> result;\n    for(auto it = creatorPopularity.begin(); it != creatorPopularity.end(); ++it)\n    {\n        if(it->second == maxPopularity)\n        {\n            result.push_back({it->first, mostViewedVideos[it->first].first});\n        }\n    }\n    return result;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <string>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nvector<vector<string>> getHighestPopularity(vector<string> &creatorNames, vector<string> &videoIds, vector<int> &viewCounts)\n{\n    unordered_map<string, int> creatorPopularity;\n    unordered_map<string, pair<string, int>> mostViewedVideos;\n    for(int index= 0; index < creatorNames.size(); index++)\n    {\n        creatorPopularity[creatorNames[index]] += viewCounts[index];\n        if(!mostViewedVideos.count(creatorNames[index]) || viewCounts[index] > mostViewedVideos[creatorNames[index]].second || (viewCounts[index] == mostViewedVideos[creatorNames[index]].second && videoIds[index] < mostViewedVideos[creatorNames[index]].first))\n        {\n            mostViewedVideos[creatorNames[index]] = {videoIds[index], viewCounts[index]};\n        }\n    }\n\n    int maxPopularity= 0;\n    for(auto &[creator, popularity] : creatorPopularity)\n    {\n        maxPopularity = max(maxPopularity, popularity);\n    }\n\n    vector<vector<string>> result;\n    for(auto &[creator, popularity] : creatorPopularity)\n    {\n        if(popularity == maxPopularity)\n        {\n            result.push_back({creator, mostViewedVideos[creator].first});\n        }\n    }\n    return result;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint digitSum(int number)\n{\n    int totalSum= 0;\n    while(number)\n    {\n        totalSum+= number % 10;\n        number/= 10;\n    }\n    return totalSum;\n}\n\nint minimumBeautiful(int baseNumber, int targetSum)\n{\n    int increment= 0;\n    while(digitSum(baseNumber + increment) > targetSum)\n    {\n        ++increment;\n    }\n    return increment;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int digitSum(int number)\n{\n    int totalSum= 0;\n    while(number)\n    {\n        totalSum+= number % 10;\n        number/= 10;\n    }\n    return totalSum;\n}\n\nint minimumBeautiful(int baseNumber, int targetSum)\n{\n    int increment= 0;\n    while(digitSum(baseNumber + increment) > targetSum)\n    {\n        ++increment;\n    }\n    return increment;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nclass Solution\n{\n  public:\n    vector<int> removeSubtrees(TreeNode *rootNode, vector<int> &queries)\n    {\n        vector<int> answer(queries.size());\n\n        for(int i= 0; i < queries.size(); ++i)\n        {\n            removeSubtree(rootNode, queries[i]);\n            answer[i]= findHeight(rootNode);\n        }\n\n        return answer;\n    }\n\n    void removeSubtree(TreeNode *currentNode, int value)\n    {\n        if(currentNode == NULL)\n            return;\n\n        if(currentNode->leftChild && currentNode->leftChild->value == value)\n            currentNode->leftChild= NULL;\n        else\n            removeSubtree(currentNode->leftChild, value);\n\n        if(currentNode->rightChild && currentNode->rightChild->value == value)\n            currentNode->rightChild= NULL;\n        else\n            removeSubtree(currentNode->rightChild, value);\n    }\n\n    int findHeight(TreeNode *currentNode)\n    {\n        if(currentNode == NULL)\n            return -1;\n\n        return 1 + max(findHeight(currentNode->leftChild), findHeight(currentNode->rightChild));\n    }\n};### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <vector>\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nclass Solution\n{\n  public:\n    vector<int> removeSubtrees(TreeNode *rootNode, vector<int> &queries)\n    {\n        vector<int> answer(queries.size());\n\n        for(int i= 0; i < queries.size(); ++i)\n        {\n            removeSubtree(rootNode, queries[i]);\n            answer[i]= findHeight(rootNode);\n        }\n\n        return answer;\n    }\n\n    void removeSubtree(TreeNode *currentNode, int value)\n    {\n        if(currentNode == nullptr)\n            return;\n\n        if(currentNode->leftChild && currentNode->leftChild->value == value)\n            currentNode->leftChild= nullptr;\n        else\n            removeSubtree(currentNode->leftChild, value);\n\n        if(currentNode->rightChild && currentNode->rightChild->value == value)\n            currentNode->rightChild= nullptr;\n        else\n            removeSubtree(currentNode->rightChild, value);\n    }\n\n    int findHeight(TreeNode *currentNode)\n    {\n        if(currentNode == nullptr)\n            return -1;\n\n        return 1 + max(findHeight(currentNode->leftChild), findHeight(currentNode->rightChild));\n    }\n};\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numberList)\n{\n    int size= numberList.size();\n    int indexOfZero= -1;\n\n    for(int index= 0; index < size; index++)\n    {\n        if(numberList[index] == 0)\n        {\n            indexOfZero= index;\n            break;\n        }\n    }\n\n    int countIncrements= 0, countDecrements= 0;\n\n    for(int index= 1; index < size; index++)\n    {\n        if(abs(numberList[index] - numberList[index - 1]) != 1)\n        {\n            countIncrements+= abs(numberList[index] - numberList[index - 1]) - 1;\n        }\n    }\n\n    for(int index= indexOfZero + 1; index < size; index++)\n    {\n        if(numberList[index] < numberList[index - 1])\n        {\n            countDecrements++;\n        }\n    }\n\n    return min(countIncrements, countDecrements);\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nint minOperations(vector<int> &numberList)\n{\n    int size= numberList.size();\n    int indexOfZero= -1;\n\n    for(int index= 0; index < size; index++)\n    {\n        if(numberList[index] == 0)\n        {\n            indexOfZero= index;\n            break;\n        }\n    }\n\n    int countIncrements= 0, countDecrements= 0;\n\n    for(int index= 1; index < size; index++)\n    {\n        if(abs(numberList[index] - numberList[index - 1]) != 1)\n        {\n            countIncrements+= abs(numberList[index] - numberList[index - 1]) - 1;\n        }\n    }\n\n    for(int index= indexOfZero + 1; index < size; index++)\n    {\n        if(numberList[index] < numberList[index - 1])\n        {\n            countDecrements++;\n        }\n    }\n\n    return min(countIncrements, countDecrements);\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> performOps(vector<int> &numberList)\n{\n    int listSize= numberList.size();\n    for(int currentIndex= 0; currentIndex < listSize - 1; ++currentIndex)\n    {\n        if(numberList[currentIndex] == numberList[currentIndex + 1])\n        {\n            numberList[currentIndex]*= 2;\n            numberList[currentIndex + 1]= 0;\n        }\n    }\n    int nonZeroCount= 0;\n    for(int currentIndex= 0; currentIndex < listSize; ++currentIndex)\n    {\n        if(numberList[currentIndex] != 0)\n        {\n            numberList[nonZeroCount++]= numberList[currentIndex];\n        }\n    }\n    while(nonZeroCount < listSize)\n    {\n        numberList[nonZeroCount++]= 0;\n    }\n    return numberList;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <vector>\nusing namespace std;\n\nvector<int> performOps(vector<int> &numberList)\n{\n    int listSize= numberList.size();\n    for(int currentIndex= 0; currentIndex < listSize - 1; ++currentIndex)\n    {\n        if(numberList[currentIndex] == numberList[currentIndex + 1])\n        {\n            numberList[currentIndex]*= 2;\n            numberList[currentIndex + 1]= 0;\n        }\n    }\n    int nonZeroCount= 0;\n    for(int currentIndex= 0; currentIndex < listSize; ++currentIndex)\n    {\n        if(numberList[currentIndex] != 0)\n        {\n            numberList[nonZeroCount++]= numberList[currentIndex];\n        }\n    }\n    while(nonZeroCount < listSize)\n    {\n        numberList[nonZeroCount++]= 0;\n    }\n    return numberList;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSubarraySumWithDistinctElements(vector<int> &numbers, int windowSize)\n{\n    int maxSum = 0, currentWindowSum = 0;\n    unordered_map<int, int> frequencyMap;\n\n    for (int index = 0; index < numbers.size(); index++)\n    {\n        frequencyMap[numbers[index]]++;\n        currentWindowSum += numbers[index];\n        if (index >= windowSize)\n        {\n            frequencyMap[numbers[index - windowSize]]--;\n            currentWindowSum -= numbers[index - windowSize];\n        }\n        if (index >= windowSize - 1)\n        {\n            bool isDistinct = true;\n            // Modify the range-based for loop to a traditional for loop\n            for (int i = 0; i < frequencyMap.size(); ++i)\n            {\n                auto it = frequencyMap.begin();\n                advance(it, i);\n                if (it->second > 1)\n                {\n                    isDistinct = false;\n                    break;\n                }\n            }\n            if (isDistinct)\n            {\n                maxSum = max(maxSum, currentWindowSum);\n            }\n        }\n    }\n    return maxSum;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSubarraySumWithDistinctElements(vector<int> &numbers, int windowSize)\n{\n    int maxSum= 0, currentWindowSum= 0;\n    unordered_map<int, int> frequencyMap;\n\n    for(int index= 0; index < numbers.size(); index++)\n    {\n        frequencyMap[numbers[index]]++;\n        currentWindowSum+= numbers[index];\n        if(index >= windowSize)\n        {\n            frequencyMap[numbers[index - windowSize]]--;\n            currentWindowSum-= numbers[index - windowSize];\n        }\n        if(index >= windowSize - 1)\n        {\n            bool isDistinct= true;\n            for(const auto &pair : frequencyMap)\n            {\n                if(pair.second > 1)\n                {\n                    isDistinct= false;\n                    break;\n                }\n            }\n            if(isDistinct)\n            {\n                maxSum= max(maxSum, currentWindowSum);\n            }\n        }\n    }\n    return maxSum;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint hireWorkers(vector<int> &workerCosts, int numberOfWorkers, int candidateLimit)\n{\n    int totalCosts= workerCosts.size();\n    vector<pair<int, int>> workers;\n    for(int i= 0; i < totalCosts; ++i)\n        workers.emplace_back(workerCosts[i], i);\n    sort(workers.begin(), workers.end());\n\n    int totalCost= 0;\n    for(int i= 0; i < numberOfWorkers; ++i)\n    {\n        if(min(workers[i].second, totalCosts - workers[i].second - 1) < candidateLimit)\n            totalCost+= workers[i].first;\n    }\n    return totalCost;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <vector>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nint hireWorkers(vector<int> &workerCosts, int numberOfWorkers, int candidateLimit)\n{\n    int totalCosts= workerCosts.size();\n    vector<pair<int, int>> workers;\n    for(int i= 0; i < totalCosts; ++i)\n        workers.emplace_back(workerCosts[i], i);\n    sort(workers.begin(), workers.end());\n\n    int totalCost= 0;\n    for(int i= 0; i < numberOfWorkers; ++i)\n    {\n        if(min(workers[i].second, totalCosts - workers[i].second - 1) < candidateLimit)\n            totalCost+= workers[i].first;\n    }\n    return totalCost;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\n// for abs\nusing namespace std;\n\nint calculateMinimumTotalDistance(vector<int> &robotPositions, vector<vector<int>> &factoryLocations)\n{\n    sort(robotPositions.begin(), robotPositions.end());\n    sort(factoryLocations.begin(), factoryLocations.end());\n\n    int totalDistance = 0, robotIndex = 0;\n    for (int i = 0; i < factoryLocations.size(); ++i)\n    {\n        const auto &factory = factoryLocations[i];\n        int availableCapacity = factory[1];\n        while (availableCapacity-- > 0 && robotIndex < robotPositions.size())\n        {\n            totalDistance += abs(factory[0] - robotPositions[robotIndex]);\n            robotIndex++;\n        }\n    }\n\n    return totalDistance;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <vector>\n#include <algorithm>\n#include <cstdlib> // for abs\nusing namespace std;\n\nint calculateMinimumTotalDistance(vector<int> &robotPositions, vector<vector<int>> &factoryLocations)\n{\n    sort(robotPositions.begin(), robotPositions.end());\n    sort(factoryLocations.begin(), factoryLocations.end());\n\n    int totalDistance= 0, robotIndex= 0;\n    for(const auto &factory : factoryLocations)\n    {\n        int availableCapacity= factory[1];\n        while(availableCapacity-- > 0 && robotIndex < robotPositions.size())\n        {\n            totalDistance+= abs(factory[0] - robotPositions[robotIndex]);\n            robotIndex++;\n        }\n    }\n\n    return totalDistance;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minValidSubarrays(vector<int> &numberList)\n{\n    int subarrayCount= 0;\n    for(int currentIndex= 0; currentIndex < numberList.size(); currentIndex++)\n    {\n        while(currentIndex < numberList.size() && gcd(numberList[currentIndex], numberList.back()) == 1)\n        {\n            currentIndex++;\n        }\n        if(currentIndex < numberList.size())\n        {\n            subarrayCount++;\n            numberList.pop_back();\n        }\n    }\n    return subarrayCount > 0 ? subarrayCount : -1;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <numeric>\n#include <vector>\nusing namespace std;\n\nint minValidSubarrays(vector<int> &numberList)\n{\n    int subarrayCount= 0;\n    for(int currentIndex= 0; currentIndex < numberList.size(); currentIndex++)\n    {\n        while(currentIndex < numberList.size() && gcd(numberList[currentIndex], numberList.back()) == 1)\n        {\n            currentIndex++;\n        }\n        if(currentIndex < numberList.size())\n        {\n            subarrayCount++;\n            numberList.pop_back();\n        }\n    }\n    return subarrayCount > 0 ? subarrayCount : -1;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint distinctAverages(vector<int> &numberList)\n{\n    set<double> uniqueAverages;\n    sort(numberList.begin(), numberList.end());\n    int listSize= numberList.size();\n    for(int index= 0; index < listSize / 2; index++)\n    {\n        uniqueAverages.insert((numberList[index] + numberList[listSize - 1 - index]) / 2.0);\n    }\n    return uniqueAverages.size();\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nint distinctAverages(vector<int> &numberList)\n{\n    set<double> uniqueAverages;\n    sort(numberList.begin(), numberList.end());\n    int listSize= numberList.size();\n    for(int index= 0; index < listSize / 2; index++)\n    {\n        uniqueAverages.insert((numberList[index] + numberList[listSize - 1 - index]) / 2.0);\n    }\n    return uniqueAverages.size();\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint modulusPower(long base, int exponent, int modulus)\n{\n    long result= 1;\n    while(exponent > 0)\n    {\n        if(exponent % 2 == 1)\n        {\n            result= (result * base) % modulus;\n        }\n        base= (base * base) % modulus;\n        exponent/= 2;\n    }\n    return (int)result;\n}\n\nint countGoodStrings(int minLength, int maxLength, int zeroCount, int oneCount)\n{\n    long modulus= 1000000007;\n    return (((modulusPower(2, maxLength, modulus) - modulusPower(2, minLength - 1, modulus) + 1) * (zeroCount + 1)) % modulus * (oneCount + 1)) % modulus;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int modulusPower(long base, int exponent, int modulus)\n{\n    long result= 1;\n    while(exponent > 0)\n    {\n        if(exponent % 2 == 1)\n        {\n            result= (result * base) % modulus;\n        }\n        base= (base * base) % modulus;\n        exponent/= 2;\n    }\n    return (int)result;\n}\n\nint countGoodStrings(int minLength, int maxLength, int zeroCount, int oneCount)\n{\n    long modulus= 1000000007;\n    return (((modulusPower(2, maxLength, modulus) - modulusPower(2, minLength - 1, modulus) + 1) * (zeroCount + 1)) % modulus * (oneCount + 1)) % modulus;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid depthFirstSearch(int currentNode, int parentNode, int bobTime, int currentTime, int &aliceIncome, int &maximumIncome, vector<int> &amounts, unordered_map<int, vector<int>> &tree)\n{\n    if(currentTime < bobTime || amounts[currentNode] >= 0)\n    {\n        aliceIncome += amounts[currentNode];\n    }\n    else\n    {\n        aliceIncome += amounts[currentNode] / 2;\n    }\n    amounts[currentNode] = 0;\n    bool isLeafNode = true;\n    for(int j = 0; j < tree[currentNode].size(); ++j)\n    {\n        int childNode = tree[currentNode][j];\n        if(childNode != parentNode)\n        {\n            isLeafNode = false;\n            int temporaryIncome = aliceIncome;\n            depthFirstSearch(childNode, currentNode, bobTime, currentTime + 1, temporaryIncome, maximumIncome, amounts, tree);\n        }\n    }\n    if(isLeafNode)\n    {\n        maximumIncome = max(maximumIncome, aliceIncome);\n    }\n}\n\nint calculateMaxNetIncome(vector<vector<int>> &edges, int bobTime, vector<int> &amounts)\n{\n    unordered_map<int, vector<int>> tree;\n    for(const auto &edge : edges)\n    {\n        tree[edge[0]].emplace_back(edge[1]);\n        tree[edge[1]].emplace_back(edge[0]);\n    }\n    int maximumIncome = -100000;\n    int aliceIncome = 0;\n    depthFirstSearch(0, -1, bobTime, 0, aliceIncome, maximumIncome, amounts, tree);\n    return maximumIncome;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nvoid depthFirstSearch(int currentNode, int parentNode, int bobTime, int currentTime, int &aliceIncome, int &maximumIncome, vector<int> &amounts, unordered_map<int, vector<int>> &tree)\n{\n    if(currentTime < bobTime || amounts[currentNode] >= 0)\n    {\n        aliceIncome += amounts[currentNode];\n    }\n    else\n    {\n        aliceIncome += amounts[currentNode] / 2;\n    }\n    amounts[currentNode] = 0;\n    bool isLeafNode = true;\n    for(int childNode : tree[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            isLeafNode = false;\n            int temporaryIncome = aliceIncome;\n            depthFirstSearch(childNode, currentNode, bobTime, currentTime + 1, temporaryIncome, maximumIncome, amounts, tree);\n        }\n    }\n    if(isLeafNode)\n    {\n        maximumIncome = max(maximumIncome, aliceIncome);\n    }\n}\n\nint calculateMaxNetIncome(vector<vector<int>> &edges, int bobTime, vector<int> &amounts)\n{\n    unordered_map<int, vector<int>> tree;\n    for(const auto &edge : edges)\n    {\n        tree[edge[0]].emplace_back(edge[1]);\n        tree[edge[1]].emplace_back(edge[0]);\n    }\n    int maximumIncome = -100000;\n    int aliceIncome = 0;\n    depthFirstSearch(0, -1, bobTime, 0, aliceIncome, maximumIncome, amounts, tree);\n    return maximumIncome;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> splitMessage(string inputMessage, int characterLimit)\n{\n    int messageLength= inputMessage.size();\n    int extraCharacters= (characterLimit - 3) * (messageLength / (characterLimit - 3)) - messageLength;\n    int fullParts= messageLength / (characterLimit - 3);\n    if((messageLength + fullParts + extraCharacters) % (characterLimit - 2) != 0)\n        return {};\n    int numberOfParts= (messageLength + fullParts + extraCharacters) / (characterLimit - 2);\n    vector<string> messageParts;\n    for(int currentIndex= 0, partIndex= 1, characterCount= 0; currentIndex < messageLength || partIndex <= numberOfParts;)\n    {\n        string tempPart;\n        while(characterCount < characterLimit - 3)\n        {\n            characterCount++;\n            tempPart+= inputMessage[currentIndex++];\n            if(currentIndex == messageLength)\n                break;\n        }\n        characterCount= 0;\n        tempPart+= to_string(partIndex) + \"/\" + to_string(numberOfParts) + \" \";\n        partIndex++;\n        messageParts.push_back(tempPart);\n    }\n    return messageParts;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <string>\n#include <vector>\nusing namespace std;\n\nvector<string> splitMessage(string inputMessage, int characterLimit)\n{\n    int messageLength= inputMessage.size();\n    int extraCharacters= (characterLimit - 3) * (messageLength / (characterLimit - 3)) - messageLength;\n    int fullParts= messageLength / (characterLimit - 3);\n    if((messageLength + fullParts + extraCharacters) % (characterLimit - 2) != 0)\n        return {};\n    int numberOfParts= (messageLength + fullParts + extraCharacters) / (characterLimit - 2);\n    vector<string> messageParts;\n    for(int currentIndex= 0, partIndex= 1, characterCount= 0; currentIndex < messageLength || partIndex <= numberOfParts;)\n    {\n        string tempPart;\n        while(characterCount < characterLimit - 3)\n        {\n            characterCount++;\n            tempPart+= inputMessage[currentIndex++];\n            if(currentIndex == messageLength)\n                break;\n        }\n        characterCount= 0;\n        tempPart+= to_string(partIndex) + \"/\" + to_string(numberOfParts) + \" \";\n        partIndex++;\n        messageParts.push_back(tempPart);\n    }\n    return messageParts;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<double> convertTemperature(double celsiusTemperature)\n{\n    double kelvinTemperature = celsiusTemperature + 273.15;\n    double fahrenheitTemperature = celsiusTemperature * 1.80 + 32.00;\n    return {kelvinTemperature, fahrenheitTemperature};\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <vector>\nusing namespace std;\n\nvector<double> convertTemperature(double celsiusTemperature)\n{\n    double kelvinTemperature = celsiusTemperature + 273.15;\n    double fahrenheitTemperature = celsiusTemperature * 1.80 + 32.00;\n    return {kelvinTemperature, fahrenheitTemperature};\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lcm(int firstNumber, int secondNumber)\n{\n    int currentMultiple= firstNumber;\n    while((currentMultiple % secondNumber) != 0)\n    {\n        currentMultiple+= firstNumber;\n    }\n    return currentMultiple;\n}\n\nint countLcmSubarrays(vector<int> &numberArray, int targetLcm)\n{\n    int subarrayCount= 0;\n    for(int startIndex= 0; startIndex < numberArray.size(); startIndex++)\n    {\n        int currentLcm= numberArray[startIndex];\n        for(int endIndex= startIndex; endIndex < numberArray.size(); endIndex++)\n        {\n            currentLcm= lcm(currentLcm, numberArray[endIndex]);\n            if(currentLcm == targetLcm)\n            {\n                subarrayCount++;\n            }\n        }\n    }\n    return subarrayCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <vector>\nusing namespace std;\n\nint lcm(int firstNumber, int secondNumber)\n{\n    int currentMultiple= firstNumber;\n    while((currentMultiple % secondNumber) != 0)\n    {\n        currentMultiple+= firstNumber;\n    }\n    return currentMultiple;\n}\n\nint countLcmSubarrays(vector<int> &numberArray, int targetLcm)\n{\n    int subarrayCount= 0;\n    for(int startIndex= 0; startIndex < numberArray.size(); startIndex++)\n    {\n        int currentLcm= numberArray[startIndex];\n        for(int endIndex= startIndex; endIndex < numberArray.size(); endIndex++)\n        {\n            currentLcm= lcm(currentLcm, numberArray[endIndex]);\n            if(currentLcm == targetLcm)\n            {\n                subarrayCount++;\n            }\n        }\n    }\n    return subarrayCount;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nint calculateMinSwaps(TreeNode *rootNode)\n{\n    int swapCount= 0;\n    queue<pair<TreeNode *, int>> nodeQueue;\n    nodeQueue.push({rootNode, 0});\n\n    vector<int> levelValues;\n    int previousDepth= -1;\n\n    while(!nodeQueue.empty())\n    {\n        auto currentNode= nodeQueue.front();\n        nodeQueue.pop();\n        TreeNode *currentTreeNode= currentNode.first;\n        int currentDepth= currentNode.second;\n\n        if(previousDepth != currentDepth)\n        {\n            sort(levelValues.begin(), levelValues.end());\n            for(int i= 1; i < levelValues.size(); ++i)\n            {\n                swapCount+= abs(levelValues[i] - levelValues[i - 1]) - 1;\n            }\n            previousDepth= currentDepth;\n            levelValues.clear();\n        }\n        levelValues.push_back(currentTreeNode->value);\n\n        if(currentTreeNode->leftChild)\n            nodeQueue.push({currentTreeNode->leftChild, currentDepth + 1});\n        if(currentTreeNode->rightChild)\n            nodeQueue.push({currentTreeNode->rightChild, currentDepth + 1});\n    }\n\n    sort(levelValues.begin(), levelValues.end());\n    for(int i= 1; i < levelValues.size(); ++i)\n    {\n        swapCount+= abs(levelValues[i] - levelValues[i - 1]) - 1;\n    }\n\n    return swapCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <algorithm>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nint calculateMinSwaps(TreeNode *rootNode)\n{\n    int swapCount= 0;\n    queue<pair<TreeNode *, int>> nodeQueue;\n    nodeQueue.push({rootNode, 0});\n\n    vector<int> levelValues;\n    int previousDepth= -1;\n\n    while(!nodeQueue.empty())\n    {\n        auto currentNode= nodeQueue.front();\n        nodeQueue.pop();\n        TreeNode *currentTreeNode= currentNode.first;\n        int currentDepth= currentNode.second;\n\n        if(previousDepth != currentDepth)\n        {\n            sort(levelValues.begin(), levelValues.end());\n            for(int i= 1; i < levelValues.size(); ++i)\n            {\n                swapCount+= abs(levelValues[i] - levelValues[i - 1]) - 1;\n            }\n            previousDepth= currentDepth;\n            levelValues.clear();\n        }\n        levelValues.push_back(currentTreeNode->value);\n\n        if(currentTreeNode->leftChild)\n            nodeQueue.push({currentTreeNode->leftChild, currentDepth + 1});\n        if(currentTreeNode->rightChild)\n            nodeQueue.push({currentTreeNode->rightChild, currentDepth + 1});\n    }\n\n    sort(levelValues.begin(), levelValues.end());\n    for(int i= 1; i < levelValues.size(); ++i)\n    {\n        swapCount+= abs(levelValues[i] - levelValues[i - 1]) - 1;\n    }\n\n    return swapCount;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countMaxPalindromicSubstrings(string inputString, int minLength)\n{\n    int stringLength= inputString.size();\n    if(stringLength < minLength)\n    {\n        return 0;\n    }\n    int palindromeCount= 0;\n    vector<vector<bool>> isPalindrome(stringLength, vector<bool>(stringLength, false));\n    for(int startIndex= stringLength - 1; startIndex >= 0; startIndex--)\n    {\n        for(int endIndex= startIndex; endIndex < stringLength; endIndex++)\n        {\n            if(startIndex == endIndex)\n            {\n                isPalindrome[startIndex][endIndex]= true;\n            }\n            else if(inputString[startIndex] == inputString[endIndex])\n            {\n                isPalindrome[startIndex][endIndex]= startIndex + 1 > endIndex - 1 || isPalindrome[startIndex + 1][endIndex - 1];\n            }\n            else\n            {\n                isPalindrome[startIndex][endIndex]= false;\n            }\n            if(endIndex - startIndex + 1 >= minLength && isPalindrome[startIndex][endIndex])\n            {\n                palindromeCount++;\n                startIndex= endIndex;\n                break;\n            }\n        }\n    }\n    return palindromeCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint countMaxPalindromicSubstrings(string inputString, int minLength)\n{\n    int stringLength= inputString.size();\n    if(stringLength < minLength)\n    {\n        return 0;\n    }\n    int palindromeCount= 0;\n    vector<vector<bool>> isPalindrome(stringLength, vector<bool>(stringLength, false));\n    for(int startIndex= stringLength - 1; startIndex >= 0; startIndex--)\n    {\n        for(int endIndex= startIndex; endIndex < stringLength; endIndex++)\n        {\n            if(startIndex == endIndex)\n            {\n                isPalindrome[startIndex][endIndex]= true;\n            }\n            else if(inputString[startIndex] == inputString[endIndex])\n            {\n                isPalindrome[startIndex][endIndex]= startIndex + 1 > endIndex - 1 || isPalindrome[startIndex + 1][endIndex - 1];\n            }\n            else\n            {\n                isPalindrome[startIndex][endIndex]= false;\n            }\n            if(endIndex - startIndex + 1 >= minLength && isPalindrome[startIndex][endIndex])\n            {\n                palindromeCount++;\n                startIndex= endIndex;\n                break;\n            }\n        }\n    }\n    return palindromeCount;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> minTotalCost(int numberOfCities, vector<vector<int>> &roads, vector<int> &appleCosts, int k)\n{\n    vector<vector<pair<int, int>>> cityGraph(numberOfCities + 1);\n    for (int i = 0; i < roads.size(); ++i)\n    {\n        cityGraph[roads[i][0]].push_back({roads[i][1], roads[i][2]});\n        cityGraph[roads[i][1]].push_back({roads[i][0], roads[i][2]});\n    }\n\n    vector<int> totalCosts(numberOfCities);\n    for (int startCity = 1; startCity <= numberOfCities; ++startCity)\n    {\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> minHeap;\n        vector<int> distance(numberOfCities + 1, 1e9);\n        distance[startCity] = 0;\n        minHeap.push({0, startCity});\n        while (!minHeap.empty())\n        {\n            int currentCity = minHeap.top().second;\n            int currentDistance = minHeap.top().first;\n            minHeap.pop();\n\n            if (currentDistance > distance[currentCity])\n                continue;\n\n            for (int j = 0; j < cityGraph[currentCity].size(); ++j)\n            {\n                int adjacentCity = cityGraph[currentCity][j].first;\n                int cost = currentDistance + cityGraph[currentCity][j].second + (currentCity != startCity ? cityGraph[currentCity][j].second * k : 0) + appleCosts[adjacentCity - 1];\n\n                if (cost < distance[adjacentCity])\n                {\n                    distance[adjacentCity] = cost;\n                    minHeap.push({cost, adjacentCity});\n                }\n            }\n        }\n\n        totalCosts[startCity - 1] = distance[startCity];\n    }\n    return totalCosts;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <queue>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nvector<int> minTotalCost(int numberOfCities, vector<vector<int>> &roads, vector<int> &appleCosts, int k)\n{\n    vector<vector<pair<int, int>>> cityGraph(numberOfCities + 1);\n    for(auto &road : roads)\n    {\n        cityGraph[road[0]].push_back({road[1], road[2]});\n        cityGraph[road[1]].push_back({road[0], road[2]});\n    }\n\n    vector<int> totalCosts(numberOfCities);\n    for(int startCity= 1; startCity <= numberOfCities; ++startCity)\n    {\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> minHeap;\n        vector<int> distance(numberOfCities + 1, 1e9);\n        distance[startCity]= 0;\n        minHeap.push({0, startCity});\n        while(!minHeap.empty())\n        {\n            int currentCity= minHeap.top().second;\n            int currentDistance= minHeap.top().first;\n            minHeap.pop();\n\n            if(currentDistance > distance[currentCity])\n                continue;\n\n            for(auto &edge : cityGraph[currentCity])\n            {\n                int adjacentCity= edge.first;\n                int cost= currentDistance + edge.second + (currentCity != startCity ? edge.second * k : 0) + appleCosts[adjacentCity - 1];\n\n                if(cost < distance[adjacentCity])\n                {\n                    distance[adjacentCity]= cost;\n                    minHeap.push({cost, adjacentCity});\n                }\n            }\n        }\n\n        totalCosts[startCity - 1]= distance[startCity];\n    }\n    return totalCosts;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countTriplets(vector<int> &numberList)\n{\n    int tripletCount= 0;\n    int listSize= numberList.size();\n\n    for(int firstIndex= 0; firstIndex < listSize; firstIndex++)\n    {\n        for(int secondIndex= firstIndex + 1; secondIndex < listSize; secondIndex++)\n        {\n            for(int thirdIndex= secondIndex + 1; thirdIndex < listSize; thirdIndex++)\n            {\n                if(numberList[firstIndex] != numberList[secondIndex] && numberList[firstIndex] != numberList[thirdIndex] && numberList[secondIndex] != numberList[thirdIndex])\n                {\n                    tripletCount++;\n                }\n            }\n        }\n    }\n\n    return tripletCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <vector>\nusing namespace std;\n\nint countTriplets(vector<int> &numberList)\n{\n    int tripletCount= 0;\n    int listSize= numberList.size();\n\n    for(int firstIndex= 0; firstIndex < listSize; firstIndex++)\n    {\n        for(int secondIndex= firstIndex + 1; secondIndex < listSize; secondIndex++)\n        {\n            for(int thirdIndex= secondIndex + 1; thirdIndex < listSize; thirdIndex++)\n            {\n                if(numberList[firstIndex] != numberList[secondIndex] && numberList[firstIndex] != numberList[thirdIndex] && numberList[secondIndex] != numberList[thirdIndex])\n                {\n                    tripletCount++;\n                }\n            }\n        }\n    }\n\n    return tripletCount;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nvector<vector<int>> findMinMax(TreeNode *root, vector<int> &queries)\n{\n    if(!root)\n    {\n        return {};\n    }\n\n    vector<vector<int>> result(queries.size(), vector<int>{-1, -1});\n    for(size_t index= 0; index < queries.size(); index++)\n    {\n        TreeNode *currentNode= root;\n        int currentQuery= queries[index];\n        while(currentNode)\n        {\n            if(currentNode->value < currentQuery)\n            {\n                result[index][0]= currentNode->value;\n                currentNode= currentNode->rightChild;\n            }\n            else\n            {\n                result[index][1]= currentNode->value;\n                if(currentNode->value == currentQuery)\n                {\n                    result[index][0]= currentQuery;\n                    break;\n                }\n                currentNode= currentNode->leftChild;\n            }\n        }\n    }\n    return result;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nvector<vector<int>> findMinMax(TreeNode *root, vector<int> &queries)\n{\n    if(!root)\n    {\n        return {};\n    }\n\n    vector<vector<int>> result(queries.size(), vector<int>{-1, -1});\n    for(size_t index= 0; index < queries.size(); index++)\n    {\n        TreeNode *currentNode= root;\n        int currentQuery= queries[index];\n        while(currentNode)\n        {\n            if(currentNode->value < currentQuery)\n            {\n                result[index][0]= currentNode->value;\n                currentNode= currentNode->rightChild;\n            }\n            else\n            {\n                result[index][1]= currentNode->value;\n                if(currentNode->value == currentQuery)\n                {\n                    result[index][0]= currentQuery;\n                    break;\n                }\n                currentNode= currentNode->leftChild;\n            }\n        }\n    }\n    return result;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMinimumFuel(vector<vector<int>> &roadConnections, int seatCapacity)\n{\n    int numberOfCities = roadConnections.size() + 1;\n    vector<vector<int>> cityGraph(numberOfCities);\n    for (const auto &road : roadConnections) // This can remain as a range-based for loop\n    {\n        cityGraph[road[0]].push_back(road[1]);\n        cityGraph[road[1]].push_back(road[0]);\n    }\n\n    vector<int> cityDistance(numberOfCities, -1);\n    queue<int> cityQueue;\n    cityQueue.push(0);\n    cityDistance[0] = 0;\n\n    while (!cityQueue.empty())\n    {\n        int currentCity = cityQueue.front();\n        cityQueue.pop();\n        for (int neighborCity : cityGraph[currentCity]) // This can remain as a range-based for loop\n        {\n            if (cityDistance[neighborCity] == -1)\n            {\n                cityDistance[neighborCity] = cityDistance[currentCity] + 1;\n                cityQueue.push(neighborCity);\n            }\n        }\n    }\n\n    int totalFuelRequired = 0;\n    for (int cityIndex = 1; cityIndex < numberOfCities; cityIndex++)\n    {\n        totalFuelRequired += (cityDistance[cityIndex] - 1) / (seatCapacity - 1) + 1;\n    }\n    return totalFuelRequired;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <queue>\n#include <vector>\nusing namespace std;\n\nint calculateMinimumFuel(vector<vector<int>> &roadConnections, int seatCapacity)\n{\n    int numberOfCities = roadConnections.size() + 1;\n    vector<vector<int>> cityGraph(numberOfCities);\n    for(auto &road : roadConnections)\n    {\n        cityGraph[road[0]].push_back(road[1]);\n        cityGraph[road[1]].push_back(road[0]);\n    }\n\n    vector<int> cityDistance(numberOfCities, -1);\n    queue<int> cityQueue;\n    cityQueue.push(0);\n    cityDistance[0] = 0;\n\n    while(!cityQueue.empty())\n    {\n        int currentCity = cityQueue.front();\n        cityQueue.pop();\n        for(int neighborCity : cityGraph[currentCity])\n        {\n            if(cityDistance[neighborCity] == -1)\n            {\n                cityDistance[neighborCity] = cityDistance[currentCity] + 1;\n                cityQueue.push(neighborCity);\n            }\n        }\n    }\n\n    int totalFuelRequired = 0;\n    for(int cityIndex = 1; cityIndex < numberOfCities; cityIndex++)\n    {\n        totalFuelRequired += (cityDistance[cityIndex] - 1) / (seatCapacity - 1) + 1;\n    }\n    return totalFuelRequired;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint numBeautifulPartitions(const string &inputString, int partitionCount, int minimumLength)\n{\n    const int modulo= 1e9 + 7;\n    unordered_set<char> primeDigits= {'2', '3', '5', '7'};\n    int stringLength= inputString.length();\n    vector<vector<int>> dynamicProgramming(stringLength + 1, vector<int>(partitionCount + 1, 0));\n    dynamicProgramming[0][0]= 1;\n\n    for(int currentIndex= 1; currentIndex <= stringLength; ++currentIndex)\n    {\n        for(int currentPartitions= 1; currentPartitions <= partitionCount; ++currentPartitions)\n        {\n            for(int length= minimumLength; length <= currentIndex && currentIndex - length >= currentPartitions - 1; ++length)\n            {\n                if(primeDigits.count(inputString[currentIndex - length]) && !primeDigits.count(inputString[currentIndex - 1]))\n                {\n                    dynamicProgramming[currentIndex][currentPartitions]+= dynamicProgramming[currentIndex - length][currentPartitions - 1];\n                    if(dynamicProgramming[currentIndex][currentPartitions] >= modulo)\n                        dynamicProgramming[currentIndex][currentPartitions]-= modulo;\n                }\n            }\n        }\n    }\n\n    return dynamicProgramming[stringLength][partitionCount];\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <string>\n#include <unordered_set>\n#include <vector>\n\nusing namespace std;\n\nint numBeautifulPartitions(const string &inputString, int partitionCount, int minimumLength)\n{\n    const int modulo= 1e9 + 7;\n    unordered_set<char> primeDigits= {'2', '3', '5', '7'};\n    int stringLength= inputString.length();\n    vector<vector<int>> dynamicProgramming(stringLength + 1, vector<int>(partitionCount + 1, 0));\n    dynamicProgramming[0][0]= 1;\n\n    for(int currentIndex= 1; currentIndex <= stringLength; ++currentIndex)\n    {\n        for(int currentPartitions= 1; currentPartitions <= partitionCount; ++currentPartitions)\n        {\n            for(int length= minimumLength; length <= currentIndex && currentIndex - length >= currentPartitions - 1; ++length)\n            {\n                if(primeDigits.count(inputString[currentIndex - length]) && !primeDigits.count(inputString[currentIndex - 1]))\n                {\n                    dynamicProgramming[currentIndex][currentPartitions]+= dynamicProgramming[currentIndex - length][currentPartitions - 1];\n                    if(dynamicProgramming[currentIndex][currentPartitions] >= modulo)\n                        dynamicProgramming[currentIndex][currentPartitions]-= modulo;\n                }\n            }\n        }\n    }\n\n    return dynamicProgramming[stringLength][partitionCount];\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<vector<int>> &adjacencyList, vector<int> &nodeValues, int &maximumXor)\n{\n    int currentXorSum = nodeValues[currentNode];\n\n    for (int i = 0; i < adjacencyList[currentNode].size(); ++i)\n    {\n        int childNode = adjacencyList[currentNode][i];\n        if (childNode != parentNode)\n        {\n            currentXorSum ^= depthFirstSearch(childNode, currentNode, adjacencyList, nodeValues, maximumXor);\n        }\n    }\n\n    maximumXor = max(maximumXor, currentXorSum);\n\n    return currentXorSum;\n}\n\nint maxXorSubtree(int totalNodes, vector<vector<int>> &edges, vector<int> &nodeValues)\n{\n    vector<vector<int>> adjacencyList(totalNodes);\n\n    for (const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1]);\n        adjacencyList[edge[1]].emplace_back(edge[0]);\n    }\n\n    int maximumXor = 0;\n    int rootXorSum = depthFirstSearch(0, -1, adjacencyList, nodeValues, maximumXor);\n\n    return rootXorSum ^ maximumXor;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<vector<int>> &adjacencyList, vector<int> &nodeValues, int &maximumXor)\n{\n    int currentXorSum= nodeValues[currentNode];\n\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorSum^= depthFirstSearch(childNode, currentNode, adjacencyList, nodeValues, maximumXor);\n        }\n    }\n\n    maximumXor= max(maximumXor, currentXorSum);\n\n    return currentXorSum;\n}\n\nint maxXorSubtree(int totalNodes, vector<vector<int>> &edges, vector<int> &nodeValues)\n{\n    vector<vector<int>> adjacencyList(totalNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1]);\n        adjacencyList[edge[1]].emplace_back(edge[0]);\n    }\n\n    int maximumXor= 0;\n    int rootXorSum= depthFirstSearch(0, -1, adjacencyList, nodeValues, maximumXor);\n\n    return rootXorSum ^ maximumXor;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint minCuts(int number)\n{\n    if(number % 2 == 0)\n        return number / 2;\n    else\n        return number;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int minCuts(int number)\n{\n    if(number % 2 == 0)\n        return number / 2;\n    else\n        return number;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> createDifferenceMatrix(vector<vector<int>> &inputGrid)\n{\n    int rowCount= inputGrid.size(), columnCount= inputGrid[0].size();\n    vector<int> rowSum(rowCount, 0), columnSum(columnCount, 0);\n    vector<vector<int>> differenceMatrix(rowCount, vector<int>(columnCount));\n\n    for(int currentRowIndex= 0; currentRowIndex < rowCount; ++currentRowIndex)\n    {\n        for(int currentColIndex= 0; currentColIndex < columnCount; ++currentColIndex)\n        {\n            rowSum[currentRowIndex]+= inputGrid[currentRowIndex][currentColIndex];\n            columnSum[currentColIndex]+= inputGrid[currentRowIndex][currentColIndex];\n        }\n    }\n\n    for(int currentRowIndex= 0; currentRowIndex < rowCount; ++currentRowIndex)\n    {\n        for(int currentColIndex= 0; currentColIndex < columnCount; ++currentColIndex)\n        {\n            differenceMatrix[currentRowIndex][currentColIndex]= rowSum[currentRowIndex] + columnSum[currentColIndex] - (columnCount - rowSum[currentRowIndex]) - (rowCount - columnSum[currentColIndex]);\n        }\n    }\n\n    return differenceMatrix;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <vector>\nusing namespace std;\n\nvector<vector<int>> createDifferenceMatrix(vector<vector<int>> &inputGrid)\n{\n    int rowCount= inputGrid.size(), columnCount= inputGrid[0].size();\n    vector<int> rowSum(rowCount, 0), columnSum(columnCount, 0);\n    vector<vector<int>> differenceMatrix(rowCount, vector<int>(columnCount));\n\n    for(int currentRowIndex= 0; currentRowIndex < rowCount; ++currentRowIndex)\n    {\n        for(int currentColIndex= 0; currentColIndex < columnCount; ++currentColIndex)\n        {\n            rowSum[currentRowIndex]+= inputGrid[currentRowIndex][currentColIndex];\n            columnSum[currentColIndex]+= inputGrid[currentRowIndex][currentColIndex];\n        }\n    }\n\n    for(int currentRowIndex= 0; currentRowIndex < rowCount; ++currentRowIndex)\n    {\n        for(int currentColIndex= 0; currentColIndex < columnCount; ++currentColIndex)\n        {\n            differenceMatrix[currentRowIndex][currentColIndex]= rowSum[currentRowIndex] + columnSum[currentColIndex] - (columnCount - rowSum[currentRowIndex]) - (rowCount - columnSum[currentColIndex]);\n        }\n    }\n\n    return differenceMatrix;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minPenalty(string customerSequence)\n{\n    int customerCount = customerSequence.length();\n    int openPenalty = 0, closedPenalty = 0;\n\n    for (int i = 0; i < customerCount; ++i)\n    {\n        char currentCustomer = customerSequence[i];\n        if (currentCustomer == 'N')\n            openPenalty++;\n        else\n            closedPenalty++;\n    }\n\n    int minimumPenalty = closedPenalty;\n    int currentPenalty = closedPenalty;\n\n    for (int index = 0; index < customerCount; index++)\n    {\n        if (customerSequence[index] == 'N')\n            currentPenalty--;\n        else\n            currentPenalty++;\n\n        minimumPenalty = min(minimumPenalty, currentPenalty);\n    }\n\n    return minimumPenalty;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nint minPenalty(string customerSequence)\n{\n    int customerCount= customerSequence.length();\n    int openPenalty= 0, closedPenalty= 0;\n\n    for(char currentCustomer : customerSequence)\n    {\n        if(currentCustomer == 'N')\n            openPenalty++;\n        else\n            closedPenalty++;\n    }\n\n    int minimumPenalty= closedPenalty;\n    int currentPenalty= closedPenalty;\n\n    for(int index= 0; index < customerCount; index++)\n    {\n        if(customerSequence[index] == 'N')\n            currentPenalty--;\n        else\n            currentPenalty++;\n\n        minimumPenalty= min(minimumPenalty, currentPenalty);\n    }\n\n    return minimumPenalty;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPalindromeSubsequences(string inputString, int modulus)\n{\n    int stringLength= inputString.size();\n    const int modulusValue= 1000000007;\n    vector<vector<int>> dpTable(10, vector<int>(stringLength, 0));\n    for(int i= 0; i < stringLength; ++i)\n        dpTable[inputString[i] - '0'][i]= 1;\n    for(int length= 1; length <= 4; ++length)\n    {\n        for(int digit= 0; digit < 10; ++digit)\n        {\n            for(int i= 0, j= length; j < stringLength; ++i, ++j)\n            {\n                dpTable[digit][j]= (dpTable[digit][j - 1] + (inputString[j] - '0' == digit)) % modulusValue;\n            }\n        }\n    }\n    long long totalCount= 0;\n    for(int firstDigit= 0; firstDigit < 10; ++firstDigit)\n    {\n        for(int secondDigit= 0; secondDigit < 10; ++secondDigit)\n        {\n            totalCount+= (1LL * dpTable[firstDigit][stringLength - 5] * dpTable[secondDigit][stringLength - 1]) % modulusValue;\n        }\n    }\n    return totalCount % modulusValue;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint countPalindromeSubsequences(string inputString, int modulus)\n{\n    int stringLength= inputString.size();\n    const int modulusValue= 1000000007;\n    vector<vector<int>> dpTable(10, vector<int>(stringLength, 0));\n    for(int i= 0; i < stringLength; ++i)\n        dpTable[inputString[i] - '0'][i]= 1;\n    for(int length= 1; length <= 4; ++length)\n    {\n        for(int digit= 0; digit < 10; ++digit)\n        {\n            for(int i= 0, j= length; j < stringLength; ++i, ++j)\n            {\n                dpTable[digit][j]= (dpTable[digit][j - 1] + (inputString[j] - '0' == digit)) % modulusValue;\n            }\n        }\n    }\n    long long totalCount= 0;\n    for(int firstDigit= 0; firstDigit < 10; ++firstDigit)\n    {\n        for(int secondDigit= 0; secondDigit < 10; ++secondDigit)\n        {\n            totalCount+= (1LL * dpTable[firstDigit][stringLength - 5] * dpTable[secondDigit][stringLength - 1]) % modulusValue;\n        }\n    }\n    return totalCount % modulusValue;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint findPivot(int totalNumbers)\n{\n    int totalSum= totalNumbers * (totalNumbers + 1) / 2;\n    int leftSum= 0;\n    for(int currentNumber= 1; currentNumber <= totalNumbers; ++currentNumber)\n    {\n        leftSum+= currentNumber;\n        if(2 * leftSum == totalSum)\n        {\n            return currentNumber;\n        }\n    }\n    return -1;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int findPivot(int totalNumbers)\n{\n    int totalSum= totalNumbers * (totalNumbers + 1) / 2;\n    int leftSum= 0;\n    for(int currentNumber= 1; currentNumber <= totalNumbers; ++currentNumber)\n    {\n        leftSum+= currentNumber;\n        if(2 * leftSum == totalSum)\n        {\n            return currentNumber;\n        }\n    }\n    return -1;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minAddition(string sourceString, string targetString)\n{\n    int sourceLength = sourceString.length();\n    int targetLength = targetString.length();\n    int sourceIndex = 0, targetIndex = 0;\n    while(sourceIndex < sourceLength && targetIndex < targetLength)\n    {\n        if(sourceString[sourceIndex] == targetString[targetIndex])\n        {\n            targetIndex++;\n        }\n        sourceIndex++;\n    }\n    return targetLength - targetIndex;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <string>\nusing namespace std;\n\nint minAddition(string sourceString, string targetString)\n{\n    int sourceLength = sourceString.length();\n    int targetLength = targetString.length();\n    int sourceIndex = 0, targetIndex = 0;\n    while(sourceIndex < sourceLength && targetIndex < targetLength)\n    {\n        if(sourceString[sourceIndex] == targetString[targetIndex])\n        {\n            targetIndex++;\n        }\n        sourceIndex++;\n    }\n    return targetLength - targetIndex;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nclass ListNode\n{\n  public:\n    int value;\n    ListNode *next;\n};\n\nListNode *removeNodes(ListNode *head)\n{\n    if(!head)\n        return NULL;\n    ListNode *maxNode= head;\n    ListNode *currentNode= head;\n    ListNode *previousNode= NULL;\n\n    while(currentNode && currentNode->next)\n    {\n        if(currentNode->next->value > maxNode->value)\n        {\n            if(previousNode)\n                previousNode->next= currentNode->next;\n            else\n                head= currentNode->next;\n            maxNode= currentNode->next;\n        }\n        else\n        {\n            previousNode= currentNode;\n        }\n        currentNode= currentNode->next;\n    }\n    maxNode->next= removeNodes(maxNode->next);\n    return head;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "class ListNode\n{\n  public:\n    int value;\n    ListNode *next;\n};\n\nListNode *removeNodes(ListNode *head)\n{\n    if(!head)\n        return nullptr;\n    ListNode *maxNode= head;\n    ListNode *currentNode= head;\n    ListNode *previousNode= nullptr;\n\n    while(currentNode && currentNode->next)\n    {\n        if(currentNode->next->value > maxNode->value)\n        {\n            if(previousNode)\n                previousNode->next= currentNode->next;\n            else\n                head= currentNode->next;\n            maxNode= currentNode->next;\n        }\n        else\n        {\n            previousNode= currentNode;\n        }\n        currentNode= currentNode->next;\n    }\n    maxNode->next= removeNodes(maxNode->next);\n    return head;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countSubarraysWithMedian(vector<int> &numbers, int target)\n{\n    int resultCount = 0;\n    for(int startIndex = 0; startIndex < numbers.size(); ++startIndex)\n    {\n        int targetCount = 0;\n        vector<int> subarray;\n        for(int endIndex = startIndex; endIndex < numbers.size(); ++endIndex)\n        {\n            targetCount += (numbers[endIndex] == target);\n            subarray.insert(lower_bound(subarray.begin(), subarray.end(), numbers[endIndex]), numbers[endIndex]);\n            if((subarray.size() % 2 == 1) && (subarray[subarray.size() / 2] == target))\n            {\n                resultCount += targetCount;\n            }\n        }\n    }\n    return resultCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint countSubarraysWithMedian(vector<int> &numbers, int target)\n{\n    int resultCount = 0;\n    for(int startIndex = 0; startIndex < numbers.size(); ++startIndex)\n    {\n        int targetCount = 0;\n        vector<int> subarray;\n        for(int endIndex = startIndex; endIndex < numbers.size(); ++endIndex)\n        {\n            targetCount += (numbers[endIndex] == target);\n            subarray.insert(lower_bound(subarray.begin(), subarray.end(), numbers[endIndex]), numbers[endIndex]);\n            if((subarray.size() % 2 == 1) && (subarray[subarray.size() / 2] == target))\n            {\n                resultCount += targetCount;\n            }\n        }\n    }\n    return resultCount;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateRatioSubstringCount(string inputString, int firstNum, int secondNum)\n{\n    int zeroCount = 0, oneCount = 0;\n    map<int, int> frequencyMap;\n    int substringCount = 0;\n\n    frequencyMap[0] = 1;\n\n    for (int i = 0; i < inputString.size(); ++i)\n    {\n        char currentChar = inputString[i];\n        if (currentChar == '0')\n            zeroCount++;\n        else\n            oneCount++;\n\n        int currentDifference = zeroCount * secondNum - oneCount * firstNum;\n        substringCount += frequencyMap[currentDifference];\n        frequencyMap[currentDifference]++;\n    }\n    return substringCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <string>\n#include <map>\nusing namespace std;\n\nint calculateRatioSubstringCount(string inputString, int firstNum, int secondNum)\n{\n    int zeroCount= 0, oneCount= 0;\n    map<int, int> frequencyMap;\n    int substringCount= 0;\n\n    frequencyMap[0]= 1;\n\n    for(char currentChar : inputString)\n    {\n        if(currentChar == '0')\n            zeroCount++;\n        else\n            oneCount++;\n\n        int currentDifference= zeroCount * secondNum - oneCount * firstNum;\n        substringCount+= frequencyMap[currentDifference];\n        frequencyMap[currentDifference]++;\n    }\n    return substringCount;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isCircular(string sentence)\n{\n    stringstream stream(sentence);\n    string currentWord, previousWord;\n\n    while(stream >> currentWord)\n    {\n        if(!previousWord.empty() && previousWord.back() != currentWord.front())\n        {\n            return false;\n        }\n        previousWord = currentWord;\n    }\n\n    return currentWord.back() == sentence.front();\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <string>\n#include <sstream>\nusing namespace std;\n\nbool isCircular(string sentence)\n{\n    stringstream stream(sentence);\n    string currentWord, previousWord;\n\n    while(stream >> currentWord)\n    {\n        if(!previousWord.empty() && previousWord.back() != currentWord.front())\n        {\n            return false;\n        }\n        previousWord = currentWord;\n    }\n\n    return currentWord.back() == sentence.front();\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maximumChemistry(vector<int> &skillLevels)\n{\n    int totalSum = 0;\n    for (int i = 0; i < skillLevels.size(); ++i)\n    {\n        totalSum += skillLevels[i];\n    }\n    int targetSum = totalSum / 2;\n    if (totalSum % 2 == 1)\n        return -1;\n\n    unordered_map<int, int> dynamicProgrammingMap;\n    dynamicProgrammingMap[0] = 1;\n    int maxChemistry = 0;\n\n    for (int i = 0; i < skillLevels.size(); ++i)\n    {\n        int skill = skillLevels[i];\n        for (int j = targetSum - skill; j >= 0; j--)\n        {\n            if (dynamicProgrammingMap[j])\n            {\n                dynamicProgrammingMap[j + skill] += dynamicProgrammingMap[j];\n                if (j + skill == targetSum)\n                {\n                    maxChemistry += dynamicProgrammingMap[j] * skill;\n                }\n            }\n        }\n    }\n\n    return (maxChemistry > 0) ? maxChemistry : -1;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint maximumChemistry(vector<int> &skillLevels)\n{\n    int totalSum= 0;\n    for(int skill : skillLevels)\n    {\n        totalSum+= skill;\n    }\n    int targetSum= totalSum / 2;\n    if(totalSum % 2 == 1)\n        return -1;\n\n    unordered_map<int, int> dynamicProgrammingMap;\n    dynamicProgrammingMap[0]= 1;\n    int maxChemistry= 0;\n\n    for(int skill : skillLevels)\n    {\n        for(int i= targetSum - skill; i >= 0; i--)\n        {\n            if(dynamicProgrammingMap[i])\n            {\n                dynamicProgrammingMap[i + skill]+= dynamicProgrammingMap[i];\n                if(i + skill == targetSum)\n                {\n                    maxChemistry+= dynamicProgrammingMap[i] * skill;\n                }\n            }\n        }\n    }\n\n    return (maxChemistry > 0) ? maxChemistry : -1;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumScore(int totalCities, vector<vector<int>> &roads)\n{\n    vector<vector<pair<int, int>>> adjacencyList(totalCities + 1);\n    for (int i = 0; i < roads.size(); ++i)\n    {\n        adjacencyList[roads[i][0]].push_back({roads[i][1], roads[i][2]});\n        adjacencyList[roads[i][1]].push_back({roads[i][0], roads[i][2]});\n    }\n\n    const int infinity = 1e9;\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> priorityQueue;\n    priorityQueue.push({0, 1});\n\n    vector<int> minimumDistance(totalCities + 1, infinity);\n    while (!priorityQueue.empty())\n    {\n        int currentCity = priorityQueue.top().second;\n        int currentDistance = priorityQueue.top().first;\n        priorityQueue.pop();\n\n        if (currentCity == totalCities)\n        {\n            return currentDistance;\n        }\n\n        if (currentDistance < minimumDistance[currentCity])\n        {\n            minimumDistance[currentCity] = currentDistance;\n            for (int j = 0; j < adjacencyList[currentCity].size(); ++j)\n            {\n                const auto &neighbor = adjacencyList[currentCity][j];\n                int nextCity = neighbor.first;\n                int nextDistance = max(currentDistance, neighbor.second);\n                if (nextDistance < minimumDistance[nextCity])\n                {\n                    priorityQueue.push({nextDistance, nextCity});\n                }\n            }\n        }\n    }\n\n    return -1;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <vector>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nint minimumScore(int totalCities, vector<vector<int>> &roads)\n{\n    vector<vector<pair<int, int>>> adjacencyList(totalCities + 1);\n    for(const auto &road : roads)\n    {\n        adjacencyList[road[0]].push_back({road[1], road[2]});\n        adjacencyList[road[1]].push_back({road[0], road[2]});\n    }\n\n    const int infinity= 1e9;\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> priorityQueue;\n    priorityQueue.push({0, 1});\n\n    vector<int> minimumDistance(totalCities + 1, infinity);\n    while(!priorityQueue.empty())\n    {\n        int currentCity= priorityQueue.top().second;\n        int currentDistance= priorityQueue.top().first;\n        priorityQueue.pop();\n\n        if(currentCity == totalCities)\n        {\n            return currentDistance;\n        }\n\n        if(currentDistance < minimumDistance[currentCity])\n        {\n            minimumDistance[currentCity]= currentDistance;\n            for(const auto &neighbor : adjacencyList[currentCity])\n            {\n                int nextCity= neighbor.first;\n                int nextDistance= max(currentDistance, neighbor.second);\n                if(nextDistance < minimumDistance[nextCity])\n                {\n                    priorityQueue.push({nextDistance, nextCity});\n                }\n            }\n        }\n    }\n\n    return -1;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxGroups(int numberOfNodes, vector<vector<int>> &edges)\n{\n    vector<vector<int>> adjacencyList(numberOfNodes + 1);\n    vector<int> nodeColor(numberOfNodes + 1, 0);\n\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        adjacencyList[edges[i][0]].push_back(edges[i][1]);\n        adjacencyList[edges[i][1]].push_back(edges[i][0]);\n    }\n\n    int maximumGroupSize = 0;\n    for (int nodeIndex = 1; nodeIndex <= numberOfNodes; ++nodeIndex)\n    {\n        if (nodeColor[nodeIndex] == 0)\n        {\n            queue<int> nodeQueue;\n            nodeQueue.push(nodeIndex);\n            nodeColor[nodeIndex] = 1;\n            while (!nodeQueue.empty())\n            {\n                int currentNode = nodeQueue.front();\n                nodeQueue.pop();\n                maximumGroupSize = max(maximumGroupSize, nodeColor[currentNode]);\n                for (int j = 0; j < adjacencyList[currentNode].size(); ++j)\n                {\n                    int neighbor = adjacencyList[currentNode][j];\n                    if (nodeColor[neighbor] == 0)\n                    {\n                        nodeColor[neighbor] = nodeColor[currentNode] + 1;\n                        nodeQueue.push(neighbor);\n                    }\n                    else if (nodeColor[neighbor] == nodeColor[currentNode])\n                    {\n                        return -1;\n                    }\n                }\n            }\n        }\n    }\n    return maximumGroupSize;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <queue>\n#include <vector>\nusing namespace std;\n\nint maxGroups(int numberOfNodes, vector<vector<int>> &edges)\n{\n    vector<vector<int>> adjacencyList(numberOfNodes + 1);\n    vector<int> nodeColor(numberOfNodes + 1, 0);\n\n    for(auto &edge : edges)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    int maximumGroupSize = 0;\n    for(int nodeIndex = 1; nodeIndex <= numberOfNodes; ++nodeIndex)\n    {\n        if(nodeColor[nodeIndex] == 0)\n        {\n            queue<int> nodeQueue;\n            nodeQueue.push(nodeIndex);\n            nodeColor[nodeIndex] = 1;\n            while(!nodeQueue.empty())\n            {\n                int currentNode = nodeQueue.front();\n                nodeQueue.pop();\n                maximumGroupSize = max(maximumGroupSize, nodeColor[currentNode]);\n                for(int neighbor : adjacencyList[currentNode])\n                {\n                    if(nodeColor[neighbor] == 0)\n                    {\n                        nodeColor[neighbor] = nodeColor[currentNode] + 1;\n                        nodeQueue.push(neighbor);\n                    }\n                    else if(nodeColor[neighbor] == nodeColor[currentNode])\n                    {\n                        return -1;\n                    }\n                }\n            }\n        }\n    }\n    return maximumGroupSize;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countOfEvenSubarrays(vector<int> &numberArray)\n{\n    int arraySize = numberArray.size();\n    int evenCount = 0, oddCount = 0, totalCount = 0;\n\n    for (int i = 0; i < arraySize; ++i)\n    {\n        int currentNumber = numberArray[i];\n        if (currentNumber % 2 == 0)\n        {\n            evenCount++;\n            totalCount += evenCount;\n        }\n        else\n        {\n            swap(evenCount, oddCount);\n            oddCount++;\n            totalCount += oddCount;\n        }\n    }\n\n    return totalCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <vector>\nusing namespace std;\n\nint countOfEvenSubarrays(vector<int> &numberArray)\n{\n    int arraySize= numberArray.size();\n    int evenCount= 0, oddCount= 0, totalCount= 0;\n\n    for(int currentNumber : numberArray)\n    {\n        if(currentNumber % 2 == 0)\n        {\n            evenCount++;\n            totalCount+= evenCount;\n        }\n        else\n        {\n            swap(evenCount, oddCount);\n            oddCount++;\n            totalCount+= oddCount;\n        }\n    }\n\n    return totalCount;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxValue(vector<string> &stringList)\n{\n    int maxValue = 0;\n    for (int i = 0; i < stringList.size(); ++i)\n    {\n        const string &currentString = stringList[i];\n        int currentValue;\n        if (currentString.find_first_not_of(\"0123456789\") == string::npos)\n        {\n            currentValue = stoi(currentString);\n        }\n        else\n        {\n            currentValue = static_cast<int>(currentString.length());\n        }\n        maxValue = max(maxValue, currentValue);\n    }\n    return maxValue;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxValue(vector<string> &stringList)\n{\n    int maxValue= 0;\n    for(const string &currentString : stringList)\n    {\n        int currentValue;\n        if(currentString.find_first_not_of(\"0123456789\") == string::npos)\n        {\n            currentValue= stoi(currentString);\n        }\n        else\n        {\n            currentValue= static_cast<int>(currentString.length());\n        }\n        maxValue= max(maxValue, currentValue);\n    }\n    return maxValue;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxStarSum(const vector<int> &nodeValues, const vector<vector<int>> &edges, int k)\n{\n    vector<int> adjacencyList[100000];\n    int maximumSum = -1e9;\n\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        const vector<int> &edge = edges[i];\n        adjacencyList[edge[0]].push_back(nodeValues[edge[1]]);\n        adjacencyList[edge[1]].push_back(nodeValues[edge[0]]);\n    }\n\n    for (int nodeIndex = 0; nodeIndex < nodeValues.size(); nodeIndex++)\n    {\n        sort(adjacencyList[nodeIndex].rbegin(), adjacencyList[nodeIndex].rend());\n        int currentSum = nodeValues[nodeIndex];\n        for (int j = 0; j < k && j < adjacencyList[nodeIndex].size(); j++)\n        {\n            currentSum += adjacencyList[nodeIndex][j];\n        }\n        maximumSum = max(maximumSum, currentSum);\n    }\n\n    return maximumSum;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxStarSum(const vector<int> &nodeValues, const vector<vector<int>> &edges, int k)\n{\n    vector<int> adjacencyList[100000];\n    int maximumSum= -1e9;\n\n    for(const vector<int> &edge : edges)\n    {\n        adjacencyList[edge[0]].push_back(nodeValues[edge[1]]);\n        adjacencyList[edge[1]].push_back(nodeValues[edge[0]]);\n    }\n\n    for(int nodeIndex= 0; nodeIndex < nodeValues.size(); nodeIndex++)\n    {\n        sort(adjacencyList[nodeIndex].rbegin(), adjacencyList[nodeIndex].rend());\n        int currentSum= nodeValues[nodeIndex];\n        for(int j= 0; j < k && j < adjacencyList[nodeIndex].size(); j++)\n        {\n            currentSum+= adjacencyList[nodeIndex][j];\n        }\n        maximumSum= max(maximumSum, currentSum);\n    }\n\n    return maximumSum;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumPathCost(vector<int> &stoneCosts)\n{\n    int numberOfStones= stoneCosts.size();\n    int minimumCost= stoneCosts[numberOfStones - 1];\n    for(int index= 1; index < numberOfStones - 1; ++index)\n    {\n        minimumCost= min(minimumCost, max(stoneCosts[index], stoneCosts[numberOfStones - 1] - stoneCosts[index]));\n    }\n    return minimumCost;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint minimumPathCost(vector<int> &stoneCosts)\n{\n    int numberOfStones= stoneCosts.size();\n    int minimumCost= stoneCosts[numberOfStones - 1];\n    for(int index= 1; index < numberOfStones - 1; ++index)\n    {\n        minimumCost= min(minimumCost, max(stoneCosts[index], stoneCosts[numberOfStones - 1] - stoneCosts[index]));\n    }\n    return minimumCost;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minCost(vector<int> &firstArray, vector<int> &secondArray)\n{\n    unordered_map<int, vector<int>> valueToIndices;\n    for(int index = 0; index < firstArray.size(); ++index)\n    {\n        valueToIndices[firstArray[index]].push_back(index);\n    }\n\n    int totalCost = 0;\n    for(int i = 0; i < secondArray.size(); ++i)\n    {\n        int value = secondArray[i];\n        if(valueToIndices[value].empty())\n            return -1;\n        totalCost += valueToIndices[value].back();\n        valueToIndices[value].pop_back();\n    }\n\n    return totalCost;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint minCost(vector<int> &firstArray, vector<int> &secondArray)\n{\n    unordered_map<int, vector<int>> valueToIndices;\n    for(int index= 0; index < firstArray.size(); ++index)\n    {\n        valueToIndices[firstArray[index]].push_back(index);\n    }\n\n    int totalCost= 0;\n    for(int value : secondArray)\n    {\n        if(valueToIndices[value].empty())\n            return -1;\n        totalCost+= valueToIndices[value].back();\n        valueToIndices[value].pop_back();\n    }\n\n    return totalCost;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxValueAfterOperations(vector<vector<int>> &grid)\n{\n    int totalMaxValue= 0;\n    while(!grid.empty())\n    {\n        int currentMaxValue= 0, maxRowIndex= -1;\n\n        for(int rowIndex= 0; rowIndex < grid.size(); ++rowIndex)\n        {\n            auto maxElementIterator= max_element(grid[rowIndex].begin(), grid[rowIndex].end());\n            if(*maxElementIterator > currentMaxValue)\n            {\n                currentMaxValue= *maxElementIterator;\n                maxRowIndex= rowIndex;\n            }\n            grid[rowIndex].erase(maxElementIterator);\n        }\n\n        totalMaxValue+= currentMaxValue;\n        if(grid[maxRowIndex].empty())\n        {\n            grid.erase(grid.begin() + maxRowIndex);\n        }\n    }\n\n    return totalMaxValue;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint maxValueAfterOperations(vector<vector<int>> &grid)\n{\n    int totalMaxValue= 0;\n    while(!grid.empty())\n    {\n        int currentMaxValue= 0, maxRowIndex= -1;\n\n        for(int rowIndex= 0; rowIndex < grid.size(); ++rowIndex)\n        {\n            auto maxElementIterator= max_element(grid[rowIndex].begin(), grid[rowIndex].end());\n            if(*maxElementIterator > currentMaxValue)\n            {\n                currentMaxValue= *maxElementIterator;\n                maxRowIndex= rowIndex;\n            }\n            grid[rowIndex].erase(maxElementIterator);\n        }\n\n        totalMaxValue+= currentMaxValue;\n        if(grid[maxRowIndex].empty())\n        {\n            grid.erase(grid.begin() + maxRowIndex);\n        }\n    }\n\n    return totalMaxValue;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint longestSquareStreak(vector<int> &numberList)\n{\n    unordered_set<int> numberSet(numberList.begin(), numberList.end());\n    int longestStreak = -1;\n\n    for (auto it = numberSet.begin(); it != numberSet.end(); ++it)\n    {\n        int currentNumber = *it;\n        int currentStreak = 1;\n\n        while (numberSet.count(static_cast<int>(pow(currentNumber, 0.5))) > 0)\n        {\n            ++currentStreak;\n            currentNumber = static_cast<int>(pow(currentNumber, 0.5));\n        }\n\n        longestStreak = max(longestStreak, currentStreak);\n    }\n\n    return longestStreak >= 2 ? longestStreak : -1;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <algorithm>\n#include <cmath>\n#include <unordered_set>\nusing namespace std;\n\nint longestSquareStreak(vector<int> &numberList)\n{\n    unordered_set<int> numberSet(numberList.begin(), numberList.end());\n    int longestStreak= -1;\n\n    for(int currentNumber : numberSet)\n    {\n        int currentStreak= 1;\n\n        while(numberSet.count(static_cast<int>(pow(currentNumber, 0.5))) > 0)\n        {\n            ++currentStreak;\n            currentNumber= static_cast<int>(pow(currentNumber, 0.5));\n        }\n\n        longestStreak= max(longestStreak, currentStreak);\n    }\n\n    return longestStreak >= 2 ? longestStreak : -1;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nclass Allocator\n{\n    vector<int> memory;\n\n  public:\n    Allocator(int size) : memory(size, 0) {}\n\n    int allocate(int blockSize, int memoryId)\n    {\n        int startIndex= -1, freeCount= 0;\n        for(int i= 0; i <= memory.size(); ++i)\n        {\n            if(i < memory.size() && memory[i] == 0)\n            {\n                if(startIndex == -1)\n                    startIndex= i;\n                freeCount++;\n            }\n            else\n            {\n                if(freeCount >= blockSize)\n                {\n                    fill(memory.begin() + startIndex, memory.begin() + startIndex + blockSize, memoryId);\n                    return startIndex;\n                }\n                startIndex= -1;\n                freeCount= 0;\n            }\n        }\n        return -1;\n    }\n\n    int free(int memoryId)\n    {\n        int freedCount= 0;\n        for(int i= 0; i < memory.size(); ++i)\n        {\n            if(memory[i] == memoryId)\n            {\n                freedCount++;\n                memory[i]= 0;\n            }\n        }\n        return freedCount;\n    }\n};### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Allocator\n{\n    vector<int> memory;\n\n  public:\n    Allocator(int size) : memory(size, 0) {}\n\n    int allocate(int blockSize, int memoryId)\n    {\n        int startIndex= -1, freeCount= 0;\n        for(int i= 0; i <= memory.size(); ++i)\n        {\n            if(i < memory.size() && memory[i] == 0)\n            {\n                if(startIndex == -1)\n                    startIndex= i;\n                freeCount++;\n            }\n            else\n            {\n                if(freeCount >= blockSize)\n                {\n                    fill(memory.begin() + startIndex, memory.begin() + startIndex + blockSize, memoryId);\n                    return startIndex;\n                }\n                startIndex= -1;\n                freeCount= 0;\n            }\n        }\n        return -1;\n    }\n\n    int free(int memoryId)\n    {\n        int freedCount= 0;\n        for(int i= 0; i < memory.size(); ++i)\n        {\n            if(memory[i] == memoryId)\n            {\n                freedCount++;\n                memory[i]= 0;\n            }\n        }\n        return freedCount;\n    }\n};"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> traverseMatrix(vector<vector<int>> &grid, const vector<int> &queries, int rows, int columns)\n{\n    vector<int> directionX= {-1, 0, 1, 0};\n    vector<int> directionY= {0, 1, 0, -1};\n    vector<int> result(queries.size(), 0);\n\n    for(int queryIndex= 0; queryIndex < queries.size(); ++queryIndex)\n    {\n        int queryValue= queries[queryIndex];\n        int pointsCount= 0;\n        set<pair<int, int>> visitedCells;\n\n        function<void(int, int)> depthFirstSearch= [&](int currentX, int currentY)\n        {\n            if(visitedCells.find({currentX, currentY}) == visitedCells.end() && grid[currentX][currentY] < queryValue)\n            {\n                visitedCells.insert({currentX, currentY});\n                pointsCount++;\n                for(int directionIndex= 0; directionIndex < 4; ++directionIndex)\n                {\n                    int nextX= currentX + directionX[directionIndex], nextY= currentY + directionY[directionIndex];\n                    if(nextX >= 0 && nextX < rows && nextY >= 0 && nextY < columns)\n                    {\n                        depthFirstSearch(nextX, nextY);\n                    }\n                }\n            }\n        };\n\n        depthFirstSearch(0, 0);\n        result[queryIndex]= pointsCount;\n    }\n\n    return result;\n}\n\nvector<int> maxPoints(vector<vector<int>> &grid, vector<int> &queries)\n{\n    int rows= grid.size();\n    int columns= grid[0].size();\n    return traverseMatrix(grid, queries, rows, columns);\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <set>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nvector<int> traverseMatrix(vector<vector<int>> &grid, const vector<int> &queries, int rows, int columns)\n{\n    vector<int> directionX= {-1, 0, 1, 0};\n    vector<int> directionY= {0, 1, 0, -1};\n    vector<int> result(queries.size(), 0);\n\n    for(int queryIndex= 0; queryIndex < queries.size(); ++queryIndex)\n    {\n        int queryValue= queries[queryIndex];\n        int pointsCount= 0;\n        set<pair<int, int>> visitedCells;\n\n        function<void(int, int)> depthFirstSearch= [&](int currentX, int currentY)\n        {\n            if(visitedCells.find({currentX, currentY}) == visitedCells.end() && grid[currentX][currentY] < queryValue)\n            {\n                visitedCells.insert({currentX, currentY});\n                pointsCount++;\n                for(int directionIndex= 0; directionIndex < 4; ++directionIndex)\n                {\n                    int nextX= currentX + directionX[directionIndex], nextY= currentY + directionY[directionIndex];\n                    if(nextX >= 0 && nextX < rows && nextY >= 0 && nextY < columns)\n                    {\n                        depthFirstSearch(nextX, nextY);\n                    }\n                }\n            }\n        };\n\n        depthFirstSearch(0, 0);\n        result[queryIndex]= pointsCount;\n    }\n\n    return result;\n}\n\nvector<int> maxPoints(vector<vector<int>> &grid, vector<int> &queries)\n{\n    int rows= grid.size();\n    int columns= grid[0].size();\n    return traverseMatrix(grid, queries, rows, columns);\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint subsequenceOrSum(vector<int> &numbers)\n{\n    int orResult = 0;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int currentNumber = numbers[i];\n        orResult |= currentNumber;\n    }\n    return orResult;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <vector>\nusing namespace std;\n\nint subsequenceOrSum(vector<int> &numbers)\n{\n    int orResult= 0;\n    for(int currentNumber : numbers)\n    {\n        orResult|= currentNumber;\n    }\n    return orResult;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countSimilarPairs(vector<string> &wordList)\n{\n    int similarPairCount = 0;\n    for(int firstIndex = 0; firstIndex < wordList.size(); ++firstIndex)\n    {\n        for(int secondIndex = firstIndex + 1; secondIndex < wordList.size(); ++secondIndex)\n        {\n            unordered_set<char> firstWordSet{wordList[firstIndex].begin(), wordList[firstIndex].end()};\n            unordered_set<char> secondWordSet{wordList[secondIndex].begin(), wordList[secondIndex].end()};\n            if(firstWordSet == secondWordSet)\n                similarPairCount++;\n        }\n    }\n    return similarPairCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <string>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\n\nint countSimilarPairs(vector<string> &wordList)\n{\n    int similarPairCount = 0;\n    for(int firstIndex = 0; firstIndex < wordList.size(); ++firstIndex)\n    {\n        for(int secondIndex = firstIndex + 1; secondIndex < wordList.size(); ++secondIndex)\n        {\n            unordered_set<char> firstWordSet{wordList[firstIndex].begin(), wordList[firstIndex].end()};\n            unordered_set<char> secondWordSet{wordList[secondIndex].begin(), wordList[secondIndex].end()};\n            if(firstWordSet == secondWordSet)\n                similarPairCount++;\n        }\n    }\n    return similarPairCount;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint smallestFactorization(int number)\n{\n    if(number <= 3)\n        return number;\n    int factorizationResult= 0, factorMultiplier= 1;\n    for(int currentFactor= 2; currentFactor <= 5; ++currentFactor)\n    {\n        while(number % currentFactor == 0)\n        {\n            factorizationResult+= factorMultiplier * currentFactor;\n            factorMultiplier*= 10;\n            number/= currentFactor;\n        }\n    }\n    return number == 1 ? factorizationResult : number;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int smallestFactorization(int number)\n{\n    if(number <= 3)\n        return number;\n    int factorizationResult= 0, factorMultiplier= 1;\n    for(int currentFactor= 2; currentFactor <= 5; ++currentFactor)\n    {\n        while(number % currentFactor == 0)\n        {\n            factorizationResult+= factorMultiplier * currentFactor;\n            factorMultiplier*= 10;\n            number/= currentFactor;\n        }\n    }\n    return number == 1 ? factorizationResult : number;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPossibleDegreeEven(int numberOfVertices, vector<vector<int>> &edges)\n{\n    vector<int> vertexDegrees(numberOfVertices + 1, 0);\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        vertexDegrees[edges[i][0]]++;\n        vertexDegrees[edges[i][1]]++;\n    }\n\n    int oddDegreeCount = 0;\n    for (int index = 1; index <= numberOfVertices; index++)\n    {\n        if (vertexDegrees[index] % 2 != 0)\n            oddDegreeCount++;\n    }\n\n    return (oddDegreeCount == 0 || oddDegreeCount == 2);\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <vector>\nusing namespace std;\n\nbool isPossibleDegreeEven(int numberOfVertices, vector<vector<int>> &edges)\n{\n    vector<int> vertexDegrees(numberOfVertices + 1, 0);\n    for(const auto &edge : edges)\n    {\n        vertexDegrees[edge[0]]++;\n        vertexDegrees[edge[1]]++;\n    }\n\n    int oddDegreeCount= 0;\n    for(int index= 1; index <= numberOfVertices; index++)\n    {\n        if(vertexDegrees[index] % 2 != 0)\n            oddDegreeCount++;\n    }\n\n    return (oddDegreeCount == 0 || oddDegreeCount == 2);\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> lengthOfCycle(int numberOfNodes, const vector<vector<int>> &queries)\n{\n    vector<int> cycleLengths;\n    for (int i = 0; i < queries.size(); ++i)\n    {\n        const auto &query = queries[i];\n        int depthA = 0, depthB = 0, nodeA = query[0], nodeB = query[1];\n        while (nodeA != nodeB)\n        {\n            if (nodeA < nodeB)\n                swap(nodeA, nodeB);\n            nodeA >>= 1;\n            depthA++;\n        }\n        cycleLengths.push_back(depthA + depthB);\n    }\n    return cycleLengths;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> lengthOfCycle(int numberOfNodes, const vector<vector<int>> &queries)\n{\n    vector<int> cycleLengths;\n    for(const auto &query : queries)\n    {\n        int depthA= 0, depthB= 0, nodeA= query[0], nodeB= query[1];\n        while(nodeA != nodeB)\n        {\n            if(nodeA < nodeB)\n                swap(nodeA, nodeB);\n            nodeA>>= 1;\n            depthA++;\n        }\n        cycleLengths.push_back(depthA + depthB);\n    }\n    return cycleLengths;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isValidPath(vector<vector<int>> &grid, int currentRow, int currentCol, int zeroCount, int oneCount)\n{\n    if(currentRow < 0 || currentCol < 0 || currentRow >= grid.size() || currentCol >= grid[0].size())\n    {\n        return false;\n    }\n    if(grid[currentRow][currentCol] == 1)\n    {\n        oneCount++;\n    }\n    else\n    {\n        zeroCount++;\n    }\n    if(currentRow == grid.size() - 1 && currentCol == grid[0].size() - 1)\n    {\n        return zeroCount == oneCount;\n    }\n    return isValidPath(grid, currentRow + 1, currentCol, zeroCount, oneCount) || isValidPath(grid, currentRow, currentCol + 1, zeroCount, oneCount);\n}\n\nbool equalPath(vector<vector<int>> &grid)\n{\n    return isValidPath(grid, 0, 0, 0, 0);\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <vector>\nusing namespace std;\n\nbool isValidPath(vector<vector<int>> &grid, int currentRow, int currentCol, int zeroCount, int oneCount)\n{\n    if(currentRow < 0 || currentCol < 0 || currentRow >= grid.size() || currentCol >= grid[0].size())\n    {\n        return false;\n    }\n    if(grid[currentRow][currentCol] == 1)\n    {\n        oneCount++;\n    }\n    else\n    {\n        zeroCount++;\n    }\n    if(currentRow == grid.size() - 1 && currentCol == grid[0].size() - 1)\n    {\n        return zeroCount == oneCount;\n    }\n    return isValidPath(grid, currentRow + 1, currentCol, zeroCount, oneCount) || isValidPath(grid, currentRow, currentCol + 1, zeroCount, oneCount);\n}\n\nbool equalPath(vector<vector<int>> &grid)\n{\n    return isValidPath(grid, 0, 0, 0, 0);\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxCapturedForts(vector<int> &forts)\n{\n    int totalForts= forts.size();\n    int maxCapture= 0;\n    for(int currentFort= 0; currentFort < totalForts; currentFort++)\n    {\n        if(forts[currentFort] == 1)\n        {\n            for(int nextFort= currentFort + 1; nextFort < totalForts; nextFort++)\n            {\n                if(forts[nextFort] != -1)\n                {\n                    int captureCount= 0;\n                    for(int intermediateFort= currentFort + 1; intermediateFort < nextFort; intermediateFort++)\n                    {\n                        if(forts[intermediateFort] == 0)\n                            captureCount++;\n                    }\n                    if(forts[nextFort] == 1)\n                        maxCapture= max(maxCapture, captureCount);\n                }\n            }\n        }\n    }\n    return maxCapture;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint maxCapturedForts(vector<int> &forts)\n{\n    int totalForts= forts.size();\n    int maxCapture= 0;\n    for(int currentFort= 0; currentFort < totalForts; currentFort++)\n    {\n        if(forts[currentFort] == 1)\n        {\n            for(int nextFort= currentFort + 1; nextFort < totalForts; nextFort++)\n            {\n                if(forts[nextFort] != -1)\n                {\n                    int captureCount= 0;\n                    for(int intermediateFort= currentFort + 1; intermediateFort < nextFort; intermediateFort++)\n                    {\n                        if(forts[intermediateFort] == 0)\n                            captureCount++;\n                    }\n                    if(forts[nextFort] == 1)\n                        maxCapture= max(maxCapture, captureCount);\n                }\n            }\n        }\n    }\n    return maxCapture;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> topKStudents(const vector<string> &positiveFeedback,\n                          const vector<string> &negativeFeedback,\n                          const vector<string> &reports,\n                          const vector<int> &studentIds,\n                          int k)\n{\n    unordered_map<int, int> studentPoints;\n    for(size_t i = 0; i < reports.size(); ++i)\n    {\n        int positiveCount = 0, negativeCount = 0;\n        for(size_t j = 0; j < positiveFeedback.size(); ++j)\n        {\n            const auto &positive = positiveFeedback[j];\n            size_t positiveIndex = reports[i].find(positive);\n            while(positiveIndex != string::npos)\n            {\n                ++positiveCount;\n                positiveIndex = reports[i].find(positive, positiveIndex + positive.length());\n            }\n        }\n        for(size_t j = 0; j < negativeFeedback.size(); ++j)\n        {\n            const auto &negative = negativeFeedback[j];\n            size_t negativeIndex = reports[i].find(negative);\n            while(negativeIndex != string::npos)\n            {\n                ++negativeCount;\n                negativeIndex = reports[i].find(negative, negativeIndex + negative.length());\n            }\n        }\n        studentPoints[studentIds[i]] += 3 * positiveCount - negativeCount;\n    }\n\n    vector<int> students(studentIds.begin(), studentIds.end());\n    sort(students.begin(), students.end(), [&studentPoints](int a, int b)\n         { return studentPoints[a] != studentPoints[b] ? studentPoints[a] > studentPoints[b] : a < b; });\n\n    return vector<int>(students.begin(), students.begin() + k);\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <algorithm>\n#include <string>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nvector<int> topKStudents(const vector<string> &positiveFeedback,\n                          const vector<string> &negativeFeedback,\n                          const vector<string> &reports,\n                          const vector<int> &studentIds,\n                          int k)\n{\n    unordered_map<int, int> studentPoints;\n    for(size_t i= 0; i < reports.size(); ++i)\n    {\n        int positiveCount= 0, negativeCount= 0;\n        for(const auto &positive : positiveFeedback)\n        {\n            size_t positiveIndex= reports[i].find(positive);\n            while(positiveIndex != string::npos)\n            {\n                ++positiveCount;\n                positiveIndex= reports[i].find(positive, positiveIndex + positive.length());\n            }\n        }\n        for(const auto &negative : negativeFeedback)\n        {\n            size_t negativeIndex= reports[i].find(negative);\n            while(negativeIndex != string::npos)\n            {\n                ++negativeCount;\n                negativeIndex= reports[i].find(negative, negativeIndex + negative.length());\n            }\n        }\n        studentPoints[studentIds[i]]+= 3 * positiveCount - negativeCount;\n    }\n\n    vector<int> students(studentIds.begin(), studentIds.end());\n    sort(students.begin(), students.end(), [&studentPoints](int a, int b)\n         { return studentPoints[a] != studentPoints[b] ? studentPoints[a] > studentPoints[b] : a < b; });\n\n    return vector<int>(students.begin(), students.begin() + k);\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint calculateMinimumPossibleMax(int divisor1, int divisor2, int uniqueCount1, int uniqueCount2)\n{\n    return (divisor1 - 1) * uniqueCount1 + (divisor2 - 1) * uniqueCount2 + 1;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int calculateMinimumPossibleMax(int divisor1, int divisor2, int uniqueCount1, int uniqueCount2)\n{\n    return (divisor1 - 1) * uniqueCount1 + (divisor2 - 1) * uniqueCount2 + 1;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\n// For std::min\nusing namespace std;\n\nint shortestDistance(vector<string> &words, string target, int startIndex)\n{\n    int totalWords = words.size();\n    int leftDistance = 0, rightDistance = 0, currentIndex = startIndex;\n    while(true)\n    {\n        if(words[currentIndex] == target)\n        {\n            return min(leftDistance, rightDistance);\n        }\n        leftDistance++;\n        rightDistance++;\n        currentIndex = (currentIndex + 1) % totalWords;\n        if(leftDistance == totalWords)\n        {\n            break;\n        }\n    }\n    return -1;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "Heres the updated code with the necessary standard library headers included and `using namespace std;` added:\n\n```cpp\n#include <string>\n#include <vector>\n#include <algorithm> // For std::min\nusing namespace std;\n\nint shortestDistance(vector<string> &words, string target, int startIndex)\n{\n    int totalWords = words.size();\n    int leftDistance = 0, rightDistance = 0, currentIndex = startIndex;\n    while(true)\n    {\n        if(words[currentIndex] == target)\n        {\n            return min(leftDistance, rightDistance);\n        }\n        leftDistance++;\n        rightDistance++;\n        currentIndex = (currentIndex + 1) % totalWords;\n        if(leftDistance == totalWords)\n        {\n            break;\n        }\n    }\n    return -1;\n}\n```\n\n### Changes Made:\n1. Included `<algorithm>` to use `std::min`.\n2. Added `using namespace std;` to avoid prefixing standard library entities with `std::`."
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minMinutes(string inputString, int requiredCount)\n{\n    int stringLength = inputString.length();\n    vector<int> leftCharacterCounts(3, 0), rightCharacterCounts(3, 0);\n    for (int i = 0; i < stringLength; ++i)\n        rightCharacterCounts[inputString[i] - 'a']++;\n\n    int minimumMinutes = stringLength, totalCount = 0;\n    while (true)\n    {\n        int leftIndex = 0, rightIndex = stringLength - 1;\n        while (leftIndex < rightIndex && leftCharacterCounts[inputString[leftIndex] - 'a'] < requiredCount && rightCharacterCounts[inputString[rightIndex] - 'a'] < requiredCount)\n        {\n            int neededLeft = max(0, requiredCount - leftCharacterCounts[inputString[leftIndex] - 'a']);\n            int neededRight = max(0, requiredCount - rightCharacterCounts[inputString[rightIndex] - 'a']);\n            if (neededLeft <= neededRight)\n            {\n                totalCount += neededLeft;\n                leftCharacterCounts[inputString[leftIndex] - 'a'] += neededLeft; // Fixed increment\n                rightCharacterCounts[inputString[leftIndex] - 'a'] -= neededLeft; // Fixed decrement\n                leftIndex++;\n            }\n            else\n            {\n                totalCount += neededRight;\n                rightCharacterCounts[inputString[rightIndex] - 'a'] -= neededRight; // Fixed decrement\n                leftCharacterCounts[inputString[rightIndex] - 'a'] += neededRight; // Fixed increment\n                rightIndex--;\n            }\n        }\n        minimumMinutes = min(minimumMinutes, totalCount);\n        if (leftIndex + 1 < inputString.length())\n        {\n            totalCount -= leftCharacterCounts[inputString[leftIndex] - 'a'];\n            leftCharacterCounts[inputString[leftIndex] - 'a']--;\n            rightCharacterCounts[inputString[leftIndex + 1] - 'a']++;\n            leftIndex++;\n        }\n        else\n            break;\n    }\n    if (leftCharacterCounts[0] >= requiredCount && leftCharacterCounts[1] >= requiredCount && leftCharacterCounts[2] >= requiredCount)\n        return minimumMinutes;\n    return -1;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <algorithm>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint minMinutes(string inputString, int requiredCount)\n{\n    int stringLength = inputString.length();\n    vector<int> leftCharacterCounts(3, 0), rightCharacterCounts(3, 0);\n    for (char character : inputString)\n        rightCharacterCounts[character - 'a']++;\n\n    int minimumMinutes = stringLength, totalCount = 0;\n    while (true)\n    {\n        int leftIndex = 0, rightIndex = stringLength - 1;\n        while (leftIndex < rightIndex && leftCharacterCounts[inputString[leftIndex] - 'a'] < requiredCount && rightCharacterCounts[inputString[rightIndex] - 'a'] < requiredCount)\n        {\n            int neededLeft = max(0, requiredCount - leftCharacterCounts[inputString[leftIndex] - 'a']);\n            int neededRight = max(0, requiredCount - rightCharacterCounts[inputString[rightIndex] - 'a']);\n            if (neededLeft <= neededRight)\n            {\n                totalCount += neededLeft;\n                leftIndex++;\n                leftCharacterCounts[inputString[leftIndex] - 'a']++;\n                rightCharacterCounts[inputString[leftIndex] - 'a']--;\n            }\n            else\n            {\n                totalCount += neededRight;\n                rightIndex--;\n                rightCharacterCounts[inputString[rightIndex] - 'a']--;\n                leftCharacterCounts[inputString[rightIndex] - 'a']++;\n            }\n        }\n        minimumMinutes = min(minimumMinutes, totalCount);\n        if (leftIndex + 1 < inputString.length())\n        {\n            totalCount -= leftCharacterCounts[inputString[leftIndex] - 'a'];\n            leftCharacterCounts[inputString[leftIndex] - 'a']--;\n            rightCharacterCounts[inputString[leftIndex + 1] - 'a']++;\n            leftIndex++;\n        }\n        else\n            break;\n    }\n    if (leftCharacterCounts[0] >= requiredCount && leftCharacterCounts[1] >= requiredCount && leftCharacterCounts[2] >= requiredCount)\n        return minimumMinutes;\n    return -1;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMaxTastiness(vector<int> &prices, int numberOfItems)\n{\n    sort(prices.begin(), prices.end());\n    int maxTastiness= 0;\n    for(int i= 0; i < prices.size() - numberOfItems + 1; i++)\n    {\n        int minDifference= INT_MAX;\n        for(int j= i; j < i + numberOfItems - 1; j++)\n        {\n            minDifference= min(minDifference, prices[j + 1] - prices[j]);\n        }\n        maxTastiness= max(maxTastiness, minDifference);\n    }\n\n    return maxTastiness;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <vector>\n#include <algorithm>\n#include <limits.h>\nusing namespace std;\n\nint calculateMaxTastiness(vector<int> &prices, int numberOfItems)\n{\n    sort(prices.begin(), prices.end());\n    int maxTastiness= 0;\n    for(int i= 0; i < prices.size() - numberOfItems + 1; i++)\n    {\n        int minDifference= INT_MAX;\n        for(int j= i; j < i + numberOfItems - 1; j++)\n        {\n            minDifference= min(minDifference, prices[j + 1] - prices[j]);\n        }\n        maxTastiness= max(maxTastiness, minDifference);\n    }\n\n    return maxTastiness;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPartitions(vector<int> &numbers, int target)\n{\n    long long totalSum = 0;\n    int size = numbers.size();\n    int modulus = 1000000007;\n\n    for (int i = 0; i < size; ++i)\n    {\n        totalSum += numbers[i];\n    }\n\n    if (totalSum < target * 2)\n    {\n        return 0;\n    }\n\n    vector<long long> dynamicProgramming(size + 1, 1);\n\n    for (int i = 1; i <= target - 1; i++)\n    {\n        for (int j = size - 1; j >= 1; j--)\n        {\n            dynamicProgramming[j] = (dynamicProgramming[j] * j + dynamicProgramming[j - 1]) % modulus;\n        }\n    }\n\n    long long result = 0;\n\n    for (int i = 0; i < size - 1; i++)\n    {\n        totalSum -= numbers[i];\n        if (totalSum >= target)\n        {\n            result = (result + dynamicProgramming[i + 1]) % modulus;\n        }\n    }\n\n    return (int)result;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <vector>\nusing namespace std;\n\nint countPartitions(vector<int> &numbers, int target)\n{\n    long long totalSum= 0;\n    int size= numbers.size();\n    int modulus= 1000000007;\n\n    for(int number : numbers)\n    {\n        totalSum+= number;\n    }\n\n    if(totalSum < target * 2)\n    {\n        return 0;\n    }\n\n    vector<long long> dynamicProgramming(size + 1, 1);\n\n    for(int i= 1; i <= target - 1; i++)\n    {\n        for(int j= size - 1; j >= 1; j--)\n        {\n            dynamicProgramming[j]= (dynamicProgramming[j] * j + dynamicProgramming[j - 1]) % modulus;\n        }\n    }\n\n    long long result= 0;\n\n    for(int i= 0; i < size - 1; i++)\n    {\n        totalSum-= numbers[i];\n        if(totalSum >= target)\n        {\n            result= (result + dynamicProgramming[i + 1]) % modulus;\n        }\n    }\n\n    return (int)result;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countKBigIndices(vector<int> &numbers, int threshold)\n{\n    int size= numbers.size();\n    vector<int> leftIndices(size, 0), rightIndices(size, 0);\n\n    for(int index= 1; index < size; ++index)\n    {\n        if(numbers[index] > numbers[index - 1])\n            leftIndices[index]= leftIndices[index - 1] + 1;\n\n        int reverseIndex= size - index - 1;\n        if(reverseIndex + 1 < size && numbers[reverseIndex] < numbers[reverseIndex + 1]) // Ensure we don't go out of bounds\n            rightIndices[reverseIndex]= rightIndices[reverseIndex + 1] + 1;\n    }\n\n    int totalCount= 0;\n    for(int index= 0; index < size; ++index)\n        if(leftIndices[index] >= threshold && rightIndices[index] >= threshold)\n            totalCount++;\n\n    return totalCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <vector>\nusing namespace std;\n\nint countKBigIndices(vector<int> &numbers, int threshold)\n{\n    int size= numbers.size();\n    vector<int> leftIndices(size, 0), rightIndices(size, 0);\n\n    for(int index= 1; index < size; ++index)\n    {\n        if(numbers[index] > numbers[index - 1])\n            leftIndices[index]= leftIndices[index - 1] + 1;\n\n        int reverseIndex= size - index - 1;\n        if(reverseIndex + 1 < size && numbers[reverseIndex] < numbers[reverseIndex + 1]) // Ensure we don't go out of bounds\n            rightIndices[reverseIndex]= rightIndices[reverseIndex + 1] + 1;\n    }\n\n    int totalCount= 0;\n    for(int index= 0; index < size; ++index)\n        if(leftIndices[index] >= threshold && rightIndices[index] >= threshold)\n            totalCount++;\n\n    return totalCount;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint countDigitsDividingNumber(int inputNumber)\n{\n    int divisorCount= 0, tempNumber= inputNumber;\n    while(tempNumber > 0)\n    {\n        int currentDigit= tempNumber % 10;\n        if(inputNumber % currentDigit == 0)\n        {\n            divisorCount++;\n        }\n        tempNumber/= 10;\n    }\n    return divisorCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int countDigitsDividingNumber(int inputNumber)\n{\n    int divisorCount= 0, tempNumber= inputNumber;\n    while(tempNumber > 0)\n    {\n        int currentDigit= tempNumber % 10;\n        if(inputNumber % currentDigit == 0)\n        {\n            divisorCount++;\n        }\n        tempNumber/= 10;\n    }\n    return divisorCount;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countDistinctPrimeFactors(const vector<int> &numbers)\n{\n    set<int> distinctPrimeFactors;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int number = numbers[i];\n        for (int divisor = 2; divisor * divisor <= number; ++divisor)\n        {\n            if (number % divisor == 0)\n            {\n                distinctPrimeFactors.insert(divisor);\n                distinctPrimeFactors.insert(number / divisor);\n            }\n        }\n    }\n    return distinctPrimeFactors.size();\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <set>\n#include <vector>\nusing namespace std;\n\nint countDistinctPrimeFactors(const vector<int> &numbers)\n{\n    set<int> distinctPrimeFactors;\n    for(const int number : numbers)\n    {\n        for(int divisor= 2; divisor * divisor <= number; ++divisor)\n        {\n            if(number % divisor == 0)\n            {\n                distinctPrimeFactors.insert(divisor);\n                distinctPrimeFactors.insert(number / divisor);\n            }\n        }\n    }\n    return distinctPrimeFactors.size();\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minPartitions(string numberString, int maxValue)\n{\n    int stringLength= numberString.size();\n    int partitionCount= 0, currentIndex= 0;\n\n    while(currentIndex < stringLength)\n    {\n        int currentValue= 0;\n        // Make sure the currentValue is below maxValue\n        while(currentIndex < stringLength && currentValue * 10 + (numberString[currentIndex] - '0') <= maxValue)\n        {\n            currentValue= currentValue * 10 + (numberString[currentIndex] - '0');\n            currentIndex++;\n        }\n\n        if(currentValue == 0)\n            return -1;\n        partitionCount++;\n    }\n\n    return partitionCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <string>\nusing namespace std;\n\nint minPartitions(string numberString, int maxValue)\n{\n    int stringLength= numberString.size();\n    int partitionCount= 0, currentIndex= 0;\n\n    while(currentIndex < stringLength)\n    {\n        int currentValue= 0;\n        // Make sure the currentValue is below maxValue\n        while(currentIndex < stringLength && currentValue * 10 + (numberString[currentIndex] - '0') <= maxValue)\n        {\n            currentValue= currentValue * 10 + (numberString[currentIndex] - '0');\n            currentIndex++;\n        }\n\n        if(currentValue == 0)\n            return -1;\n        partitionCount++;\n    }\n\n    return partitionCount;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPrime(int number)\n{\n    if(number <= 1)\n        return false;\n    for(int divisor= 2; divisor * divisor <= number; ++divisor)\n    {\n        if(number % divisor == 0)\n            return false;\n    }\n    return true;\n}\n\nvector<int> closestPrimePair(int rangeStart, int rangeEnd)\n{\n    int minimumDistance= rangeEnd - rangeStart + 1;\n    vector<int> result= {-1, -1};\n    for(int currentNumber= rangeStart; currentNumber <= rangeEnd; ++currentNumber)\n    {\n        if(isPrime(currentNumber))\n        {\n            for(int nextNumber= currentNumber + 1; nextNumber <= rangeEnd; ++nextNumber)\n            {\n                if(isPrime(nextNumber) && nextNumber - currentNumber < minimumDistance)\n                {\n                    minimumDistance= nextNumber - currentNumber;\n                    result= {currentNumber, nextNumber};\n                }\n            }\n        }\n    }\n    return result;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <vector>\nusing namespace std;\n\nbool isPrime(int number)\n{\n    if(number <= 1)\n        return false;\n    for(int divisor= 2; divisor * divisor <= number; ++divisor)\n    {\n        if(number % divisor == 0)\n            return false;\n    }\n    return true;\n}\n\nvector<int> closestPrimePair(int rangeStart, int rangeEnd)\n{\n    int minimumDistance= rangeEnd - rangeStart + 1;\n    vector<int> result= {-1, -1};\n    for(int currentNumber= rangeStart; currentNumber <= rangeEnd; ++currentNumber)\n    {\n        if(isPrime(currentNumber))\n        {\n            for(int nextNumber= currentNumber + 1; nextNumber <= rangeEnd; ++nextNumber)\n            {\n                if(isPrime(nextNumber) && nextNumber - currentNumber < minimumDistance)\n                {\n                    minimumDistance= nextNumber - currentNumber;\n                    result= {currentNumber, nextNumber};\n                }\n            }\n        }\n    }\n    return result;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxFrequencyScore(vector<int> &numbers, int k)\n{\n    int size= numbers.size();\n    int rightIndex= 0, currentCount= 0, maxScore= 0;\n    long long currentScore= 0;\n    unordered_map<int, int> frequencyMap;\n\n    for(int leftIndex= 0; leftIndex < size; ++leftIndex)\n    {\n        while(rightIndex < size && currentCount < k)\n        {\n            currentScore= (currentScore + (long long)numbers[rightIndex] * frequencyMap[numbers[rightIndex]]) % 1000000007;\n            frequencyMap[numbers[rightIndex]]++;\n            currentCount++;\n            rightIndex++;\n        }\n\n        maxScore= max(maxScore, (int)currentScore);\n\n        if(currentCount == k)\n        {\n            currentScore-= numbers[leftIndex] * (frequencyMap[numbers[leftIndex]] - 1);\n            frequencyMap[numbers[leftIndex]]--;\n            currentCount--;\n        }\n    }\n\n    return maxScore;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint maxFrequencyScore(vector<int> &numbers, int k)\n{\n    int size= numbers.size();\n    int rightIndex= 0, currentCount= 0, maxScore= 0;\n    long long currentScore= 0;\n    unordered_map<int, int> frequencyMap;\n\n    for(int leftIndex= 0; leftIndex < size; ++leftIndex)\n    {\n        while(rightIndex < size && currentCount < k)\n        {\n            currentScore= (currentScore + (long long)numbers[rightIndex] * frequencyMap[numbers[rightIndex]]) % 1000000007;\n            frequencyMap[numbers[rightIndex]]++;\n            currentCount++;\n            rightIndex++;\n        }\n\n        maxScore= max(maxScore, (int)currentScore);\n\n        if(currentCount == k)\n        {\n            currentScore-= numbers[leftIndex] * (frequencyMap[numbers[leftIndex]] - 1);\n            frequencyMap[numbers[leftIndex]]--;\n            currentCount--;\n        }\n    }\n\n    return maxScore;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring getBoxCategory(int boxLength, int boxWidth, int boxHeight, int boxMass)\n{\n    bool isBulky= boxLength >= 10000 || boxWidth >= 10000 || boxHeight >= 10000 || (long)boxLength * boxWidth * boxHeight >= 1000000000;\n    bool isHeavy= boxMass >= 100;\n\n    if(isBulky && isHeavy)\n        return \"Both \";\n    if(isBulky)\n        return \"Bulky \";\n    if(isHeavy)\n        return \"Heavy \";\n    return \"Neither \";\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <string>\nusing namespace std;\n\nstring getBoxCategory(int boxLength, int boxWidth, int boxHeight, int boxMass)\n{\n    bool isBulky= boxLength >= 10000 || boxWidth >= 10000 || boxHeight >= 10000 || (long)boxLength * boxWidth * boxHeight >= 1000000000;\n    bool isHeavy= boxMass >= 100;\n\n    if(isBulky && isHeavy)\n        return \"Both \";\n    if(isBulky)\n        return \"Bulky \";\n    if(isHeavy)\n        return \"Heavy \";\n    return \"Neither \";\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nclass DataStream\n{\n  public:\n    DataStream(int targetValue, int sequenceLength) : targetValue(targetValue), sequenceLength(sequenceLength) {}\n\n    bool consec(int num)\n    {\n        dataStream.push_back(num);\n        if(dataStream.size() > sequenceLength)\n            dataStream.pop_front();\n\n        return dataStream.size() == sequenceLength && count(dataStream.begin(), dataStream.end(), targetValue) == sequenceLength;\n    }\n\n  private:\n    int targetValue;\n    int sequenceLength;\n    deque<int> dataStream;\n};### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <deque>\nusing namespace std;\n\nclass DataStream\n{\n  public:\n    DataStream(int targetValue, int sequenceLength) : targetValue(targetValue), sequenceLength(sequenceLength) {}\n\n    bool consec(int num)\n    {\n        dataStream.push_back(num);\n        if(dataStream.size() > sequenceLength)\n            dataStream.pop_front();\n\n        return dataStream.size() == sequenceLength && count(dataStream.begin(), dataStream.end(), targetValue) == sequenceLength;\n    }\n\n  private:\n    int targetValue;\n    int sequenceLength;\n    deque<int> dataStream;\n};\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateXorBeauty(vector<int> &inputNumbers)\n{\n    int numberOfElements = inputNumbers.size();\n    int maximumXorValue = 1024; // Maximum value for bitwise operations\n    vector<int> frequencyCounter(maximumXorValue, 0);\n\n    for (int i = 0; i < numberOfElements; ++i)\n    {\n        frequencyCounter[inputNumbers[i] % maximumXorValue]++;\n    }\n\n    int xorBeautyResult = 0;\n    for (int i = 0; i < maximumXorValue; i++)\n    {\n        for (int j = i; j < maximumXorValue; j++)\n        {\n            int commonBits = (i | j) & (~(i ^ j));\n            if (commonBits < maximumXorValue && commonBits >= j)\n            {\n                int countCombinations = frequencyCounter[i] * frequencyCounter[j] * (i == j ? 1 : 2);\n                if (commonBits != i && commonBits != j)\n                {\n                    countCombinations *= frequencyCounter[commonBits];\n                }\n                xorBeautyResult ^= countCombinations;\n            }\n        }\n    }\n\n    return xorBeautyResult;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <vector>\nusing namespace std;\n\nint calculateXorBeauty(vector<int> &inputNumbers)\n{\n    int numberOfElements= inputNumbers.size();\n    int maximumXorValue= 1024; // Maximum value for bitwise operations\n    vector<int> frequencyCounter(maximumXorValue, 0);\n\n    for(int currentNumber : inputNumbers)\n    {\n        frequencyCounter[currentNumber % maximumXorValue]++;\n    }\n\n    int xorBeautyResult= 0;\n    for(int i= 0; i < maximumXorValue; i++)\n    {\n        for(int j= i; j < maximumXorValue; j++)\n        {\n            int commonBits= (i | j) & (~(i ^ j));\n            if(commonBits < maximumXorValue && commonBits >= j)\n            {\n                int countCombinations= frequencyCounter[i] * frequencyCounter[j] * (i == j ? 1 : 2);\n                if(commonBits != i && commonBits != j)\n                {\n                    countCombinations*= frequencyCounter[commonBits];\n                }\n                xorBeautyResult^= countCombinations;\n            }\n        }\n    }\n\n    return xorBeautyResult;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMaxMinPower(vector<int> &stationPowers, int range, int additionalPower)\n{\n    int numberOfStations = stationPowers.size();\n    vector<int> totalPower(numberOfStations);\n    for(int currentStation = 0; currentStation < numberOfStations; currentStation++)\n    {\n        for(int nearbyStation = max(0, currentStation - range); nearbyStation <= min(numberOfStations - 1, currentStation + range); nearbyStation++)\n        {\n            totalPower[nearbyStation] += stationPowers[currentStation];\n        }\n    }\n\n    int sumOfK = 0, minimumPower = INT_MAX;\n    for(int currentIndex = range; currentIndex < numberOfStations - range; currentIndex++)\n    {\n        sumOfK += stationPowers[currentIndex];\n        minimumPower = min(minimumPower, totalPower[currentIndex]);\n    }\n\n    for(int j = 0, i = numberOfStations - 2 * range; j < 2 * range; j++, i--)\n    {\n        sumOfK -= stationPowers[i + range + 1];\n        minimumPower -= stationPowers[j];\n        minimumPower += sumOfK;\n        minimumPower += additionalPower;\n        minimumPower = min(minimumPower, totalPower[j]);\n    }\n\n    return minimumPower;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nint calculateMaxMinPower(vector<int> &stationPowers, int range, int additionalPower)\n{\n    int numberOfStations = stationPowers.size();\n    vector<int> totalPower(numberOfStations);\n    for(int currentStation = 0; currentStation < numberOfStations; currentStation++)\n    {\n        for(int nearbyStation = max(0, currentStation - range); nearbyStation <= min(numberOfStations - 1, currentStation + range); nearbyStation++)\n        {\n            totalPower[nearbyStation] += stationPowers[currentStation];\n        }\n    }\n\n    int sumOfK = 0, minimumPower = INT_MAX;\n    for(int currentIndex = range; currentIndex < numberOfStations - range; currentIndex++)\n    {\n        sumOfK += stationPowers[currentIndex];\n        minimumPower = min(minimumPower, totalPower[currentIndex]);\n    }\n\n    for(int j = 0, i = numberOfStations - 2 * range; j < 2 * range; j++, i--)\n    {\n        sumOfK -= stationPowers[i + range + 1];\n        minimumPower -= stationPowers[j];\n        minimumPower += sumOfK;\n        minimumPower += additionalPower;\n        minimumPower = min(minimumPower, totalPower[j]);\n    }\n\n    return minimumPower;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxPositiveNegativeCount(const vector<int> &numbers)\n{\n    int positiveCount= upper_bound(numbers.begin(), numbers.end(), -1) - numbers.begin();\n    int negativeCount= numbers.size() - positiveCount;\n    return max(positiveCount, negativeCount);\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint maxPositiveNegativeCount(const vector<int> &numbers)\n{\n    int positiveCount= upper_bound(numbers.begin(), numbers.end(), -1) - numbers.begin();\n    int negativeCount= numbers.size() - positiveCount;\n    return max(positiveCount, negativeCount);\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxScore(const vector<int> &numbers, int numberOfPicks)\n{\n    priority_queue<int> maxHeap(numbers.begin(), numbers.end());\n    int totalScore= 0;\n\n    for(int i= 0; i < numberOfPicks; i++)\n    {\n        int currentNumber= maxHeap.top();\n        maxHeap.pop();\n        totalScore+= currentNumber;\n        maxHeap.push(currentNumber / 3);\n    }\n\n    return totalScore;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <queue>\n#include <vector>\nusing namespace std;\n\nint maxScore(const vector<int> &numbers, int numberOfPicks)\n{\n    priority_queue<int> maxHeap(numbers.begin(), numbers.end());\n    int totalScore= 0;\n\n    for(int i= 0; i < numberOfPicks; i++)\n    {\n        int currentNumber= maxHeap.top();\n        maxHeap.pop();\n        totalScore+= currentNumber;\n        maxHeap.push(currentNumber / 3);\n    }\n\n    return totalScore;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool compare(const string &firstWord, const string &secondWord)\n{\n    array<int, 26> letterCountsFirst = {0}, letterCountsSecond = {0};\n    for (int i = 0; i < firstWord.size(); ++i)\n        letterCountsFirst[firstWord[i] - 'a']++;\n    for (int i = 0; i < secondWord.size(); ++i)\n        letterCountsSecond[secondWord[i] - 'a']++;\n    for (int index = 0; index < 26; ++index)\n    {\n        if (letterCountsFirst[index] && letterCountsSecond[index])\n            return true;\n    }\n    return false;\n}\n\nbool swapEqualDistinct(const string &firstWord, const string &secondWord)\n{\n    bool hasCommonLetter = compare(firstWord, secondWord);\n    return hasCommonLetter && firstWord.size() == secondWord.size();\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <array>\n#include <string>\nusing namespace std;\n\nbool compare(const string &firstWord, const string &secondWord)\n{\n    array<int, 26> letterCountsFirst = {0}, letterCountsSecond = {0};\n    for(char character : firstWord)\n        letterCountsFirst[character - 'a']++;\n    for(char character : secondWord)\n        letterCountsSecond[character - 'a']++;\n    for(int index = 0; index < 26; ++index)\n    {\n        if(letterCountsFirst[index] && letterCountsSecond[index])\n            return true;\n    }\n    return false;\n}\n\nbool swapEqualDistinct(const string &firstWord, const string &secondWord)\n{\n    bool hasCommonLetter = compare(firstWord, secondWord);\n    return hasCommonLetter && firstWord.size() == secondWord.size();\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getLastMoment(int totalMoments, int numElements, vector<vector<int>> &elementTimes)\n{\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> leftQueue, rightQueue;\n    for(int index= 0; index < numElements; index++)\n    {\n        leftQueue.push({elementTimes[index][0] + elementTimes[index][2], index});\n    }\n\n    while(totalMoments)\n    {\n        while(!rightQueue.empty() && rightQueue.top().first <= leftQueue.top().first)\n        {\n            auto rightTopElement= rightQueue.top();\n            rightQueue.pop();\n            leftQueue.push({rightTopElement.first + elementTimes[rightTopElement.second][0] + elementTimes[rightTopElement.second][2], rightTopElement.second});\n        }\n        auto leftTopElement= leftQueue.top();\n        leftQueue.pop();\n        elementTimes[leftTopElement.second][2]+= elementTimes[leftTopElement.second][3] + elementTimes[leftTopElement.second][0] + elementTimes[leftTopElement.second][1];\n        rightQueue.push({leftTopElement.first + elementTimes[leftTopElement.second][1], leftTopElement.second});\n        totalMoments--;\n    }\n\n    int lastMoment= -1;\n    while(!rightQueue.empty())\n    {\n        lastMoment= max(lastMoment, elementTimes[rightQueue.top().second][2]);\n        rightQueue.pop();\n    }\n    return lastMoment;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <algorithm>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nint getLastMoment(int totalMoments, int numElements, vector<vector<int>> &elementTimes)\n{\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> leftQueue, rightQueue;\n    for(int index= 0; index < numElements; index++)\n    {\n        leftQueue.push({elementTimes[index][0] + elementTimes[index][2], index});\n    }\n\n    while(totalMoments)\n    {\n        while(!rightQueue.empty() && rightQueue.top().first <= leftQueue.top().first)\n        {\n            auto rightTopElement= rightQueue.top();\n            rightQueue.pop();\n            leftQueue.push({rightTopElement.first + elementTimes[rightTopElement.second][0] + elementTimes[rightTopElement.second][2], rightTopElement.second});\n        }\n        auto leftTopElement= leftQueue.top();\n        leftQueue.pop();\n        elementTimes[leftTopElement.second][2]+= elementTimes[leftTopElement.second][3] + elementTimes[leftTopElement.second][0] + elementTimes[leftTopElement.second][1];\n        rightQueue.push({leftTopElement.first + elementTimes[leftTopElement.second][1], leftTopElement.second});\n        totalMoments--;\n    }\n\n    int lastMoment= -1;\n    while(!rightQueue.empty())\n    {\n        lastMoment= max(lastMoment, elementTimes[rightQueue.top().second][2]);\n        rightQueue.pop();\n    }\n    return lastMoment;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\n// for std::max\nusing namespace std;\n\nint countGoodStrings(int minLength, int maxLength, int oneGroupSize, int zeroGroupSize, int modulo = 1000000007)\n{\n    int maxCount = maxLength / oneGroupSize + maxLength / zeroGroupSize;\n\n    vector<long long> dynamicProgramming(maxCount + 1);\n    dynamicProgramming[0] = 1;\n\n    for (int index = 1; index <= maxCount; index++)\n        dynamicProgramming[index] = (dynamicProgramming[index - 1] * (index % oneGroupSize == 0 || index % zeroGroupSize == 0)) % modulo;\n\n    long long result = 0;\n    for (int index = 0; index <= maxCount; index++)\n    {\n        result = (result + dynamicProgramming[minLength / oneGroupSize + minLength / zeroGroupSize - index] - \n            (minLength - 1) / oneGroupSize - (minLength - 1) / zeroGroupSize + index < 0 ? 0\n            : dynamicProgramming[(minLength - 1) / oneGroupSize + (minLength - 1) / zeroGroupSize - index]) % modulo;\n    }\n\n    return result;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <vector>\n#include <algorithm> // for std::max\nusing namespace std;\n\nint countGoodStrings(int minLength, int maxLength, int oneGroupSize, int zeroGroupSize, int modulo = 1000000007)\n{\n    int maxCount = maxLength / oneGroupSize + maxLength / zeroGroupSize;\n\n    vector<long long> dynamicProgramming(maxCount + 1);\n    dynamicProgramming[0] = 1;\n\n    for (int index = 1; index <= maxCount; index++)\n        dynamicProgramming[index] = (dynamicProgramming[index - 1] * (index % oneGroupSize == 0 || index % zeroGroupSize == 0)) % modulo;\n\n    long long result = 0;\n    for (int index = 0; index <= maxCount; index++)\n    {\n        result = (result + dynamicProgramming[minLength / oneGroupSize + minLength / zeroGroupSize - index] - \n            (minLength - 1) / oneGroupSize - (minLength - 1) / zeroGroupSize + index < 0 ? 0\n            : dynamicProgramming[(minLength - 1) / oneGroupSize + (minLength - 1) / zeroGroupSize - index]) % modulo;\n    }\n\n    return result;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> timeCrossingTheDoor(vector<int> &arrivalTimes, vector<int> &personState)\n{\n    int numberOfPersons= arrivalTimes.size();\n    vector<int> crossingTimes(numberOfPersons);\n    vector<int> lastSeenTimeAtDoor(2, -1);\n\n    for(int personIndex= 0, currentTime= 0; personIndex < numberOfPersons; ++personIndex, ++currentTime)\n    {\n        while(currentTime < arrivalTimes[personIndex])\n            currentTime++;\n\n        int direction= (lastSeenTimeAtDoor[1] != currentTime - 1) ? 1 : 0;\n\n        if(personState[personIndex] == direction)\n        {\n            lastSeenTimeAtDoor[personState[personIndex]]= currentTime;\n        }\n        else\n        {\n            while(personIndex + 1 < numberOfPersons && arrivalTimes[personIndex + 1] == currentTime && personState[personIndex + 1] != direction)\n                ++personIndex;\n\n            if(personIndex + 1 < numberOfPersons && arrivalTimes[personIndex + 1] == currentTime && personState[personIndex + 1] == direction)\n            {\n                lastSeenTimeAtDoor[personState[personIndex= personIndex + 1]]= currentTime;\n            }\n            else\n            {\n                currentTime--, personIndex--;\n            }\n        }\n        crossingTimes[personIndex]= lastSeenTimeAtDoor[personState[personIndex]];\n    }\n    return crossingTimes;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <vector>\nusing namespace std;\n\nvector<int> timeCrossingTheDoor(vector<int> &arrivalTimes, vector<int> &personState)\n{\n    int numberOfPersons= arrivalTimes.size();\n    vector<int> crossingTimes(numberOfPersons);\n    vector<int> lastSeenTimeAtDoor(2, -1);\n\n    for(int personIndex= 0, currentTime= 0; personIndex < numberOfPersons; ++personIndex, ++currentTime)\n    {\n        while(currentTime < arrivalTimes[personIndex])\n            currentTime++;\n\n        int direction= (lastSeenTimeAtDoor[1] != currentTime - 1) ? 1 : 0;\n\n        if(personState[personIndex] == direction)\n        {\n            lastSeenTimeAtDoor[personState[personIndex]]= currentTime;\n        }\n        else\n        {\n            while(personIndex + 1 < numberOfPersons && arrivalTimes[personIndex + 1] == currentTime && personState[personIndex + 1] != direction)\n                ++personIndex;\n\n            if(personIndex + 1 < numberOfPersons && arrivalTimes[personIndex + 1] == currentTime && personState[personIndex + 1] == direction)\n            {\n                lastSeenTimeAtDoor[personState[personIndex= personIndex + 1]]= currentTime;\n            }\n            else\n            {\n                currentTime--, personIndex--;\n            }\n        }\n        crossingTimes[personIndex]= lastSeenTimeAtDoor[personState[personIndex]];\n    }\n    return crossingTimes;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\n// For abs function\nusing namespace std;\n\nint differenceBetweenElementAndDigitSum(vector<int> &numbers)\n{\n    int totalElementSum = 0, totalDigitSum = 0;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int currentNumber = numbers[i];\n        totalElementSum += currentNumber;\n        int tempNumber = currentNumber; // Create a temporary variable to hold the current number\n        while (tempNumber > 0)\n        {\n            totalDigitSum += tempNumber % 10;\n            tempNumber /= 10;\n        }\n    }\n    return abs(totalElementSum - totalDigitSum);\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <vector>\n#include <cstdlib> // For abs function\nusing namespace std;\n\nint differenceBetweenElementAndDigitSum(vector<int> &numbers)\n{\n    int totalElementSum= 0, totalDigitSum= 0;\n    for(int currentNumber : numbers)\n    {\n        totalElementSum+= currentNumber;\n        int tempNumber= currentNumber; // Create a temporary variable to hold the current number\n        while(tempNumber > 0)\n        {\n            totalDigitSum+= tempNumber % 10;\n            tempNumber/= 10;\n        }\n    }\n    return abs(totalElementSum - totalDigitSum);\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> applyQueries(int matrixSize, vector<vector<int>> &queryList)\n{\n    vector<vector<int>> matrix(matrixSize, vector<int>(matrixSize, 0));\n\n    for (int i = 0; i < queryList.size(); ++i)\n    {\n        auto &query = queryList[i];\n        for (int row = query[0]; row <= query[2]; ++row)\n        {\n            for (int col = query[1]; col <= query[3]; ++col)\n            {\n                matrix[row][col]++;\n            }\n        }\n    }\n\n    return matrix;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <vector>\nusing namespace std;\n\nvector<vector<int>> applyQueries(int matrixSize, vector<vector<int>> &queryList)\n{\n    vector<vector<int>> matrix(matrixSize, vector<int>(matrixSize, 0));\n\n    for(auto &query : queryList)\n    {\n        for(int row= query[0]; row <= query[2]; ++row)\n        {\n            for(int col= query[1]; col <= query[3]; ++col)\n            {\n                matrix[row][col]++;\n            }\n        }\n    }\n\n    return matrix;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countGoodSubarrays(vector<int> &numbers, int targetSum)\n{\n    unordered_map<int, int> prefixSumCount;\n    int totalGoodSubarrays = 0, currentPrefixSum = 0;\n\n    prefixSumCount[0] = 1;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int number = numbers[i];\n        currentPrefixSum += number - 1;\n        totalGoodSubarrays += prefixSumCount[currentPrefixSum - targetSum];\n        prefixSumCount[currentPrefixSum]++;\n    }\n\n    return totalGoodSubarrays;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint countGoodSubarrays(vector<int> &numbers, int targetSum)\n{\n    unordered_map<int, int> prefixSumCount;\n    int totalGoodSubarrays= 0, currentPrefixSum= 0;\n\n    prefixSumCount[0]= 1;\n    for(int number : numbers)\n    {\n        currentPrefixSum+= number - 1;\n        totalGoodSubarrays+= prefixSumCount[currentPrefixSum - targetSum];\n        prefixSumCount[currentPrefixSum]++;\n    }\n\n    return totalGoodSubarrays;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adjacencyList;\nvector<int> nodePrices;\nvector<pair<vector<long long>, vector<long long>>> dynamicProgramming;\n\nvoid depthFirstSearch(int currentNode, int parentNode)\n{\n    dynamicProgramming[currentNode].first[0] = nodePrices[currentNode];\n    dynamicProgramming[currentNode].first[1] = 0;\n    dynamicProgramming[currentNode].second[0] = nodePrices[currentNode];\n    dynamicProgramming[currentNode].second[1] = 0;\n\n    for (int i = 0; i < adjacencyList[currentNode].size(); ++i)\n    {\n        int neighborNode = adjacencyList[currentNode][i];\n        if (neighborNode == parentNode)\n            continue;\n        depthFirstSearch(neighborNode, currentNode);\n        dynamicProgramming[currentNode].first.push_back(dynamicProgramming[neighborNode].first[0] + nodePrices[currentNode] - dynamicProgramming[neighborNode].second[0]);\n        dynamicProgramming[currentNode].first.push_back(dynamicProgramming[neighborNode].first[1]);\n        dynamicProgramming[currentNode].second.push_back(dynamicProgramming[neighborNode].second[0] + nodePrices[currentNode] - dynamicProgramming[neighborNode].first[0]);\n        dynamicProgramming[currentNode].second.push_back(dynamicProgramming[neighborNode].second[1]);\n\n        sort(dynamicProgramming[currentNode].first.begin(), dynamicProgramming[currentNode].first.end());\n        sort(dynamicProgramming[currentNode].second.begin(), dynamicProgramming[currentNode].second.end());\n    }\n}\n\nint getMaxCost(int numberOfNodes, vector<vector<int>> &edges, vector<int> &priceList)\n{\n    adjacencyList.resize(numberOfNodes);\n    nodePrices = priceList;\n    dynamicProgramming.resize(numberOfNodes, pair<vector<long long>, vector<long long>>(vector<long long>(2), vector<long long>(2)));\n\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        vector<int> &edge = edges[i];\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    depthFirstSearch(0, -1);\n\n    long long maximumCost = 0;\n    for (int i = 0; i < numberOfNodes; ++i)\n    {\n        maximumCost = max(maximumCost, dynamicProgramming[i].first.back() - dynamicProgramming[i].second.back());\n    }\n\n    return maximumCost;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <algorithm>\n#include <vector>\nusing namespace std;\n\nvector<vector<int>> adjacencyList;\nvector<int> nodePrices;\nvector<pair<vector<long long>, vector<long long>>> dynamicProgramming;\n\nvoid depthFirstSearch(int currentNode, int parentNode)\n{\n    dynamicProgramming[currentNode].first[0]= nodePrices[currentNode];\n    dynamicProgramming[currentNode].first[1]= 0;\n    dynamicProgramming[currentNode].second[0]= nodePrices[currentNode];\n    dynamicProgramming[currentNode].second[1]= 0;\n\n    for(int neighborNode : adjacencyList[currentNode])\n    {\n        if(neighborNode == parentNode)\n            continue;\n        depthFirstSearch(neighborNode, currentNode);\n        dynamicProgramming[currentNode].first.push_back(dynamicProgramming[neighborNode].first[0] + nodePrices[currentNode] - dynamicProgramming[neighborNode].second[0]);\n        dynamicProgramming[currentNode].first.push_back(dynamicProgramming[neighborNode].first[1]);\n        dynamicProgramming[currentNode].second.push_back(dynamicProgramming[neighborNode].second[0] + nodePrices[currentNode] - dynamicProgramming[neighborNode].first[0]);\n        dynamicProgramming[currentNode].second.push_back(dynamicProgramming[neighborNode].second[1]);\n\n        sort(dynamicProgramming[currentNode].first.begin(), dynamicProgramming[currentNode].first.end());\n        sort(dynamicProgramming[currentNode].second.begin(), dynamicProgramming[currentNode].second.end());\n    }\n}\n\nint getMaxCost(int numberOfNodes, vector<vector<int>> &edges, vector<int> &priceList)\n{\n    adjacencyList.resize(numberOfNodes);\n    nodePrices= priceList;\n    dynamicProgramming.resize(numberOfNodes, pair<vector<long long>, vector<long long>>(vector<long long>(2), vector<long long>(2)));\n\n    for(vector<int> &edge : edges)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    depthFirstSearch(0, -1);\n\n    long long maximumCost= 0;\n    for(int i= 0; i < numberOfNodes; ++i)\n    {\n        maximumCost= max(maximumCost, dynamicProgramming[i].first.back() - dynamicProgramming[i].second.back());\n    }\n\n    return maximumCost;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countOfGoodSubsequences(string inputString)\n{\n    vector<int> characterCount(26, 0);\n    long totalCount = 0;\n    const int modulo = 1000000007;\n\n    for (char currentChar : inputString)\n    {\n        characterCount[currentChar - 'a']++;\n    }\n\n    for (int i = 0; i < characterCount.size(); ++i)\n    {\n        int occurrence = characterCount[i];\n        totalCount = (totalCount + (1L << occurrence) - 1) % modulo;\n    }\n\n    return totalCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <string>\n#include <vector>\nusing namespace std;\n\nint countOfGoodSubsequences(string inputString)\n{\n    vector<int> characterCount(26, 0);\n    long totalCount= 0;\n    const int modulo= 1000000007;\n\n    for(char currentChar : inputString)\n    {\n        characterCount[currentChar - 'a']++;\n    }\n\n    for(int occurrence : characterCount)\n    {\n        totalCount= (totalCount + (1L << occurrence) - 1) % modulo;\n    }\n\n    return totalCount;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint findMinimumCommonNumber(vector<int> &firstArray, vector<int> &secondArray)\n{\n    int firstIndex= 0, secondIndex= 0;\n    while(firstIndex < firstArray.size() && secondIndex < secondArray.size())\n    {\n        if(firstArray[firstIndex] == secondArray[secondIndex])\n        {\n            return firstArray[firstIndex];\n        }\n        else if(firstArray[firstIndex] < secondArray[secondIndex])\n        {\n            firstIndex++;\n        }\n        else\n        {\n            secondIndex++;\n        }\n    }\n    return -1;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <vector>\nusing namespace std;\n\nint findMinimumCommonNumber(vector<int> &firstArray, vector<int> &secondArray)\n{\n    int firstIndex= 0, secondIndex= 0;\n    while(firstIndex < firstArray.size() && secondIndex < secondArray.size())\n    {\n        if(firstArray[firstIndex] == secondArray[secondIndex])\n        {\n            return firstArray[firstIndex];\n        }\n        else if(firstArray[firstIndex] < secondArray[secondIndex])\n        {\n            firstIndex++;\n        }\n        else\n        {\n            secondIndex++;\n        }\n    }\n    return -1;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\n// For abs function\nusing namespace std;\n\nint minChanges(vector<int> &firstArray, vector<int> &secondArray, int differenceFactor)\n{\n    int arraySize= firstArray.size();\n    int totalOperations= 0;\n    for(int index= 0; index < arraySize; ++index)\n    {\n        int difference= abs(firstArray[index] - secondArray[index]);\n        if(difference % differenceFactor != 0)\n            return -1;\n        totalOperations+= difference / differenceFactor;\n    }\n    return totalOperations;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <vector>\n#include <cmath> // For abs function\nusing namespace std;\n\nint minChanges(vector<int> &firstArray, vector<int> &secondArray, int differenceFactor)\n{\n    int arraySize= firstArray.size();\n    int totalOperations= 0;\n    for(int index= 0; index < arraySize; ++index)\n    {\n        int difference= abs(firstArray[index] - secondArray[index]);\n        if(difference % differenceFactor != 0)\n            return -1;\n        totalOperations+= difference / differenceFactor;\n    }\n    return totalOperations;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxScore(vector<int> &firstArray, vector<int> &secondArray, int maxElements)\n{\n    int arraySize = firstArray.size();\n    int maximumResult = 0;\n    int sumFirstArray = 0, minimumSecondArray = secondArray[0];\n    for(int startIndex = 0, endIndex = 0; endIndex < arraySize; ++endIndex)\n    {\n        sumFirstArray += firstArray[endIndex];\n        minimumSecondArray = min(minimumSecondArray, secondArray[endIndex]);\n        if(endIndex - startIndex + 1 > maxElements)\n            sumFirstArray -= firstArray[startIndex++];\n        if(endIndex + 1 >= maxElements)\n            maximumResult = max(maximumResult, sumFirstArray * minimumSecondArray);\n    }\n    return maximumResult;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint maxScore(vector<int> &firstArray, vector<int> &secondArray, int maxElements)\n{\n    int arraySize = firstArray.size();\n    int maximumResult = 0;\n    int sumFirstArray = 0, minimumSecondArray = secondArray[0];\n    for(int startIndex = 0, endIndex = 0; endIndex < arraySize; ++endIndex)\n    {\n        sumFirstArray += firstArray[endIndex];\n        minimumSecondArray = min(minimumSecondArray, secondArray[endIndex]);\n        if(endIndex - startIndex + 1 > maxElements)\n            sumFirstArray -= firstArray[startIndex++];\n        if(endIndex + 1 >= maxElements)\n            maximumResult = max(maximumResult, sumFirstArray * minimumSecondArray);\n    }\n    return maximumResult;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nbool canReach(int targetX, int targetY)\n{\n    while(targetX > 1 && targetY > 1)\n    {\n        if(targetX < targetY)\n            swap(targetX, targetY);\n        targetX-= targetY;\n    }\n    return targetX == 1 || targetY == 1;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "bool canReach(int targetX, int targetY)\n{\n    while(targetX > 1 && targetY > 1)\n    {\n        if(targetX < targetY)\n            swap(targetX, targetY);\n        targetX-= targetY;\n    }\n    return targetX == 1 || targetY == 1;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint sumOfDigits(int inputNumber)\n{\n    int digitSum= 0;\n    bool isPositive= true;\n\n    while(inputNumber > 0)\n    {\n        int currentDigit= inputNumber % 10;\n        inputNumber/= 10;\n\n        if(isPositive)\n        {\n            digitSum+= currentDigit;\n        }\n        else\n        {\n            digitSum-= currentDigit;\n        }\n\n        isPositive= !isPositive;\n    }\n\n    return digitSum;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int sumOfDigits(int inputNumber)\n{\n    int digitSum= 0;\n    bool isPositive= true;\n\n    while(inputNumber > 0)\n    {\n        int currentDigit= inputNumber % 10;\n        inputNumber/= 10;\n\n        if(isPositive)\n        {\n            digitSum+= currentDigit;\n        }\n        else\n        {\n            digitSum-= currentDigit;\n        }\n\n        isPositive= !isPositive;\n    }\n\n    return digitSum;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> sortStudents(vector<vector<int>> &studentScores, int scoreIndex)\n{\n    sort(studentScores.begin(), studentScores.end(), [scoreIndex](const vector<int> &firstStudent, const vector<int> &secondStudent)\n         { return firstStudent[scoreIndex] > secondStudent[scoreIndex]; });\n    return studentScores;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <algorithm>\n#include <vector>\nusing namespace std;\n\nvector<vector<int>> sortStudents(vector<vector<int>> &studentScores, int scoreIndex)\n{\n    sort(studentScores.begin(), studentScores.end(), [scoreIndex](const vector<int> &firstStudent, const vector<int> &secondStudent)\n         { return firstStudent[scoreIndex] > secondStudent[scoreIndex]; });\n    return studentScores;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool canMakeEqual(string sourceString, string targetString)\n{\n    int sourceCountOnes= count(sourceString.begin(), sourceString.end(), '1');\n    int targetCountOnes= count(targetString.begin(), targetString.end(), '1');\n    return sourceCountOnes >= targetCountOnes;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool canMakeEqual(string sourceString, string targetString)\n{\n    int sourceCountOnes= count(sourceString.begin(), sourceString.end(), '1');\n    int targetCountOnes= count(targetString.begin(), targetString.end(), '1');\n    return sourceCountOnes >= targetCountOnes;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\n// For std::min\nusing namespace std;\n\nint getCost(int endIndex, vector<int> &frequencyCount, vector<int> &numberList)\n{\n    return frequencyCount[numberList[endIndex]] == 1 ? 1 : 0;\n}\n\nint minCost(vector<int> &numberList, int cost)\n{\n    int listSize= numberList.size(), infinity= 1e9 + 7;\n    vector<int> frequencyCount(1001, 0), dynamicProgramming(listSize + 1, 0); // frequencyCount for frequency, dynamicProgramming for dynamic programming\n\n    for(int startIndex= 0, endIndex= 0; endIndex < listSize; ++endIndex)\n    {\n        ++frequencyCount[numberList[endIndex]];\n\n        if(frequencyCount[numberList[endIndex]] == 2) // if occurrence is 2, change dynamicProgramming\n            dynamicProgramming[endIndex + 1]= dynamicProgramming[startIndex] + cost + (endIndex - startIndex + 1);\n        else if(frequencyCount[numberList[endIndex]] > 2) // if occurrence is more than 2\n            dynamicProgramming[endIndex + 1]= min(dynamicProgramming[endIndex], dynamicProgramming[endIndex - 1] - (frequencyCount[numberList[endIndex]] - 2));\n        else\n            dynamicProgramming[endIndex + 1]= dynamicProgramming[endIndex] + getCost(endIndex, frequencyCount, numberList) + cost;\n\n        while(startIndex < endIndex + 1 && frequencyCount[numberList[startIndex]] >= 2)\n        {\n            --frequencyCount[numberList[startIndex]];\n            ++startIndex; // update first pointer startIndex when numberList[startIndex] has occurred more than once\n        }\n    }\n\n    return dynamicProgramming[listSize];\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <vector>\n#include <algorithm> // For std::min\nusing namespace std;\n\nint getCost(int endIndex, vector<int> &frequencyCount, vector<int> &numberList)\n{\n    return frequencyCount[numberList[endIndex]] == 1 ? 1 : 0;\n}\n\nint minCost(vector<int> &numberList, int cost)\n{\n    int listSize= numberList.size(), infinity= 1e9 + 7;\n    vector<int> frequencyCount(1001, 0), dynamicProgramming(listSize + 1, 0); // frequencyCount for frequency, dynamicProgramming for dynamic programming\n\n    for(int startIndex= 0, endIndex= 0; endIndex < listSize; ++endIndex)\n    {\n        ++frequencyCount[numberList[endIndex]];\n\n        if(frequencyCount[numberList[endIndex]] == 2) // if occurrence is 2, change dynamicProgramming\n            dynamicProgramming[endIndex + 1]= dynamicProgramming[startIndex] + cost + (endIndex - startIndex + 1);\n        else if(frequencyCount[numberList[endIndex]] > 2) // if occurrence is more than 2\n            dynamicProgramming[endIndex + 1]= min(dynamicProgramming[endIndex], dynamicProgramming[endIndex - 1] - (frequencyCount[numberList[endIndex]] - 2));\n        else\n            dynamicProgramming[endIndex + 1]= dynamicProgramming[endIndex] + getCost(endIndex, frequencyCount, numberList) + cost;\n\n        while(startIndex < endIndex + 1 && frequencyCount[numberList[startIndex]] >= 2)\n        {\n            --frequencyCount[numberList[startIndex]];\n            ++startIndex; // update first pointer startIndex when numberList[startIndex] has occurred more than once\n        }\n    }\n\n    return dynamicProgramming[listSize];\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble maxValue(vector<vector<int>> &items, int capacity)\n{\n    sort(items.begin(), items.end(), [](const vector<int> &a, const vector<int> &b)\n         { return (double)a[0] / a[1] > (double)b[0] / b[1]; });\n\n    double maxTotalPrice = 0;\n    for (int i = 0; i < items.size(); ++i)\n    {\n        const auto &item = items[i];\n        if (capacity >= item[1])\n        {\n            capacity -= item[1];\n            maxTotalPrice += item[0];\n        }\n        else\n        {\n            maxTotalPrice += (double)item[0] * capacity / item[1];\n            break;\n        }\n    }\n\n    return maxTotalPrice;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <algorithm>\n#include <vector>\nusing namespace std;\n\ndouble maxValue(vector<vector<int>> &items, int capacity)\n{\n    sort(items.begin(), items.end(), [](const vector<int> &a, const vector<int> &b)\n         { return (double)a[0] / a[1] > (double)b[0] / b[1]; });\n\n    double maxTotalPrice= 0;\n    for(const auto &item : items)\n    {\n        if(capacity >= item[1])\n        {\n            capacity-= item[1];\n            maxTotalPrice+= item[0];\n        }\n        else\n        {\n            maxTotalPrice+= (double)item[0] * capacity / item[1];\n            break;\n        }\n    }\n\n    return maxTotalPrice;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint distinctCount(int totalNumbers)\n{\n    return totalNumbers - 1;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int distinctCount(int totalNumbers)\n{\n    return totalNumbers - 1;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod= 1e9 + 7;\n\nint waysToCollide(int numberOfObjects)\n{\n    int powerOfTwo= 1;\n    for(int index= 0; index < numberOfObjects; index++)\n    {\n        powerOfTwo= (2LL * powerOfTwo) % mod;\n    }\n    return (powerOfTwo - numberOfObjects - 1 + mod) % mod;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <iostream>\nusing namespace std;\n\nconst int mod= 1e9 + 7;\n\nint waysToCollide(int numberOfObjects)\n{\n    int powerOfTwo= 1;\n    for(int index= 0; index < numberOfObjects; index++)\n    {\n        powerOfTwo= (2LL * powerOfTwo) % mod;\n    }\n    return (powerOfTwo - numberOfObjects - 1 + mod) % mod;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maximizeScore(vector<int> &weightValues, int numberOfGroups)\n{\n    int totalWeights= weightValues.size();\n    vector<int> prefixSum(totalWeights + 1);\n    partial_sum(weightValues.begin(), weightValues.end(), prefixSum.begin() + 1);\n    vector<vector<int>> dynamicProgramming(totalWeights, vector<int>(numberOfGroups + 1));\n\n    for(int currentIndex= 0; currentIndex < totalWeights; currentIndex++)\n    {\n        for(int groupIndex= 1; groupIndex <= numberOfGroups; groupIndex++)\n        {\n            dynamicProgramming[currentIndex][groupIndex]= -1e9;\n        }\n    }\n\n    for(int currentIndex= 0; currentIndex < totalWeights; currentIndex++)\n    {\n        dynamicProgramming[currentIndex][1]= prefixSum[currentIndex + 1];\n        if(currentIndex > 0)\n        {\n            dynamicProgramming[currentIndex][currentIndex + 1]= prefixSum[currentIndex + 1] - prefixSum[1];\n        }\n        for(int groupIndex= 2; groupIndex <= min<int>(currentIndex + 1, numberOfGroups); groupIndex++)\n        {\n            for(int previousGroupSize= 1; previousGroupSize <= currentIndex - groupIndex + 2; previousGroupSize++)\n            {\n                dynamicProgramming[currentIndex][groupIndex]= max(dynamicProgramming[currentIndex][groupIndex],\n                                                                   dynamicProgramming[currentIndex - previousGroupSize][groupIndex - 1] + weightValues[currentIndex] + weightValues[currentIndex - previousGroupSize]);\n            }\n        }\n    }\n\n    return dynamicProgramming[totalWeights - 1][numberOfGroups] - dynamicProgramming[totalWeights - 1][1];\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <algorithm>\n#include <numeric>\n#include <vector>\nusing namespace std;\n\nint maximizeScore(vector<int> &weightValues, int numberOfGroups)\n{\n    int totalWeights= weightValues.size();\n    vector<int> prefixSum(totalWeights + 1);\n    partial_sum(weightValues.begin(), weightValues.end(), prefixSum.begin() + 1);\n    vector<vector<int>> dynamicProgramming(totalWeights, vector<int>(numberOfGroups + 1));\n\n    for(int currentIndex= 0; currentIndex < totalWeights; currentIndex++)\n    {\n        for(int groupIndex= 1; groupIndex <= numberOfGroups; groupIndex++)\n        {\n            dynamicProgramming[currentIndex][groupIndex]= -1e9;\n        }\n    }\n\n    for(int currentIndex= 0; currentIndex < totalWeights; currentIndex++)\n    {\n        dynamicProgramming[currentIndex][1]= prefixSum[currentIndex + 1];\n        if(currentIndex > 0)\n        {\n            dynamicProgramming[currentIndex][currentIndex + 1]= prefixSum[currentIndex + 1] - prefixSum[1];\n        }\n        for(int groupIndex= 2; groupIndex <= min<int>(currentIndex + 1, numberOfGroups); groupIndex++)\n        {\n            for(int previousGroupSize= 1; previousGroupSize <= currentIndex - groupIndex + 2; previousGroupSize++)\n            {\n                dynamicProgramming[currentIndex][groupIndex]= max(dynamicProgramming[currentIndex][groupIndex],\n                                                                   dynamicProgramming[currentIndex - previousGroupSize][groupIndex - 1] + weightValues[currentIndex] + weightValues[currentIndex - previousGroupSize]);\n            }\n        }\n    }\n\n    return dynamicProgramming[totalWeights - 1][numberOfGroups] - dynamicProgramming[totalWeights - 1][1];\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countIncreasingQuadruplets(vector<int> &numberList)\n{\n    int listSize= numberList.size(), quadrupletCount= 0;\n    for(int firstIndex= 0; firstIndex < listSize - 3; firstIndex++)\n    {\n        for(int secondIndex= firstIndex + 1; secondIndex < listSize - 2; secondIndex++)\n        {\n            for(int thirdIndex= secondIndex + 1; thirdIndex < listSize - 1; thirdIndex++)\n            {\n                if(numberList[firstIndex] < numberList[thirdIndex] && numberList[thirdIndex] < numberList[secondIndex])\n                {\n                    for(int fourthIndex= thirdIndex + 1; fourthIndex < listSize; fourthIndex++)\n                    {\n                        if(numberList[secondIndex] < numberList[fourthIndex])\n                        {\n                            quadrupletCount++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return quadrupletCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <vector>\nusing namespace std;\n\nint countIncreasingQuadruplets(vector<int> &numberList)\n{\n    int listSize= numberList.size(), quadrupletCount= 0;\n    for(int firstIndex= 0; firstIndex < listSize - 3; firstIndex++)\n    {\n        for(int secondIndex= firstIndex + 1; secondIndex < listSize - 2; secondIndex++)\n        {\n            for(int thirdIndex= secondIndex + 1; thirdIndex < listSize - 1; thirdIndex++)\n            {\n                if(numberList[firstIndex] < numberList[thirdIndex] && numberList[thirdIndex] < numberList[secondIndex])\n                {\n                    for(int fourthIndex= thirdIndex + 1; fourthIndex < listSize; fourthIndex++)\n                    {\n                        if(numberList[secondIndex] < numberList[fourthIndex])\n                        {\n                            quadrupletCount++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return quadrupletCount;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> separateDigits(const vector<int> &inputNumbers)\n{\n    vector<int> resultDigits;\n    for (int i = 0; i < inputNumbers.size(); ++i)\n    {\n        int currentNumber = inputNumbers[i];\n        vector<int> extractedDigits;\n        while (currentNumber)\n        {\n            extractedDigits.insert(extractedDigits.begin(), currentNumber % 10);\n            currentNumber /= 10;\n        }\n        resultDigits.insert(resultDigits.end(), extractedDigits.begin(), extractedDigits.end());\n    }\n    return resultDigits;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> separateDigits(const vector<int> &inputNumbers)\n{\n    vector<int> resultDigits;\n    for(auto currentNumber : inputNumbers)\n    {\n        vector<int> extractedDigits;\n        while(currentNumber)\n        {\n            extractedDigits.insert(extractedDigits.begin(), currentNumber % 10);\n            currentNumber /= 10;\n        }\n        resultDigits.insert(resultDigits.end(), extractedDigits.begin(), extractedDigits.end());\n    }\n    return resultDigits;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxChosenIntegers(vector<int> &bannedIntegers, int totalIntegers, int maxSum)\n{\n    unordered_set<int> bannedSet(bannedIntegers.begin(), bannedIntegers.end());\n    int chosenCount= 0, currentSum= 0;\n    for(int integer= totalIntegers; integer >= 1 && maxSum - currentSum >= integer; --integer)\n    {\n        if(bannedSet.find(integer) == bannedSet.end())\n        {\n            currentSum+= integer;\n            ++chosenCount;\n        }\n    }\n    return chosenCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <unordered_set>\n#include <vector>\nusing namespace std;\n\nint maxChosenIntegers(vector<int> &bannedIntegers, int totalIntegers, int maxSum)\n{\n    unordered_set<int> bannedSet(bannedIntegers.begin(), bannedIntegers.end());\n    int chosenCount= 0, currentSum= 0;\n    for(int integer= totalIntegers; integer >= 1 && maxSum - currentSum >= integer; --integer)\n    {\n        if(bannedSet.find(integer) == bannedSet.end())\n        {\n            currentSum+= integer;\n            ++chosenCount;\n        }\n    }\n    return chosenCount;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxPrizes(vector<int> &prizePositions, int maxDistance)\n{\n    int totalPositions= prizePositions.size();\n    int maximumPrizes= 0;\n    for(int currentIndex= 0; currentIndex < totalPositions; ++currentIndex)\n    {\n        int leftSegmentEnd= prizePositions[currentIndex] + maxDistance;\n        int rightSegmentStart= upper_bound(prizePositions.begin(), prizePositions.end(), leftSegmentEnd) - prizePositions.begin();\n        int rightSegmentEnd= prizePositions[rightSegmentStart] + maxDistance;\n        maximumPrizes= max(maximumPrizes, int(upper_bound(prizePositions.begin(), prizePositions.end(), rightSegmentEnd) - lower_bound(prizePositions.begin(), prizePositions.end(), prizePositions[currentIndex])));\n    }\n    return maximumPrizes;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint maxPrizes(vector<int> &prizePositions, int maxDistance)\n{\n    int totalPositions= prizePositions.size();\n    int maximumPrizes= 0;\n    for(int currentIndex= 0; currentIndex < totalPositions; ++currentIndex)\n    {\n        int leftSegmentEnd= prizePositions[currentIndex] + maxDistance;\n        int rightSegmentStart= upper_bound(prizePositions.begin(), prizePositions.end(), leftSegmentEnd) - prizePositions.begin();\n        int rightSegmentEnd= prizePositions[rightSegmentStart] + maxDistance;\n        maximumPrizes= max(maximumPrizes, int(upper_bound(prizePositions.begin(), prizePositions.end(), rightSegmentEnd) - lower_bound(prizePositions.begin(), prizePositions.end(), prizePositions[currentIndex])));\n    }\n    return maximumPrizes;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool canReach(vector<vector<int>> &grid, int currentRow, int currentCol)\n{\n    if(currentRow < 0 || currentCol < 0 || currentRow >= grid.size() || currentCol >= grid[0].size() || grid[currentRow][currentCol] == 0)\n        return false;\n\n    if(currentRow == grid.size() - 1 && currentCol == grid[0].size() - 1)\n        return true;\n\n    grid[currentRow][currentCol]= 0;\n\n    return canReach(grid, currentRow + 1, currentCol) || canReach(grid, currentRow, currentCol + 1);\n}\n\nbool canDisconnect(vector<vector<int>> &grid)\n{\n    int reachableCount= 0;\n\n    for(int currentRow= 1; currentRow < grid.size(); currentRow++)\n    {\n        for(int currentCol= 1; currentCol < grid[0].size(); currentCol++)\n        {\n            if(grid[currentRow][currentCol] == 1 && (canReach(grid, currentRow - 1, currentCol) || canReach(grid, currentRow, currentCol - 1)))\n            {\n                reachableCount++;\n                if(reachableCount > 1)\n                    return true;\n            }\n        }\n    }\n\n    return reachableCount <= 1;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <vector>\nusing namespace std;\n\nbool canReach(vector<vector<int>> &grid, int currentRow, int currentCol)\n{\n    if(currentRow < 0 || currentCol < 0 || currentRow >= grid.size() || currentCol >= grid[0].size() || grid[currentRow][currentCol] == 0)\n        return false;\n\n    if(currentRow == grid.size() - 1 && currentCol == grid[0].size() - 1)\n        return true;\n\n    grid[currentRow][currentCol]= 0;\n\n    return canReach(grid, currentRow + 1, currentCol) || canReach(grid, currentRow, currentCol + 1);\n}\n\nbool canDisconnect(vector<vector<int>> &grid)\n{\n    int reachableCount= 0;\n\n    for(int currentRow= 1; currentRow < grid.size(); currentRow++)\n    {\n        for(int currentCol= 1; currentCol < grid[0].size(); currentCol++)\n        {\n            if(grid[currentRow][currentCol] == 1 && (canReach(grid, currentRow - 1, currentCol) || canReach(grid, currentRow, currentCol - 1)))\n            {\n                reachableCount++;\n                if(reachableCount > 1)\n                    return true;\n            }\n        }\n    }\n\n    return reachableCount <= 1;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxChosenIntegers(vector<int> &bannedIntegers, int totalIntegers, long long maxAllowedSum)\n{\n    unordered_set<int> bannedSet(bannedIntegers.begin(), bannedIntegers.end());\n    int countChosenIntegers= 0;\n    long long currentChosenSum= 0;\n\n    for(int i= totalIntegers; i > 0 && currentChosenSum < maxAllowedSum; --i)\n    {\n        if(bannedSet.find(i) == bannedSet.end())\n        {\n            if(currentChosenSum + i <= maxAllowedSum)\n            {\n                currentChosenSum+= i;\n                countChosenIntegers++;\n            }\n            else\n            {\n                break;\n            }\n        }\n    }\n\n    return countChosenIntegers;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nint maxChosenIntegers(vector<int> &bannedIntegers, int totalIntegers, long long maxAllowedSum)\n{\n    unordered_set<int> bannedSet(bannedIntegers.begin(), bannedIntegers.end());\n    int countChosenIntegers= 0;\n    long long currentChosenSum= 0;\n\n    for(int i= totalIntegers; i > 0 && currentChosenSum < maxAllowedSum; --i)\n    {\n        if(bannedSet.find(i) == bannedSet.end())\n        {\n            if(currentChosenSum + i <= maxAllowedSum)\n            {\n                currentChosenSum+= i;\n                countChosenIntegers++;\n            }\n            else\n            {\n                break;\n            }\n        }\n    }\n\n    return countChosenIntegers;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint giftsRemaining(vector<int> &giftValues, int numberOfIterations)\n{\n    for(int iteration = 0; iteration < numberOfIterations; iteration++)\n    {\n        sort(giftValues.begin(), giftValues.end());\n        int maxIndex = giftValues.size() - 1;\n        giftValues[maxIndex] -= static_cast<int>(sqrt(giftValues[maxIndex]));\n    }\n    int totalRemainingGifts = 0;\n    for(int j = 0; j < giftValues.size(); j++)\n        totalRemainingGifts += giftValues[j];\n    return totalRemainingGifts;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <algorithm>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nint giftsRemaining(vector<int> &giftValues, int numberOfIterations)\n{\n    for(int iteration= 0; iteration < numberOfIterations; iteration++)\n    {\n        sort(giftValues.begin(), giftValues.end());\n        int maxIndex= giftValues.size() - 1;\n        giftValues[maxIndex]-= static_cast<int>(sqrt(giftValues[maxIndex]));\n    }\n    int totalRemainingGifts= 0;\n    for(int gift : giftValues)\n        totalRemainingGifts+= gift;\n    return totalRemainingGifts;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isVowel(char character)\n{\n    return character == 'a' || character == 'e' || character == 'i' || character == 'o' || character == 'u';\n}\n\nvector<int> countVowelStrings(vector<string> &wordList, vector<vector<int>> &queryRanges)\n{\n    vector<int> result;\n    for (int i = 0; i < queryRanges.size(); ++i)\n    {\n        auto &query = queryRanges[i];\n        int vowelStringCount = 0;\n        for (int index = query[0]; index <= query[1]; index++)\n        {\n            if (isVowel(wordList[index].front()) && isVowel(wordList[index].back()))\n            {\n                vowelStringCount++;\n            }\n        }\n        result.push_back(vowelStringCount);\n    }\n    return result;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nbool isVowel(char character)\n{\n    return character == 'a' || character == 'e' || character == 'i' || character == 'o' || character == 'u';\n}\n\nvector<int> countVowelStrings(vector<string> &wordList, vector<vector<int>> &queryRanges)\n{\n    vector<int> result;\n    for(auto &query : queryRanges)\n    {\n        int vowelStringCount= 0;\n        for(int index= query[0]; index <= query[1]; index++)\n        {\n            if(isVowel(wordList[index].front()) && isVowel(wordList[index].back()))\n            {\n                vowelStringCount++;\n            }\n        }\n        result.push_back(vowelStringCount);\n    }\n    return result;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint findMinimumCapability(vector<int> &numberList, int requiredCount)\n{\n    int size= numberList.size(), left= 1, right= 1e9;\n    while(left < right)\n    {\n        int mid= left + (right - left) / 2, index= 0, count= 0;\n        for(int j= 0; j < size; ++j)\n        {\n            if(numberList[j] <= mid)\n            {\n                ++count;\n                index= j + 2;\n                while(index + 1 < size && (index == j + 1 || numberList[index] > mid))\n                    ++index;\n            }\n        }\n        if(count < requiredCount)\n            left= mid + 1;\n        else\n            right= mid;\n    }\n    return left;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <vector>\nusing namespace std;\n\nint findMinimumCapability(vector<int> &numberList, int requiredCount)\n{\n    int size= numberList.size(), left= 1, right= 1e9;\n    while(left < right)\n    {\n        int mid= left + (right - left) / 2, index= 0, count= 0;\n        for(int j= 0; j < size; ++j)\n        {\n            if(numberList[j] <= mid)\n            {\n                ++count;\n                index= j + 2;\n                while(index + 1 < size && (index == j + 1 || numberList[index] > mid))\n                    ++index;\n            }\n        }\n        if(count < requiredCount)\n            left= mid + 1;\n        else\n            right= mid;\n    }\n    return left;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minCostToEqualBaskets(vector<int> &basket1, vector<int> &basket2)\n{\n    unordered_map<int, int> differenceCount;\n    for (int index = 0; index < basket1.size(); index++)\n    {\n        differenceCount[basket1[index] - basket2[index]]++;\n    }\n\n    int minimumCost = INT_MAX, currentCost = 0;\n    for (auto it = differenceCount.begin(); it != differenceCount.end(); ++it) // traditional for loop\n    {\n        const auto &entry = *it;\n        if (entry.second == differenceCount[-entry.first])\n        {\n            currentCost = 0;\n            for (int index = 0; index < basket1.size(); index++)\n            {\n                if (basket1[index] - basket2[index] == entry.first)\n                {\n                    currentCost += min(basket1[index], basket2[index]);\n                }\n            }\n            minimumCost = min(minimumCost, currentCost);\n        }\n    }\n\n    return minimumCost == INT_MAX ? -1 : minimumCost / 2;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nint minCostToEqualBaskets(vector<int> &basket1, vector<int> &basket2)\n{\n    unordered_map<int, int> differenceCount;\n    for(int index= 0; index < basket1.size(); index++)\n    {\n        differenceCount[basket1[index] - basket2[index]]++;\n    }\n\n    int minimumCost= INT_MAX, currentCost= 0;\n    for(const auto &entry : differenceCount)\n    {\n        if(entry.second == differenceCount[-entry.first])\n        {\n            currentCost= 0;\n            for(int index= 0; index < basket1.size(); index++)\n            {\n                if(basket1[index] - basket2[index] == entry.first)\n                {\n                    currentCost+= min(basket1[index], basket2[index]);\n                }\n            }\n            minimumCost= min(minimumCost, currentCost);\n        }\n    }\n\n    return minimumCost == INT_MAX ? -1 : minimumCost / 2;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint concatenationValue(vector<int> &numberList)\n{\n    int concatenatedValue= 0;\n    while(!numberList.empty())\n    {\n        int size= numberList.size();\n        if(size == 1)\n        {\n            concatenatedValue+= numberList[0];\n            numberList.pop_back();\n        }\n        else\n        {\n            concatenatedValue+= stoi(to_string(numberList[0]) + to_string(numberList[size - 1]));\n            numberList.erase(numberList.begin());\n            numberList.pop_back();\n        }\n    }\n    return concatenatedValue;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <vector>\n#include <string>\nusing namespace std;\n\nint concatenationValue(vector<int> &numberList)\n{\n    int concatenatedValue= 0;\n    while(!numberList.empty())\n    {\n        int size= numberList.size();\n        if(size == 1)\n        {\n            concatenatedValue+= numberList[0];\n            numberList.pop_back();\n        }\n        else\n        {\n            concatenatedValue+= stoi(to_string(numberList[0]) + to_string(numberList[size - 1]));\n            numberList.erase(numberList.begin());\n            numberList.pop_back();\n        }\n    }\n    return concatenatedValue;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countFairPairs(vector<int> &numbers, int lowerBound, int upperBound)\n{\n    int size= numbers.size();\n    int fairPairCount= 0;\n    for(int indexI= 0; indexI < size; ++indexI)\n    {\n        for(int indexJ= indexI + 1; indexJ < size; ++indexJ)\n        {\n            if((lowerBound <= numbers[indexI] + numbers[indexJ]) && (numbers[indexI] + numbers[indexJ] <= upperBound))\n            {\n                fairPairCount++;\n            }\n        }\n    }\n    return fairPairCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <vector>\nusing namespace std;\n\nint countFairPairs(vector<int> &numbers, int lowerBound, int upperBound)\n{\n    int size= numbers.size();\n    int fairPairCount= 0;\n    for(int indexI= 0; indexI < size; ++indexI)\n    {\n        for(int indexJ= indexI + 1; indexJ < size; ++indexJ)\n        {\n            if((lowerBound <= numbers[indexI] + numbers[indexJ]) && (numbers[indexI] + numbers[indexJ] <= upperBound))\n            {\n                fairPairCount++;\n            }\n        }\n    }\n    return fairPairCount;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\n// Include this for log2 function\n\nusing namespace std;\n\nvector<vector<int>> shortestSubstringQueries(const string &inputString, const vector<vector<int>> &queryPairs)\n{\n    int stringLength = inputString.length();\n    unordered_map<int, int> indexMap;\n\n    for(int currentIndex = 0, currentValue = 0, bitMask = 0; currentIndex < stringLength; currentIndex++)\n    {\n        bitMask |= 1 << (inputString[currentIndex] - '0');\n        currentValue = (currentValue << 1) | (inputString[currentIndex] - '0');\n\n        for(int bitPosition = 0; bitPosition <= 9 && currentIndex + 1 - (1 << bitPosition) >= 0; bitPosition++)\n        {\n            int newValue = currentValue & ((1 << (bitPosition + 1)) - 1);\n            if(indexMap.count(newValue) == 0)\n                indexMap[newValue] = currentIndex + 1 - (1 << bitPosition);\n        }\n    }\n\n    vector<vector<int>> result;\n    for(int i = 0; i < queryPairs.size(); ++i)\n    {\n        const auto &query = queryPairs[i];\n        int targetValue = query[0] ^ query[1];\n        if(indexMap.count(targetValue))\n            result.push_back({indexMap[targetValue], indexMap[targetValue] + static_cast<int>(log2(targetValue))});\n        else\n            result.push_back({-1, -1});\n    }\n\n    return result;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "Here's the modified version of the provided C++ code that uses `using namespace std;`:\n\n```cpp\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <cmath> // Include this for log2 function\n\nusing namespace std;\n\nvector<vector<int>> shortestSubstringQueries(const string &inputString, const vector<vector<int>> &queryPairs)\n{\n    int stringLength = inputString.length();\n    unordered_map<int, int> indexMap;\n\n    for(int currentIndex = 0, currentValue = 0, bitMask = 0; currentIndex < stringLength; currentIndex++)\n    {\n        bitMask |= 1 << (inputString[currentIndex] - '0');\n        currentValue = (currentValue << 1) | (inputString[currentIndex] - '0');\n\n        for(int bitPosition = 0; bitPosition <= 9 && currentIndex + 1 - (1 << bitPosition) >= 0; bitPosition++)\n        {\n            int newValue = currentValue & ((1 << (bitPosition + 1)) - 1);\n            if(indexMap.count(newValue) == 0)\n                indexMap[newValue] = currentIndex + 1 - (1 << bitPosition);\n        }\n    }\n\n    vector<vector<int>> result;\n    for(const auto &query : queryPairs)\n    {\n        int targetValue = query[0] ^ query[1];\n        if(indexMap.count(targetValue))\n            result.push_back({indexMap[targetValue], indexMap[targetValue] + static_cast<int>(log2(targetValue))});\n        else\n            result.push_back({-1, -1});\n    }\n\n    return result;\n}\n```\n\nIn this modified code, all instances of `std::` have been removed and replaced with `using namespace std;`, allowing you to use standard library types and functions without the prefix. Additionally, I included `<cmath>` to ensure that the `log2` function is available."
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMinimumScore(string sourceString, string targetString)\n{\n    int sourceLength= sourceString.size(), targetLength= targetString.size();\n    vector<vector<int>> dynamicProgrammingTable(sourceLength + 1, vector<int>(targetLength + 1, 1e6));\n    dynamicProgrammingTable[0][0]= 0;\n    for(int sourceIndex= 0; sourceIndex < sourceLength; ++sourceIndex)\n        for(int targetIndex= 0; targetIndex < targetLength; ++targetIndex)\n            if(sourceString[sourceIndex] == targetString[targetIndex])\n                dynamicProgrammingTable[sourceIndex + 1][targetIndex + 1]= min(dynamicProgrammingTable[sourceIndex + 1][targetIndex + 1], dynamicProgrammingTable[sourceIndex][targetIndex]);\n            else\n                dynamicProgrammingTable[sourceIndex + 1][targetIndex]= min(dynamicProgrammingTable[sourceIndex + 1][targetIndex], dynamicProgrammingTable[sourceIndex][targetIndex] + 1);\n    int minimumScore= 1e6;\n    for(int sourceIndex= 0; sourceIndex < sourceLength; ++sourceIndex)\n        minimumScore= min(minimumScore, dynamicProgrammingTable[sourceIndex + 1][targetLength]);\n    return minimumScore;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint calculateMinimumScore(string sourceString, string targetString)\n{\n    int sourceLength= sourceString.size(), targetLength= targetString.size();\n    vector<vector<int>> dynamicProgrammingTable(sourceLength + 1, vector<int>(targetLength + 1, 1e6));\n    dynamicProgrammingTable[0][0]= 0;\n    for(int sourceIndex= 0; sourceIndex < sourceLength; ++sourceIndex)\n        for(int targetIndex= 0; targetIndex < targetLength; ++targetIndex)\n            if(sourceString[sourceIndex] == targetString[targetIndex])\n                dynamicProgrammingTable[sourceIndex + 1][targetIndex + 1]= min(dynamicProgrammingTable[sourceIndex + 1][targetIndex + 1], dynamicProgrammingTable[sourceIndex][targetIndex]);\n            else\n                dynamicProgrammingTable[sourceIndex + 1][targetIndex]= min(dynamicProgrammingTable[sourceIndex + 1][targetIndex], dynamicProgrammingTable[sourceIndex][targetIndex] + 1);\n    int minimumScore= 1e6;\n    for(int sourceIndex= 0; sourceIndex < sourceLength; ++sourceIndex)\n        minimumScore= min(minimumScore, dynamicProgrammingTable[sourceIndex + 1][targetLength]);\n    return minimumScore;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateDifferenceMaxMin(int inputNumber)\n{\n    int maxRemapValue = 1, minRemapValue = 9;\n    string numberString = to_string(inputNumber);\n    for (int i = 0; i < numberString.size(); ++i)\n    {\n        char digitChar = numberString[i];\n        int digitValue = digitChar - '0';\n        maxRemapValue = max(maxRemapValue, 9 - digitValue);\n        if (digitValue != 0)\n        {\n            minRemapValue = min(minRemapValue, digitValue);\n        }\n    }\n    int maxCalculatedValue = inputNumber + maxRemapValue * (numberString.length() - count(numberString.begin(), numberString.end(), '9' - maxRemapValue));\n    int minCalculatedValue = inputNumber - minRemapValue * count(numberString.begin(), numberString.end(), minRemapValue + '0');\n    return maxCalculatedValue - minCalculatedValue;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nint calculateDifferenceMaxMin(int inputNumber)\n{\n    int maxRemapValue= 1, minRemapValue= 9;\n    string numberString= to_string(inputNumber);\n    for(char digitChar : numberString)\n    {\n        int digitValue= digitChar - '0';\n        maxRemapValue= max(maxRemapValue, 9 - digitValue);\n        if(digitValue != 0)\n        {\n            minRemapValue= min(minRemapValue, digitValue);\n        }\n    }\n    int maxCalculatedValue= inputNumber + maxRemapValue * (numberString.length() - count(numberString.begin(), numberString.end(), '9' - maxRemapValue));\n    int minCalculatedValue= inputNumber - minRemapValue * count(numberString.begin(), numberString.end(), minRemapValue + '0');\n    return maxCalculatedValue - minCalculatedValue;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minScoreAfterChange(vector<int> &numbers)\n{\n    int size = numbers.size();\n    int firstMin = numbers[0], secondMin = numbers[1], lastMax = numbers[size - 1], secondLastMax = numbers[size - 2];\n\n    for(int index = 1; index < size - 1; index++)\n    {\n        firstMin = min(firstMin, numbers[index]);\n        secondMin = min(secondMin, numbers[index + 1]);\n        lastMax = max(lastMax, numbers[index]);\n        secondLastMax = max(secondLastMax, numbers[index - 1]);\n    }\n\n    int low = min(min(firstMin, lastMax), min(secondMin, secondLastMax));\n    int high = max(max(firstMin, lastMax), max(secondMin, secondLastMax));\n\n    return high - low;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minScoreAfterChange(vector<int> &numbers)\n{\n    int size = numbers.size();\n    int firstMin = numbers[0], secondMin = numbers[1], lastMax = numbers[size - 1], secondLastMax = numbers[size - 2];\n\n    for(int index = 1; index < size - 1; index++)\n    {\n        firstMin = min(firstMin, numbers[index]);\n        secondMin = min(secondMin, numbers[index + 1]);\n        lastMax = max(lastMax, numbers[index]);\n        secondLastMax = max(secondLastMax, numbers[index - 1]);\n    }\n\n    int low = min(min(firstMin, lastMax), min(secondMin, secondLastMax));\n    int high = max(max(firstMin, lastMax), max(secondMin, secondLastMax));\n\n    return high - low;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint findMinNonExpressibleInteger(vector<int> &sortedNumbers)\n{\n    int minimumNonExpressibleInteger = 1;\n    sort(sortedNumbers.begin(), sortedNumbers.end());\n    for (int i = 0; i < sortedNumbers.size(); ++i)\n    {\n        int currentNumber = sortedNumbers[i];\n        if (currentNumber > minimumNonExpressibleInteger)\n            break;\n        minimumNonExpressibleInteger += currentNumber;\n    }\n    return minimumNonExpressibleInteger;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint findMinNonExpressibleInteger(vector<int> &sortedNumbers)\n{\n    int minimumNonExpressibleInteger= 1;\n    sort(sortedNumbers.begin(), sortedNumbers.end());\n    for(int currentNumber : sortedNumbers)\n    {\n        if(currentNumber > minimumNonExpressibleInteger)\n            break;\n        minimumNonExpressibleInteger+= currentNumber;\n    }\n    return minimumNonExpressibleInteger;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> solve(vector<int> &sourceArray, vector<int> &targetArray, vector<vector<int>> &queries)\n{\n    vector<int> result;\n    for (int i = 0; i < queries.size(); ++i)\n    {\n        auto &query = queries[i];\n        if (query[0] == 1)\n        {\n            for (int index = query[1]; index <= query[2]; index++)\n            {\n                sourceArray[index] ^= 1;\n            }\n        }\n        else if (query[0] == 2)\n        {\n            for (int index = 0; index < sourceArray.size(); index++)\n            {\n                targetArray[index] += sourceArray[index] * query[1];\n            }\n        }\n        else if (query[0] == 3)\n        {\n            int totalSum = 0;\n            for (int j = 0; j < targetArray.size(); ++j)\n            {\n                totalSum += targetArray[j];\n            }\n            result.push_back(totalSum);\n        }\n    }\n    return result;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <vector>\nusing namespace std;\n\nvector<int> solve(vector<int> &sourceArray, vector<int> &targetArray, vector<vector<int>> &queries)\n{\n    vector<int> result;\n    for(auto &query : queries)\n    {\n        if(query[0] == 1)\n        {\n            for(int index= query[1]; index <= query[2]; index++)\n            {\n                sourceArray[index]^= 1;\n            }\n        }\n        else if(query[0] == 2)\n        {\n            for(int index= 0; index < sourceArray.size(); index++)\n            {\n                targetArray[index]+= sourceArray[index] * query[1];\n            }\n        }\n        else if(query[0] == 3)\n        {\n            int totalSum= 0;\n            for(auto number : targetArray)\n            {\n                totalSum+= number;\n            }\n            result.push_back(totalSum);\n        }\n    }\n    return result;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> mergeNumbers(vector<vector<int>> &numberList1, vector<vector<int>> &numberList2)\n{\n    map<int, int> mergedMap;\n    vector<vector<int>> mergedResult;\n\n    for (int i = 0; i < numberList1.size(); ++i)\n    {\n        const auto &currentPair = numberList1[i];\n        mergedMap[currentPair[0]] += currentPair[1];\n    }\n\n    for (int i = 0; i < numberList2.size(); ++i)\n    {\n        const auto &currentPair = numberList2[i];\n        mergedMap[currentPair[0]] += currentPair[1];\n    }\n\n    for (const auto &currentPair : mergedMap)\n    {\n        mergedResult.push_back({currentPair.first, currentPair.second});\n    }\n\n    return mergedResult;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <map>\n#include <vector>\nusing namespace std;\n\nvector<vector<int>> mergeNumbers(vector<vector<int>> &numberList1, vector<vector<int>> &numberList2)\n{\n    map<int, int> mergedMap;\n    vector<vector<int>> mergedResult;\n\n    for(const auto &currentPair : numberList1)\n    {\n        mergedMap[currentPair[0]] += currentPair[1];\n    }\n\n    for(const auto &currentPair : numberList2)\n    {\n        mergedMap[currentPair[0]] += currentPair[1];\n    }\n\n    for(const auto &currentPair : mergedMap)\n    {\n        mergedResult.push_back({currentPair.first, currentPair.second});\n    }\n\n    return mergedResult;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint minOperations(int inputNumber)\n{\n    int totalOperations= 0;\n    while(inputNumber)\n    {\n        totalOperations+= inputNumber % 2;\n        inputNumber/= 2;\n    }\n    return totalOperations;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int minOperations(int inputNumber)\n{\n    int totalOperations= 0;\n    while(inputNumber)\n    {\n        totalOperations+= inputNumber % 2;\n        inputNumber/= 2;\n    }\n    return totalOperations;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int modulo = 1e9 + 7;\n\nint countSquareFreeSubsets(vector<int> &inputNumbers)\n{\n    unordered_map<int, int> frequencyCounter;\n    for (int number : inputNumbers)\n    {\n        frequencyCounter[number]++;\n    }\n\n    vector<vector<long long>> dynamicProgramming(61, vector<long long>(1001));\n    dynamicProgramming[0][0] = 1;\n    int currentIndex = 0;\n    for (auto it = frequencyCounter.begin(); it != frequencyCounter.end(); ++it)\n    {\n        const int number = it->first;\n        const int frequency = it->second;\n        currentIndex++;\n        for (int squareCount = 0; squareCount <= 60; squareCount++)\n        {\n            for (int nonSquareCount = 0; nonSquareCount + frequency <= 1000; nonSquareCount++)\n            {\n                dynamicProgramming[currentIndex][nonSquareCount + frequency] += dynamicProgramming[currentIndex - 1][nonSquareCount] * ((1LL << frequency) - 1) % modulo;\n                dynamicProgramming[currentIndex][nonSquareCount + frequency] %= modulo;\n                dynamicProgramming[currentIndex][nonSquareCount] += dynamicProgramming[currentIndex - 1][nonSquareCount];\n                dynamicProgramming[currentIndex][nonSquareCount] %= modulo;\n\n                if ((squareCount / number) % 2 == 1)\n                {\n                    dynamicProgramming[currentIndex][nonSquareCount + frequency] -= dynamicProgramming[currentIndex - 1][nonSquareCount] * ((1LL << (frequency - 1)) - 1) % modulo;\n                    if (dynamicProgramming[currentIndex][nonSquareCount + frequency] < 0)\n                        dynamicProgramming[currentIndex][nonSquareCount + frequency] += modulo;\n                }\n            }\n        }\n    }\n    return dynamicProgramming[currentIndex][0];\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nconst int modulo= 1e9 + 7;\n\nint countSquareFreeSubsets(vector<int> &inputNumbers)\n{\n    unordered_map<int, int> frequencyCounter;\n    for(int number : inputNumbers)\n    {\n        frequencyCounter[number]++;\n    }\n\n    vector<vector<long long>> dynamicProgramming(61, vector<long long>(1001));\n    dynamicProgramming[0][0]= 1;\n    int currentIndex= 0;\n    for(const auto &[number, frequency] : frequencyCounter)\n    {\n        currentIndex++;\n        for(int squareCount= 0; squareCount <= 60; squareCount++)\n        {\n            for(int nonSquareCount= 0; nonSquareCount + frequency <= 1000; nonSquareCount++)\n            {\n                dynamicProgramming[currentIndex][nonSquareCount + frequency]+= dynamicProgramming[currentIndex - 1][nonSquareCount] * ((1LL << frequency) - 1) % modulo;\n                dynamicProgramming[currentIndex][nonSquareCount + frequency]%= modulo;\n                dynamicProgramming[currentIndex][nonSquareCount]+= dynamicProgramming[currentIndex - 1][nonSquareCount];\n                dynamicProgramming[currentIndex][nonSquareCount]%= modulo;\n\n                if((squareCount / number) % 2 == 1)\n                {\n                    dynamicProgramming[currentIndex][nonSquareCount + frequency]-= dynamicProgramming[currentIndex - 1][nonSquareCount] * ((1LL << (frequency - 1)) - 1) % modulo;\n                    if(dynamicProgramming[currentIndex][nonSquareCount + frequency] < 0)\n                        dynamicProgramming[currentIndex][nonSquareCount + frequency]+= modulo;\n                }\n            }\n        }\n    }\n    return dynamicProgramming[currentIndex][0];\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring smallestWordForLCP(vector<vector<int>> &longestCommonPrefix)\n{\n    int matrixSize = longestCommonPrefix.size();\n    string resultWord(matrixSize, 'a');\n    for(int rowIndex = 1; rowIndex < matrixSize; ++rowIndex)\n        for(int colIndex = 1; colIndex < matrixSize; ++colIndex)\n        {\n            if(longestCommonPrefix[rowIndex][colIndex] > min(longestCommonPrefix[rowIndex - 1][colIndex], longestCommonPrefix[rowIndex][colIndex - 1]))\n            {\n                resultWord[rowIndex + longestCommonPrefix[rowIndex][colIndex] - 1] = max(resultWord[rowIndex + longestCommonPrefix[rowIndex][colIndex] - 1], (char)(resultWord[rowIndex - 1] + 1));\n            }\n            else if(longestCommonPrefix[rowIndex][colIndex] < min(longestCommonPrefix[rowIndex - 1][colIndex], longestCommonPrefix[rowIndex][colIndex - 1]))\n            {\n                return \"\";\n            }\n        }\n    return resultWord;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nstring smallestWordForLCP(vector<vector<int>> &longestCommonPrefix)\n{\n    int matrixSize = longestCommonPrefix.size();\n    string resultWord(matrixSize, 'a');\n    for(int rowIndex = 1; rowIndex < matrixSize; ++rowIndex)\n        for(int colIndex = 1; colIndex < matrixSize; ++colIndex)\n        {\n            if(longestCommonPrefix[rowIndex][colIndex] > min(longestCommonPrefix[rowIndex - 1][colIndex], longestCommonPrefix[rowIndex][colIndex - 1]))\n            {\n                resultWord[rowIndex + longestCommonPrefix[rowIndex][colIndex] - 1] = max(resultWord[rowIndex + longestCommonPrefix[rowIndex][colIndex] - 1], (char)(resultWord[rowIndex - 1] + 1));\n            }\n            else if(longestCommonPrefix[rowIndex][colIndex] < min(longestCommonPrefix[rowIndex - 1][colIndex], longestCommonPrefix[rowIndex][colIndex - 1]))\n            {\n                return \"\";\n            }\n        }\n    return resultWord;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> getAnswer(vector<int> &inputNumbers)\n{\n    int size= inputNumbers.size();\n    vector<int> leftSum(size, 0), rightSum(size, 0), result(size, 0);\n\n    for(int index= 1; index < size; index++)\n    {\n        leftSum[index]= leftSum[index - 1] + inputNumbers[index - 1];\n    }\n\n    for(int index= size - 2; index >= 0; index--)\n    {\n        rightSum[index]= rightSum[index + 1] + inputNumbers[index + 1];\n    }\n\n    for(int index= 0; index < size; index++)\n    {\n        result[index]= abs(leftSum[index] - rightSum[index]);\n    }\n\n    return result;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <cstdlib>\n#include <vector>\nusing namespace std;\n\nvector<int> getAnswer(vector<int> &inputNumbers)\n{\n    int size= inputNumbers.size();\n    vector<int> leftSum(size, 0), rightSum(size, 0), result(size, 0);\n\n    for(int index= 1; index < size; index++)\n    {\n        leftSum[index]= leftSum[index - 1] + inputNumbers[index - 1];\n    }\n\n    for(int index= size - 2; index >= 0; index--)\n    {\n        rightSum[index]= rightSum[index + 1] + inputNumbers[index + 1];\n    }\n\n    for(int index= 0; index < size; index++)\n    {\n        result[index]= abs(leftSum[index] - rightSum[index]);\n    }\n\n    return result;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> divisibilityArray(string numberString, int divisor)\n{\n    vector<int> divisibilityResults(numberString.size());\n    int currentValue= 0;\n    for(size_t index= 0; index < numberString.length(); ++index)\n    {\n        currentValue= (currentValue * 10 + (numberString[index] - '0')) % divisor;\n        divisibilityResults[index]= (currentValue == 0) ? 1 : 0;\n    }\n    return divisibilityResults;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nvector<int> divisibilityArray(string numberString, int divisor)\n{\n    vector<int> divisibilityResults(numberString.size());\n    int currentValue= 0;\n    for(size_t index= 0; index < numberString.length(); ++index)\n    {\n        currentValue= (currentValue * 10 + (numberString[index] - '0')) % divisor;\n        divisibilityResults[index]= (currentValue == 0) ? 1 : 0;\n    }\n    return divisibilityResults;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minTime(vector<vector<int>> &grid)\n{\n    int rows= grid.size(), columns= grid[0].size();\n    vector<vector<int>> visited(rows, vector<int>(columns, 1000000));\n\n    const int directionX[]= {-1, 0, 1, 0};\n    const int directionY[]= {0, 1, 0, -1};\n\n    visited[0][0]= 0;\n\n    queue<pair<int, int>> positionQueue;\n    positionQueue.push({0, 0});\n\n    while(!positionQueue.empty())\n    {\n        auto [currentX, currentY]= positionQueue.front();\n        positionQueue.pop();\n\n        for(int i= 0; i < 4; i++)\n        {\n            int nextX= currentX + directionX[i];\n            int nextY= currentY + directionY[i];\n\n            if(nextX >= 0 && nextX < rows && nextY >= 0 && nextY < columns)\n            {\n                int time= max(grid[nextX][nextY], visited[currentX][currentY] + 1);\n                if(visited[nextX][nextY] > time)\n                {\n                    visited[nextX][nextY]= time;\n                    positionQueue.push({nextX, nextY});\n                }\n            }\n        }\n    }\n\n    return visited[rows - 1][columns - 1] == 1000000 ? -1 : visited[rows - 1][columns - 1];\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <queue>\n#include <vector>\nusing namespace std;\n\nint minTime(vector<vector<int>> &grid)\n{\n    int rows= grid.size(), columns= grid[0].size();\n    vector<vector<int>> visited(rows, vector<int>(columns, 1000000));\n\n    const int directionX[]= {-1, 0, 1, 0};\n    const int directionY[]= {0, 1, 0, -1};\n\n    visited[0][0]= 0;\n\n    queue<pair<int, int>> positionQueue;\n    positionQueue.push({0, 0});\n\n    while(!positionQueue.empty())\n    {\n        auto [currentX, currentY]= positionQueue.front();\n        positionQueue.pop();\n\n        for(int i= 0; i < 4; i++)\n        {\n            int nextX= currentX + directionX[i];\n            int nextY= currentY + directionY[i];\n\n            if(nextX >= 0 && nextX < rows && nextY >= 0 && nextY < columns)\n            {\n                int time= max(grid[nextX][nextY], visited[currentX][currentY] + 1);\n                if(visited[nextX][nextY] > time)\n                {\n                    visited[nextX][nextY]= time;\n                    positionQueue.push({nextX, nextY});\n                }\n            }\n        }\n    }\n\n    return visited[rows - 1][columns - 1] == 1000000 ? -1 : visited[rows - 1][columns - 1];\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMinSumOfTwoNumbers(string inputNumber)\n{\n    vector<int> digitCount(10, 0);\n    for (char digit : inputNumber)\n        digitCount[digit - '0']++;\n\n    int firstNumber = 0, secondNumber = 0;\n    for (int i = 1; i <= 9; i += 2)\n    {\n        int count = digitCount[i];\n        while (count--)\n            firstNumber = firstNumber * 10 + i;\n    }\n    for (int i = 0; i <= 9; i += 2)\n    {\n        int count = digitCount[i];\n        while (count--)\n            secondNumber = secondNumber * 10 + i;\n    }\n    return firstNumber + secondNumber;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <string>\n#include <vector>\nusing namespace std;\n\nint calculateMinSumOfTwoNumbers(string inputNumber)\n{\n    vector<int> digitCount(10, 0);\n    for(char digit : inputNumber)\n        digitCount[digit - '0']++;\n\n    int firstNumber= 0, secondNumber= 0;\n    for(int i= 1; i <= 9; i+= 2)\n    {\n        int count= digitCount[i];\n        while(count--)\n            firstNumber= firstNumber * 10 + i;\n    }\n    for(int i= 0; i <= 9; i+= 2)\n    {\n        int count= digitCount[i];\n        while(count--)\n            secondNumber= secondNumber * 10 + i;\n    }\n    return firstNumber + secondNumber;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint calculateColoredCells(int gridSize)\n{\n    return gridSize * gridSize + (gridSize - 1) * (gridSize - 1);\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int calculateColoredCells(int gridSize)\n{\n    return gridSize * gridSize + (gridSize - 1) * (gridSize - 1);\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int modulo = 1e9 + 7;\n\nint totalWaysToSplitRanges(vector<vector<int>> &ranges)\n{\n    sort(ranges.begin(), ranges.end(), [](const vector<int> &firstRange, const vector<int> &secondRange)\n         { return firstRange[1] < secondRange[1]; });\n    int overlappingCount = 0, nonOverlappingCount = 1, previousEnd = -1;\n    for (int i = 0; i < ranges.size(); ++i)\n    {\n        const auto &currentRange = ranges[i];\n        if (currentRange[0] <= previousEnd)\n        {\n            overlappingCount++;\n        }\n        else\n        {\n            nonOverlappingCount++;\n        }\n        previousEnd = max(previousEnd, currentRange[1]);\n    }\n    long result = 1;\n    for (int i = 1; i <= overlappingCount; ++i)\n    {\n        result = (result * 2) % modulo;\n    }\n    return result;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int modulo = 1e9 + 7;\n\nint totalWaysToSplitRanges(vector<vector<int>> &ranges)\n{\n    sort(ranges.begin(), ranges.end(), [](const vector<int> &firstRange, const vector<int> &secondRange)\n         { return firstRange[1] < secondRange[1]; });\n    int overlappingCount = 0, nonOverlappingCount = 1, previousEnd = -1;\n    for (const auto &currentRange : ranges)\n    {\n        if (currentRange[0] <= previousEnd)\n        {\n            overlappingCount++;\n        }\n        else\n        {\n            nonOverlappingCount++;\n        }\n        previousEnd = max(previousEnd, currentRange[1]);\n    }\n    long result = 1;\n    for (int i = 1; i <= overlappingCount; ++i)\n    {\n        result = (result * 2) % modulo;\n    }\n    return result;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint possibleRoots(const vector<vector<int>> &edges, const vector<vector<int>> &guesses, int k)\n{\n    int nodeCount = edges.size() + 1;\n    vector<int> inDegree(nodeCount, 0);\n    unordered_set<int> guessParents;\n\n    for (int i = 0; i < guesses.size(); ++i)\n    {\n        guessParents.insert(guesses[i][0]);\n    }\n\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        inDegree[edges[i][1]]++;\n    }\n\n    int possibleRootsCount = 0;\n    for (int i = 0; i < nodeCount; ++i)\n    {\n        if (inDegree[i] == 0)\n        {\n            if (k == 0 || guessParents.find(i) != guessParents.end())\n            {\n                possibleRootsCount++;\n            }\n        }\n        else if (inDegree[i] == 1 && guesses.size() - k < inDegree[i])\n        {\n            possibleRootsCount++;\n        }\n    }\n    return possibleRootsCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <unordered_set>\n#include <vector>\nusing namespace std;\n\nint possibleRoots(const vector<vector<int>> &edges, const vector<vector<int>> &guesses, int k)\n{\n    int nodeCount = edges.size() + 1;\n    vector<int> inDegree(nodeCount, 0);\n    unordered_set<int> guessParents;\n\n    for(const auto &guess : guesses)\n    {\n        guessParents.insert(guess[0]);\n    }\n\n    for(const auto &edge : edges)\n    {\n        inDegree[edge[1]]++;\n    }\n\n    int possibleRootsCount = 0;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        if(inDegree[i] == 0)\n        {\n            if(k == 0 || guessParents.find(i) != guessParents.end())\n            {\n                possibleRootsCount++;\n            }\n        }\n        else if(inDegree[i] == 1 && guesses.size() - k < inDegree[i])\n        {\n            possibleRootsCount++;\n        }\n    }\n    return possibleRootsCount;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint calculatePillowPosition(int numberOfPillows, int time)\n{\n    time%= (2 * numberOfPillows - 2);\n    if(time <= numberOfPillows - 1)\n        return time + 1;\n    else\n        return 2 * numberOfPillows - time - 1;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int calculatePillowPosition(int numberOfPillows, int time)\n{\n    time%= (2 * numberOfPillows - 2);\n    if(time <= numberOfPillows - 1)\n        return time + 1;\n    else\n        return 2 * numberOfPillows - time - 1;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nint kthLargestLevelSum(TreeNode *rootNode, int k)\n{\n    vector<int> levelSums;\n    queue<TreeNode *> nodeQueue;\n    nodeQueue.push(rootNode);\n\n    while(!nodeQueue.empty())\n    {\n        int levelSum= 0;\n        int levelSize= nodeQueue.size();\n        for(int i= 0; i < levelSize; ++i)\n        {\n            TreeNode *currentNode= nodeQueue.front();\n            nodeQueue.pop();\n            levelSum+= currentNode->value;\n\n            if(currentNode->leftChild)\n                nodeQueue.push(currentNode->leftChild);\n            if(currentNode->rightChild)\n                nodeQueue.push(currentNode->rightChild);\n        }\n\n        levelSums.push_back(levelSum);\n    }\n\n    sort(levelSums.begin(), levelSums.end(), greater<int>());\n    return (k > levelSums.size() ? -1 : levelSums[k - 1]);\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <algorithm>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nint kthLargestLevelSum(TreeNode *rootNode, int k)\n{\n    vector<int> levelSums;\n    queue<TreeNode *> nodeQueue;\n    nodeQueue.push(rootNode);\n\n    while(!nodeQueue.empty())\n    {\n        int levelSum= 0;\n        int levelSize= nodeQueue.size();\n        for(int i= 0; i < levelSize; ++i)\n        {\n            TreeNode *currentNode= nodeQueue.front();\n            nodeQueue.pop();\n            levelSum+= currentNode->value;\n\n            if(currentNode->leftChild)\n                nodeQueue.push(currentNode->leftChild);\n            if(currentNode->rightChild)\n                nodeQueue.push(currentNode->rightChild);\n        }\n\n        levelSums.push_back(levelSum);\n    }\n\n    sort(levelSums.begin(), levelSums.end(), greater<int>());\n    return (k > levelSums.size() ? -1 : levelSums[k - 1]);\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint gcd(int firstNumber, int secondNumber)\n{\n    return secondNumber == 0 ? firstNumber : gcd(secondNumber, firstNumber % secondNumber);\n}\n\nint findValidSplit(const vector<int> &numberList)\n{\n    int length= numberList.size();\n    vector<int> prefixProduct(length);\n    vector<int> suffixProduct(length);\n\n    prefixProduct[0]= numberList[0];\n    suffixProduct[length - 1]= numberList[length - 1];\n\n    for(int index= 1; index < length; ++index)\n        prefixProduct[index]= prefixProduct[index - 1] * numberList[index];\n\n    for(int index= length - 2; index >= 0; --index)\n        suffixProduct[index]= suffixProduct[index + 1] * numberList[index];\n\n    for(int index= 0; index < length - 1; ++index)\n    {\n        if(gcd(prefixProduct[index], suffixProduct[index + 1]) == 1)\n            return index;\n    }\n\n    return -1;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <vector>\nusing namespace std;\n\nint gcd(int firstNumber, int secondNumber)\n{\n    return secondNumber == 0 ? firstNumber : gcd(secondNumber, firstNumber % secondNumber);\n}\n\nint findValidSplit(const vector<int> &numberList)\n{\n    int length= numberList.size();\n    vector<int> prefixProduct(length);\n    vector<int> suffixProduct(length);\n\n    prefixProduct[0]= numberList[0];\n    suffixProduct[length - 1]= numberList[length - 1];\n\n    for(int index= 1; index < length; ++index)\n        prefixProduct[index]= prefixProduct[index - 1] * numberList[index];\n\n    for(int index= length - 2; index >= 0; --index)\n        suffixProduct[index]= suffixProduct[index + 1] * numberList[index];\n\n    for(int index= 0; index < length - 1; ++index)\n    {\n        if(gcd(prefixProduct[index], suffixProduct[index + 1]) == 1)\n            return index;\n    }\n\n    return -1;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int modulo = 1e9 + 7;\n\nint numberOfWays(int target, vector<vector<int>> &itemTypes)\n{\n    vector<int> dynamicProgramming(target + 1, 0);\n    dynamicProgramming[0] = 1;\n    for (int i = 0; i < itemTypes.size(); ++i)\n    {\n        auto &itemType = itemTypes[i];\n        int itemCount = itemType[0], itemMarks = itemType[1];\n        vector<int> tempDynamicProgramming(target + 1, 0);\n        for (int currentScore = 0; currentScore <= target; ++currentScore)\n        {\n            for (int itemUsed = 0; itemUsed <= itemCount && itemUsed * itemMarks + currentScore <= target; ++itemUsed)\n            {\n                tempDynamicProgramming[currentScore + itemUsed * itemMarks] = (tempDynamicProgramming[currentScore + itemUsed * itemMarks] + dynamicProgramming[currentScore]) % modulo;\n            }\n        }\n        dynamicProgramming = tempDynamicProgramming;\n    }\n    return dynamicProgramming[target];\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <vector>\nusing namespace std;\n\nconst int modulo= 1e9 + 7;\n\nint numberOfWays(int target, vector<vector<int>> &itemTypes)\n{\n    vector<int> dynamicProgramming(target + 1, 0);\n    dynamicProgramming[0]= 1;\n    for(auto &itemType : itemTypes)\n    {\n        int itemCount= itemType[0], itemMarks= itemType[1];\n        vector<int> tempDynamicProgramming(target + 1, 0);\n        for(int currentScore= 0; currentScore <= target; ++currentScore)\n        {\n            for(int itemUsed= 0; itemUsed <= itemCount && itemUsed * itemMarks + currentScore <= target; ++itemUsed)\n            {\n                tempDynamicProgramming[currentScore + itemUsed * itemMarks]= (tempDynamicProgramming[currentScore + itemUsed * itemMarks] + dynamicProgramming[currentScore]) % modulo;\n            }\n        }\n        dynamicProgramming= tempDynamicProgramming;\n    }\n    return dynamicProgramming[target];\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isVowel(char character)\n{\n    return character == 'a' || character == 'e' || character == 'i' || character == 'o' || character == 'u';\n}\n\nint countVowelStrings(vector<string> &words, int leftIndex, int rightIndex)\n{\n    int vowelCount= 0;\n    for(int index= leftIndex; index <= rightIndex; index++)\n    {\n        if(isVowel(words[index][0]) && isVowel(words[index][words[index].length() - 1]))\n        {\n            vowelCount++;\n        }\n    }\n    return vowelCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nbool isVowel(char character)\n{\n    return character == 'a' || character == 'e' || character == 'i' || character == 'o' || character == 'u';\n}\n\nint countVowelStrings(vector<string> &words, int leftIndex, int rightIndex)\n{\n    int vowelCount= 0;\n    for(int index= leftIndex; index <= rightIndex; index++)\n    {\n        if(isVowel(words[index][0]) && isVowel(words[index][words[index].length() - 1]))\n        {\n            vowelCount++;\n        }\n    }\n    return vowelCount;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxScore(vector<int> &scores)\n{\n    sort(scores.begin(), scores.end());\n    int count= 0, totalPrefixSum= 0;\n    for(int index= 0; index < scores.size(); ++index)\n    {\n        if(totalPrefixSum + scores[index] > 0)\n        {\n            ++count;\n            totalPrefixSum+= scores[index];\n        }\n    }\n    return count;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint maxScore(vector<int> &scores)\n{\n    sort(scores.begin(), scores.end());\n    int count= 0, totalPrefixSum= 0;\n    for(int index= 0; index < scores.size(); ++index)\n    {\n        if(totalPrefixSum + scores[index] > 0)\n        {\n            ++count;\n            totalPrefixSum+= scores[index];\n        }\n    }\n    return count;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countBeautifulSubarrays(vector<int> &inputNumbers)\n{\n    vector<int> oddCount(20, 0);\n    vector<int> evenCount(20, 0);\n    evenCount[0] = 1;\n\n    for (int i = 0; i < inputNumbers.size(); ++i)\n    {\n        int currentNumber = inputNumbers[i];\n        bool isOdd = __builtin_parity(currentNumber);\n        for (int j = 19; j >= 0; j--)\n        {\n            int bitMask = 1 << j;\n            if (currentNumber & bitMask)\n            {\n                if (isOdd)\n                    swap(oddCount[j], evenCount[j]);\n                oddCount[j]++;\n            }\n            else\n            {\n                if (!isOdd)\n                    swap(oddCount[j], evenCount[j]);\n                evenCount[j]++;\n            }\n            currentNumber -= (currentNumber & bitMask);\n        }\n    }\n\n    long long result = 0;\n    for (int i = 0; i < 20; i++)\n        result += (long long)evenCount[i] * (evenCount[i] - 1) / 2;\n    return result;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <vector>\nusing namespace std;\n\nint countBeautifulSubarrays(vector<int> &inputNumbers)\n{\n    vector<int> oddCount(20, 0);\n    vector<int> evenCount(20, 0);\n    evenCount[0]= 1;\n\n    for(int currentNumber : inputNumbers)\n    {\n        bool isOdd= __builtin_parity(currentNumber);\n        for(int i= 19; i >= 0; i--)\n        {\n            int bitMask= 1 << i;\n            if(currentNumber & bitMask)\n            {\n                if(isOdd)\n                    swap(oddCount[i], evenCount[i]);\n                oddCount[i]++;\n            }\n            else\n            {\n                if(!isOdd)\n                    swap(oddCount[i], evenCount[i]);\n                evenCount[i]++;\n            }\n            currentNumber-= (currentNumber & bitMask);\n        }\n    }\n\n    long long result= 0;\n    for(int i= 0; i < 20; i++)\n        result+= (long long)evenCount[i] * (evenCount[i] - 1) / 2;\n    return result;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minTimeOn(vector<vector<int>> &taskList)\n{\n    vector<vector<int>> timeIntervals;\n    for (int i = 0; i < taskList.size(); ++i)\n    {\n        const auto &task = taskList[i];\n        timeIntervals.push_back({task[1] + 1, task[2]});\n    }\n    sort(timeIntervals.begin(), timeIntervals.end());\n\n    vector<int> dynamicProgramming(2001, 0);\n    for (int i = 0; i < timeIntervals.size(); ++i)\n    {\n        const auto &interval = timeIntervals[i];\n        for (int time = 2000; time >= interval[0]; --time)\n        {\n            dynamicProgramming[time] = max(dynamicProgramming[time], dynamicProgramming[time - interval[1]] + interval[1]);\n        }\n    }\n    return dynamicProgramming.back();\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minTimeOn(vector<vector<int>> &taskList)\n{\n    vector<vector<int>> timeIntervals;\n    for(const auto &task : taskList)\n    {\n        timeIntervals.push_back({task[1] + 1, task[2]});\n    }\n    sort(timeIntervals.begin(), timeIntervals.end());\n\n    vector<int> dynamicProgramming(2001, 0);\n    for(const auto &interval : timeIntervals)\n    {\n        for(int time= 2000; time >= interval[0]; --time)\n        {\n            dynamicProgramming[time]= max(dynamicProgramming[time], dynamicProgramming[time - interval[1]] + interval[1]);\n        }\n    }\n    return dynamicProgramming.back();\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nclass TodoList\n{\n  public:\n    struct Task\n    {\n        int id;\n        string description;\n        int dueDate;\n        vector<string> tags;\n        bool isCompleted;\n\n        Task(int taskId, const string &taskDesc, int taskDueDate, const vector<string> &taskTags)\n            : id(taskId), description(taskDesc), dueDate(taskDueDate), tags(taskTags), isCompleted(false) {}\n    };\n\n    TodoList() : taskId(1) {}\n\n    int addTask(int userId, string taskDescription, int dueDate, vector<string> tags)\n    {\n        tasks[userId].emplace_back(taskId, taskDescription, dueDate, tags);\n        return taskId++;\n    }\n\n    vector<string> getAllTasks(int userId)\n    {\n        vector<string> result;\n        vector<Task> &userTasks = tasks[userId];\n\n        sort(userTasks.begin(), userTasks.end(), [](const Task &a, const Task &b)\n             { return a.dueDate < b.dueDate; });\n\n        for (size_t i = 0; i < userTasks.size(); ++i)\n        {\n            const auto &task = userTasks[i];\n            if (!task.isCompleted)\n            {\n                result.push_back(task.description);\n            }\n        }\n\n        return result;\n    }\n\n    vector<string> getTasksForTag(int userId, string tag)\n    {\n        vector<string> result;\n        vector<Task> &userTasks = tasks[userId];\n\n        sort(userTasks.begin(), userTasks.end(), [](const Task &a, const Task &b)\n             { return a.dueDate < b.dueDate; });\n\n        for (size_t i = 0; i < userTasks.size(); ++i)\n        {\n            const auto &task = userTasks[i];\n            if (!task.isCompleted && find(task.tags.begin(), task.tags.end(), tag) != task.tags.end())\n            {\n                result.push_back(task.description);\n            }\n        }\n\n        return result;\n    }\n\n    void completeTask(int userId, int taskId)\n    {\n        vector<Task> &userTasks = tasks[userId];\n        for (size_t i = 0; i < userTasks.size(); ++i)\n        {\n            auto &task = userTasks[i];\n            if (task.id == taskId)\n            {\n                task.isCompleted = true;\n                break;\n            }\n        }\n    }\n\n  private:\n    int taskId;\n    map<int, vector<Task>> tasks;\n};### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <algorithm>\n#include <map>\n#include <string>\n#include <vector>\nusing namespace std;\n\nclass TodoList\n{\n  public:\n    struct Task\n    {\n        int id;\n        string description;\n        int dueDate;\n        vector<string> tags;\n        bool isCompleted;\n\n        Task(int taskId, const string &taskDesc, int taskDueDate, const vector<string> &taskTags)\n            : id(taskId), description(taskDesc), dueDate(taskDueDate), tags(taskTags), isCompleted(false) {}\n    };\n\n    TodoList() : taskId(1) {}\n\n    int addTask(int userId, string taskDescription, int dueDate, vector<string> tags)\n    {\n        tasks[userId].emplace_back(taskId, taskDescription, dueDate, tags);\n        return taskId++;\n    }\n\n    vector<string> getAllTasks(int userId)\n    {\n        vector<string> result;\n        vector<Task> &userTasks = tasks[userId];\n\n        sort(userTasks.begin(), userTasks.end(), [](const Task &a, const Task &b)\n             { return a.dueDate < b.dueDate; });\n\n        for (const auto &task : userTasks)\n        {\n            if (!task.isCompleted)\n            {\n                result.push_back(task.description);\n            }\n        }\n\n        return result;\n    }\n\n    vector<string> getTasksForTag(int userId, string tag)\n    {\n        vector<string> result;\n        vector<Task> &userTasks = tasks[userId];\n\n        sort(userTasks.begin(), userTasks.end(), [](const Task &a, const Task &b)\n             { return a.dueDate < b.dueDate; });\n\n        for (const auto &task : userTasks)\n        {\n            if (!task.isCompleted && find(task.tags.begin(), task.tags.end(), tag) != task.tags.end())\n            {\n                result.push_back(task.description);\n            }\n        }\n\n        return result;\n    }\n\n    void completeTask(int userId, int taskId)\n    {\n        vector<Task> &userTasks = tasks[userId];\n        for (auto &task : userTasks)\n        {\n            if (task.id == taskId)\n            {\n                task.isCompleted = true;\n                break;\n            }\n        }\n    }\n\n  private:\n    int taskId;\n    map<int, vector<Task>> tasks;\n};\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint maximumChildrenWithEightDollars(int totalMoney, int totalChildren)\n{\n    if(totalMoney < totalChildren * 1 || totalMoney > totalChildren * 8)\n        return -1;\n    int maxEights= (totalMoney - totalChildren) / 7;\n    return maxEights >= totalChildren ? totalChildren : maxEights;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int maximumChildrenWithEightDollars(int totalMoney, int totalChildren)\n{\n    if(totalMoney < totalChildren * 1 || totalMoney > totalChildren * 8)\n        return -1;\n    int maxEights= (totalMoney - totalChildren) / 7;\n    return maxEights >= totalChildren ? totalChildren : maxEights;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMaxGreatness(vector<int> &numberList)\n{\n    sort(numberList.begin(), numberList.end());\n    int totalGreatness= 0;\n    for(int index= 1; index < numberList.size(); ++index)\n    {\n        if(numberList[index - 1] < numberList[index])\n        {\n            swap(numberList[index - 1], numberList[index]);\n            ++totalGreatness;\n        }\n    }\n    return totalGreatness;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint calculateMaxGreatness(vector<int> &numberList)\n{\n    sort(numberList.begin(), numberList.end());\n    int totalGreatness= 0;\n    for(int index= 1; index < numberList.size(); ++index)\n    {\n        if(numberList[index - 1] < numberList[index])\n        {\n            swap(numberList[index - 1], numberList[index]);\n            ++totalGreatness;\n        }\n    }\n    return totalGreatness;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateScore(vector<int> &scoreList)\n{\n    int scoreCount= scoreList.size();\n    vector<int> dp(scoreCount + 2, 0);\n\n    for(int index= 0; index < scoreCount; ++index)\n    {\n        dp[index + 2]= max(dp[index + 1], dp[index] + scoreList[index]);\n    }\n\n    return dp[scoreCount + 1];\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <vector>\nusing namespace std;\n\nint calculateScore(vector<int> &scoreList)\n{\n    int scoreCount= scoreList.size();\n    vector<int> dp(scoreCount + 2, 0);\n\n    for(int index= 0; index < scoreCount; ++index)\n    {\n        dp[index + 2]= max(dp[index + 1], dp[index] + scoreList[index]);\n    }\n\n    return dp[scoreCount + 1];\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minTimeToRepair(vector<int> &repairRanks, int totalCars)\n{\n    sort(repairRanks.begin(), repairRanks.end());\n    int lowerBound = 0, upperBound = 100 * totalCars * totalCars;\n    while (lowerBound < upperBound)\n    {\n        int midPoint = lowerBound + (upperBound - lowerBound) / 2;\n        int totalCarsRepaired = 0;\n        for (int i = 0; i < repairRanks.size(); ++i)\n        {\n            int rank = repairRanks[i];\n            int carsRepaired = min(totalCars, midPoint / (rank * rank));\n            totalCarsRepaired += carsRepaired;\n            if (totalCarsRepaired >= totalCars)\n                break;\n        }\n        if (totalCarsRepaired >= totalCars)\n            upperBound = midPoint;\n        else\n            lowerBound = midPoint + 1;\n    }\n    return lowerBound;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minTimeToRepair(vector<int> &repairRanks, int totalCars)\n{\n    sort(repairRanks.begin(), repairRanks.end());\n    int lowerBound= 0, upperBound= 100 * totalCars * totalCars;\n    while(lowerBound < upperBound)\n    {\n        int midPoint= lowerBound + (upperBound - lowerBound) / 2;\n        int totalCarsRepaired= 0;\n        for(int rank : repairRanks)\n        {\n            int carsRepaired= min(totalCars, midPoint / (rank * rank));\n            totalCarsRepaired+= carsRepaired;\n            if(totalCarsRepaired >= totalCars)\n                break;\n        }\n        if(totalCarsRepaired >= totalCars)\n            upperBound= midPoint;\n        else\n            lowerBound= midPoint + 1;\n    }\n    return lowerBound;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countEvenOddIndices(int inputNumber)\n{\n    vector<int> count(2, 0);\n    int currentIndex= 0;\n    while(inputNumber > 0)\n    {\n        if(inputNumber % 2)\n            count[currentIndex % 2]+= 1;\n        inputNumber/= 2;\n        currentIndex+= 1;\n    }\n    return count;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> countEvenOddIndices(int inputNumber)\n{\n    vector<int> count(2, 0);\n    int currentIndex= 0;\n    while(inputNumber > 0)\n    {\n        if(inputNumber % 2)\n            count[currentIndex % 2]+= 1;\n        inputNumber/= 2;\n        currentIndex+= 1;\n    }\n    return count;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isValidMove(int currentRow, int currentCol, int nextValue, int gridSize)\n{\n    return (currentRow + 1 < gridSize && currentCol + 2 < gridSize && nextValue == gridSize * (currentRow + 1) + (currentCol + 2)) ||\n           (currentRow + 1 < gridSize && currentCol - 2 >= 0 && nextValue == gridSize * (currentRow + 1) + (currentCol - 2)) ||\n           (currentRow + 2 < gridSize && currentCol + 1 < gridSize && nextValue == gridSize * (currentRow + 2) + (currentCol + 1)) ||\n           (currentRow + 2 < gridSize && currentCol - 1 >= 0 && nextValue == gridSize * (currentRow + 2) + (currentCol - 1));\n}\n\nbool validPath(vector<vector<int>> &grid)\n{\n    int gridSize= grid.size();\n    for(int rowIndex= 0; rowIndex < gridSize; rowIndex++)\n    {\n        for(int colIndex= 0; colIndex < gridSize; colIndex++)\n        {\n            int currentValue= grid[rowIndex][colIndex];\n            if(currentValue != gridSize * gridSize - 1 && !isValidMove(rowIndex, colIndex, currentValue + 1, gridSize))\n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <vector>\nusing namespace std;\n\nbool isValidMove(int currentRow, int currentCol, int nextValue, int gridSize)\n{\n    return (currentRow + 1 < gridSize && currentCol + 2 < gridSize && nextValue == gridSize * (currentRow + 1) + (currentCol + 2)) ||\n           (currentRow + 1 < gridSize && currentCol - 2 >= 0 && nextValue == gridSize * (currentRow + 1) + (currentCol - 2)) ||\n           (currentRow + 2 < gridSize && currentCol + 1 < gridSize && nextValue == gridSize * (currentRow + 2) + (currentCol + 1)) ||\n           (currentRow + 2 < gridSize && currentCol - 1 >= 0 && nextValue == gridSize * (currentRow + 2) + (currentCol - 1));\n}\n\nbool validPath(vector<vector<int>> &grid)\n{\n    int gridSize= grid.size();\n    for(int rowIndex= 0; rowIndex < gridSize; rowIndex++)\n    {\n        for(int colIndex= 0; colIndex < gridSize; colIndex++)\n        {\n            int currentValue= grid[rowIndex][colIndex];\n            if(currentValue != gridSize * gridSize - 1 && !isValidMove(rowIndex, colIndex, currentValue + 1, gridSize))\n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countBeautifulSubsets(vector<int> &numberList, int differenceThreshold)\n{\n    sort(numberList.begin(), numberList.end());\n    int totalCount= 0;\n    vector<int> dynamicProgramming(numberList.size(), 1);\n    for(int currentIndex= 0; currentIndex < numberList.size(); currentIndex++)\n    {\n        for(int previousIndex= 0, leftPointer= 0, rightPointer= -1; previousIndex < currentIndex; previousIndex++)\n        {\n            while(leftPointer < previousIndex && numberList[previousIndex] - numberList[leftPointer] >= differenceThreshold)\n                leftPointer++;\n            while(rightPointer + 1 < previousIndex && numberList[rightPointer + 1] - numberList[previousIndex] < differenceThreshold)\n                rightPointer++;\n            if(leftPointer <= rightPointer)\n                dynamicProgramming[previousIndex]-= dynamicProgramming[leftPointer - 1];\n            dynamicProgramming[previousIndex]+= dynamicProgramming[previousIndex - 1] + 1;\n            totalCount+= dynamicProgramming[previousIndex];\n        }\n    }\n    return totalCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint countBeautifulSubsets(vector<int> &numberList, int differenceThreshold)\n{\n    sort(numberList.begin(), numberList.end());\n    int totalCount= 0;\n    vector<int> dynamicProgramming(numberList.size(), 1);\n    for(int currentIndex= 0; currentIndex < numberList.size(); currentIndex++)\n    {\n        for(int previousIndex= 0, leftPointer= 0, rightPointer= -1; previousIndex < currentIndex; previousIndex++)\n        {\n            while(leftPointer < previousIndex && numberList[previousIndex] - numberList[leftPointer] >= differenceThreshold)\n                leftPointer++;\n            while(rightPointer + 1 < previousIndex && numberList[rightPointer + 1] - numberList[previousIndex] < differenceThreshold)\n                rightPointer++;\n            if(leftPointer <= rightPointer)\n                dynamicProgramming[previousIndex]-= dynamicProgramming[leftPointer - 1];\n            dynamicProgramming[previousIndex]+= dynamicProgramming[previousIndex - 1] + 1;\n            totalCount+= dynamicProgramming[previousIndex];\n        }\n    }\n    return totalCount;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMaximumMex(vector<int> &numbers, int incrementValue)\n{\n    unordered_set<int> numberSet(numbers.begin(), numbers.end());\n\n    for(int i= 0; i <= 100000; i++)\n    {\n        if(!numberSet.count(i))\n            numberSet.insert(i + incrementValue);\n    }\n\n    int minimumExcludedValue= 0;\n    while(numberSet.count(minimumExcludedValue))\n        minimumExcludedValue++;\n\n    return minimumExcludedValue;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nint calculateMaximumMex(vector<int> &numbers, int incrementValue)\n{\n    unordered_set<int> numberSet(numbers.begin(), numbers.end());\n\n    for(int i= 0; i <= 100000; i++)\n    {\n        if(!numberSet.count(i))\n            numberSet.insert(i + incrementValue);\n    }\n\n    int minimumExcludedValue= 0;\n    while(numberSet.count(minimumExcludedValue))\n        minimumExcludedValue++;\n\n    return minimumExcludedValue;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &nums)\n{\n    int minimumPrefixSum = 0;\n    int currentPrefixSum = 0;\n    for (int i = 0; i < nums.size(); ++i)\n    {\n        int currentNumber = nums[i];\n        currentPrefixSum += currentNumber;\n        minimumPrefixSum = min(minimumPrefixSum, currentPrefixSum);\n    }\n    return minimumPrefixSum < 0 ? -minimumPrefixSum : 0;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint minOperations(vector<int> &nums)\n{\n    int minimumPrefixSum= 0;\n    int currentPrefixSum= 0;\n    for(int currentNumber : nums)\n    {\n        currentPrefixSum+= currentNumber;\n        minimumPrefixSum= min(minimumPrefixSum, currentPrefixSum);\n    }\n    return minimumPrefixSum < 0 ? -minimumPrefixSum : 0;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint maxSum(int numberOfOnes, int numberOfZeros, int numberOfNegativeOnes, int limit)\n{\n    int maximumSum= 0;\n    for(int i= 0; i <= limit; ++i)\n    {\n        int onesCount= min(i, numberOfOnes);\n        int negativeOnesCount= min(limit - i, numberOfNegativeOnes);\n        maximumSum= max(maximumSum, onesCount - negativeOnesCount);\n    }\n    return maximumSum;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int maxSum(int numberOfOnes, int numberOfZeros, int numberOfNegativeOnes, int limit)\n{\n    int maximumSum= 0;\n    for(int i= 0; i <= limit; ++i)\n    {\n        int onesCount= min(i, numberOfOnes);\n        int negativeOnesCount= min(limit - i, numberOfNegativeOnes);\n        maximumSum= max(maximumSum, onesCount - negativeOnesCount);\n    }\n    return maximumSum;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool strictlyIncreasingArray(vector<int> &numberArray)\n{\n    for(int currentIndex= 0; currentIndex < numberArray.size() - 1; ++currentIndex)\n    {\n        numberArray[currentIndex]-= currentIndex;\n        if(numberArray[currentIndex] >= numberArray[currentIndex + 1])\n        {\n            return false;\n        }\n    }\n    return true;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <vector>\nusing namespace std;\n\nbool strictlyIncreasingArray(vector<int> &numberArray)\n{\n    for(int currentIndex= 0; currentIndex < numberArray.size() - 1; ++currentIndex)\n    {\n        numberArray[currentIndex]-= currentIndex;\n        if(numberArray[currentIndex] >= numberArray[currentIndex + 1])\n        {\n            return false;\n        }\n    }\n    return true;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> minOperations(vector<int> &numbers, vector<int> &queries)\n{\n    vector<int> operationsCount;\n    for (int i = 0; i < queries.size(); ++i)\n    {\n        int query = queries[i];\n        int totalOperations = 0;\n        for (int j = 0; j < numbers.size(); ++j)\n        {\n            int number = numbers[j];\n            totalOperations += abs(number - query);\n        }\n        operationsCount.push_back(totalOperations);\n    }\n    return operationsCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <vector>\nusing namespace std;\n\nvector<int> minOperations(vector<int> &numbers, vector<int> &queries)\n{\n    vector<int> operationsCount;\n    for(int query : queries)\n    {\n        int totalOperations= 0;\n        for(int number : numbers)\n        {\n            totalOperations+= abs(number - query);\n        }\n        operationsCount.push_back(totalOperations);\n    }\n    return operationsCount;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\npair<int, int> depthFirstSearch(const vector<vector<int>> &adjacencyList, const vector<int> &coinValues, int currentNode, int parentNode)\n{\n    int totalCoins = coinValues[currentNode], totalDistance = 0;\n    for (int i = 0; i < adjacencyList[currentNode].size(); ++i)\n    {\n        int neighborNode = adjacencyList[currentNode][i];\n        if (neighborNode != parentNode)\n        {\n            auto result = depthFirstSearch(adjacencyList, coinValues, neighborNode, currentNode);\n            totalCoins += result.first;\n            totalDistance += 2 * result.first + result.second;\n        }\n    }\n    return {totalCoins, totalDistance};\n}\n\nint minEdgesToCollectCoins(const vector<int> &coinValues, const vector<vector<int>> &edges)\n{\n    int numberOfNodes = coinValues.size();\n    vector<vector<int>> adjacencyList(numberOfNodes);\n    for (const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n    return depthFirstSearch(adjacencyList, coinValues, 0, -1).second / 2;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <utility>\n#include <vector>\nusing namespace std;\n\npair<int, int> depthFirstSearch(const vector<vector<int>> &adjacencyList, const vector<int> &coinValues, int currentNode, int parentNode)\n{\n    int totalCoins= coinValues[currentNode], totalDistance= 0;\n    for(int neighborNode : adjacencyList[currentNode])\n    {\n        if(neighborNode != parentNode)\n        {\n            auto result= depthFirstSearch(adjacencyList, coinValues, neighborNode, currentNode);\n            totalCoins+= result.first;\n            totalDistance+= 2 * result.first + result.second;\n        }\n    }\n    return {totalCoins, totalDistance};\n}\n\nint minEdgesToCollectCoins(const vector<int> &coinValues, const vector<vector<int>> &edges)\n{\n    int numberOfNodes= coinValues.size();\n    vector<vector<int>> adjacencyList(numberOfNodes);\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n    return depthFirstSearch(adjacencyList, coinValues, 0, -1).second / 2;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minTimeToEatGrains(vector<int> &hens, vector<int> &grains)\n{\n    sort(hens.begin(), hens.end());\n    sort(grains.begin(), grains.end());\n    int minTime = 0, maxTime = 1e9;\n\n    while (minTime < maxTime)\n    {\n        int midTime = minTime + (maxTime - minTime) / 2;\n        bool canEat = true;\n        int henIndex = 0;\n\n        for (int j = 0; j < grains.size(); ++j)\n        {\n            int grain = grains[j];\n\n            if (henIndex >= hens.size())\n            {\n                canEat = false;\n                break;\n            }\n\n            while (henIndex < hens.size() && hens[henIndex] < grain - midTime)\n            {\n                ++henIndex;\n            }\n\n            if (henIndex >= hens.size() || hens[henIndex] > grain + midTime)\n            {\n                canEat = false;\n                break;\n            }\n\n            ++henIndex;\n        }\n\n        if (canEat)\n        {\n            maxTime = midTime;\n        }\n        else\n        {\n            minTime = midTime + 1;\n        }\n    }\n\n    return minTime;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minTimeToEatGrains(vector<int> &hens, vector<int> &grains)\n{\n    sort(hens.begin(), hens.end());\n    sort(grains.begin(), grains.end());\n    int minTime= 0, maxTime= 1e9;\n\n    while(minTime < maxTime)\n    {\n        int midTime= minTime + (maxTime - minTime) / 2;\n        bool canEat= true;\n        int henIndex= 0;\n\n        for(int grain : grains)\n        {\n            if(henIndex >= hens.size())\n            {\n                canEat= false;\n                break;\n            }\n\n            while(henIndex < hens.size() && hens[henIndex] < grain - midTime)\n            {\n                ++henIndex;\n            }\n\n            if(henIndex >= hens.size() || hens[henIndex] > grain + midTime)\n            {\n                canEat= false;\n                break;\n            }\n\n            ++henIndex;\n        }\n\n        if(canEat)\n        {\n            maxTime= midTime;\n        }\n        else\n        {\n            minTime= midTime + 1;\n        }\n    }\n\n    return minTime;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint findSmallestNumberWithAtLeastOneDigitFromEachArray(vector<int> &firstArray, vector<int> &secondArray)\n{\n    int minFirstArray = *min_element(firstArray.begin(), firstArray.end());\n    int minSecondArray = *min_element(secondArray.begin(), secondArray.end());\n    for (int i = 0; i < firstArray.size(); ++i)\n    {\n        int numberFromFirstArray = firstArray[i];\n        for (int j = 0; j < secondArray.size(); ++j)\n        {\n            int numberFromSecondArray = secondArray[j];\n            if (numberFromFirstArray == numberFromSecondArray)\n            {\n                return numberFromFirstArray;\n            }\n        }\n    }\n    return minFirstArray * 10 + minSecondArray;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint findSmallestNumberWithAtLeastOneDigitFromEachArray(vector<int> &firstArray, vector<int> &secondArray)\n{\n    int minFirstArray= *min_element(firstArray.begin(), firstArray.end());\n    int minSecondArray= *min_element(secondArray.begin(), secondArray.end());\n    for(int numberFromFirstArray : firstArray)\n    {\n        for(int numberFromSecondArray : secondArray)\n        {\n            if(numberFromFirstArray == numberFromSecondArray)\n            {\n                return numberFromFirstArray;\n            }\n        }\n    }\n    return minFirstArray * 10 + minSecondArray;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxValueSubstring(string inputString, string charList, vector<int> values)\n{\n    unordered_map<char, int> charValues;\n\n    for(int index = 0; index < charList.length(); index++)\n    {\n        charValues[charList[index]] = values[index];\n    }\n\n    int maxCost = 0;\n    int currentCost = 0;\n\n    for (int i = 0; i < inputString.length(); ++i)\n    {\n        char currentChar = inputString[i];\n        int charValue = charValues.count(currentChar) ? charValues[currentChar] : static_cast<int>(currentChar - 'a' + 1);\n\n        currentCost = max(0, currentCost + charValue);\n        maxCost = max(maxCost, currentCost);\n    }\n\n    return maxCost;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <string>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxValueSubstring(string inputString, string charList, vector<int> values)\n{\n    unordered_map<char, int> charValues;\n\n    for(int index= 0; index < charList.length(); index++)\n    {\n        charValues[charList[index]]= values[index];\n    }\n\n    int maxCost= 0;\n    int currentCost= 0;\n\n    for(char currentChar : inputString)\n    {\n        int charValue= charValues.count(currentChar) ? charValues[currentChar] : static_cast<int>(currentChar - 'a' + 1);\n\n        currentCost= max(0, currentCost + charValue);\n        maxCost= max(maxCost, currentCost);\n    }\n\n    return maxCost;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &array, int subarraySize)\n{\n    int arraySize= array.size(), minimumCost= INT_MAX;\n    vector<int> prefixSum(arraySize + 1);\n\n    for(int index= 1; index <= arraySize; index++)\n    {\n        prefixSum[index]= prefixSum[index - 1] + array[index - 1];\n    }\n\n    for(int startIndex= 1; startIndex <= arraySize - subarraySize + 1; startIndex++)\n    {\n        int targetValue= (prefixSum[startIndex - 1] + prefixSum[arraySize] - prefixSum[startIndex + subarraySize - 1] + arraySize / subarraySize - 1) / (arraySize / subarraySize);\n        int currentCost= 0;\n        for(int elementIndex= startIndex; elementIndex < startIndex + subarraySize; elementIndex++)\n        {\n            currentCost+= abs(array[elementIndex - 1] - targetValue);\n        }\n        minimumCost= min(minimumCost, currentCost);\n    }\n    return minimumCost;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <vector>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\nint minOperations(vector<int> &array, int subarraySize)\n{\n    int arraySize= array.size(), minimumCost= INT_MAX;\n    vector<int> prefixSum(arraySize + 1);\n\n    for(int index= 1; index <= arraySize; index++)\n    {\n        prefixSum[index]= prefixSum[index - 1] + array[index - 1];\n    }\n\n    for(int startIndex= 1; startIndex <= arraySize - subarraySize + 1; startIndex++)\n    {\n        int targetValue= (prefixSum[startIndex - 1] + prefixSum[arraySize] - prefixSum[startIndex + subarraySize - 1] + arraySize / subarraySize - 1) / (arraySize / subarraySize);\n        int currentCost= 0;\n        for(int elementIndex= startIndex; elementIndex < startIndex + subarraySize; elementIndex++)\n        {\n            currentCost+= abs(array[elementIndex - 1] - targetValue);\n        }\n        minimumCost= min(minimumCost, currentCost);\n    }\n    return minimumCost;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestCycleLength(int nodeCount, vector<vector<int>> &edges)\n{\n    vector<vector<int>> adjacencyList(nodeCount);\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        const vector<int> &edge = edges[i];\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    int minimumCycleLength = nodeCount + 1;\n    for (int startNode = 0; startNode < nodeCount; ++startNode)\n    {\n        vector<int> distance(nodeCount, nodeCount + 1);\n        distance[startNode] = 0;\n        queue<int> nodeQueue;\n        nodeQueue.push(startNode);\n\n        while (!nodeQueue.empty())\n        {\n            int currentNode = nodeQueue.front();\n            nodeQueue.pop();\n            for (int j = 0; j < adjacencyList[currentNode].size(); ++j)\n            {\n                int neighbor = adjacencyList[currentNode][j];\n                if (distance[neighbor] == nodeCount + 1)\n                {\n                    distance[neighbor] = distance[currentNode] + 1;\n                    nodeQueue.push(neighbor);\n                }\n                else if (distance[neighbor] >= distance[currentNode] - 1)\n                {\n                    minimumCycleLength = min(minimumCycleLength, distance[currentNode] + distance[neighbor] + 1);\n                }\n            }\n        }\n    }\n\n    return minimumCycleLength == nodeCount + 1 ? -1 : minimumCycleLength;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestCycleLength(int nodeCount, vector<vector<int>> &edges)\n{\n    vector<vector<int>> adjacencyList(nodeCount);\n    for(const vector<int> &edge : edges)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    int minimumCycleLength= nodeCount + 1;\n    for(int startNode= 0; startNode < nodeCount; ++startNode)\n    {\n        vector<int> distance(nodeCount, nodeCount + 1);\n        distance[startNode]= 0;\n        queue<int> nodeQueue;\n        nodeQueue.push(startNode);\n\n        while(!nodeQueue.empty())\n        {\n            int currentNode= nodeQueue.front();\n            nodeQueue.pop();\n            for(int neighbor : adjacencyList[currentNode])\n            {\n                if(distance[neighbor] == nodeCount + 1)\n                {\n                    distance[neighbor]= distance[currentNode] + 1;\n                    nodeQueue.push(neighbor);\n                }\n                else if(distance[neighbor] >= distance[currentNode] - 1)\n                {\n                    minimumCycleLength= min(minimumCycleLength, distance[currentNode] + distance[neighbor] + 1);\n                }\n            }\n        }\n    }\n\n    return minimumCycleLength == nodeCount + 1 ? -1 : minimumCycleLength;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint longestBalancedSubstring(string binaryString)\n{\n    int maxLength= 0;\n    int zeroCount= 0;\n    int oneCount= 0;\n\n    for(int index= 0; index < binaryString.size(); ++index)\n    {\n        if(binaryString[index] == '0')\n        {\n            zeroCount++;\n        }\n        else\n        {\n            oneCount++;\n        }\n        if(zeroCount == oneCount)\n        {\n            maxLength= max(maxLength, zeroCount * 2);\n        }\n        else if(zeroCount > oneCount)\n        {\n            zeroCount= oneCount= 0;\n        }\n    }\n\n    zeroCount= oneCount= 0;\n    for(int index= binaryString.size() - 1; index >= 0; --index)\n    {\n        if(binaryString[index] == '0')\n        {\n            zeroCount++;\n        }\n        else\n        {\n            oneCount++;\n        }\n        if(zeroCount == oneCount)\n        {\n            maxLength= max(maxLength, zeroCount * 2);\n        }\n        else if(zeroCount < oneCount)\n        {\n            zeroCount= oneCount= 0;\n        }\n    }\n\n    return maxLength;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nint longestBalancedSubstring(string binaryString)\n{\n    int maxLength= 0;\n    int zeroCount= 0;\n    int oneCount= 0;\n\n    for(int index= 0; index < binaryString.size(); ++index)\n    {\n        if(binaryString[index] == '0')\n        {\n            zeroCount++;\n        }\n        else\n        {\n            oneCount++;\n        }\n        if(zeroCount == oneCount)\n        {\n            maxLength= max(maxLength, zeroCount * 2);\n        }\n        else if(zeroCount > oneCount)\n        {\n            zeroCount= oneCount= 0;\n        }\n    }\n\n    zeroCount= oneCount= 0;\n    for(int index= binaryString.size() - 1; index >= 0; --index)\n    {\n        if(binaryString[index] == '0')\n        {\n            zeroCount++;\n        }\n        else\n        {\n            oneCount++;\n        }\n        if(zeroCount == oneCount)\n        {\n            maxLength= max(maxLength, zeroCount * 2);\n        }\n        else if(zeroCount < oneCount)\n        {\n            zeroCount= oneCount= 0;\n        }\n    }\n\n    return maxLength;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> distinctRowsFrom(vector<int> &inputNumbers)\n{\n    vector<unordered_set<int>> uniqueRows;\n\n    for (int i = 0; i < inputNumbers.size(); ++i)\n    {\n        int currentNumber = inputNumbers[i];\n        bool isInserted = false;\n        for (int j = 0; j < uniqueRows.size(); ++j)\n        {\n            auto &row = uniqueRows[j];\n            if (row.find(currentNumber) == row.end())\n            {\n                row.insert(currentNumber);\n                isInserted = true;\n                break;\n            }\n        }\n\n        if (!isInserted)\n            uniqueRows.push_back({currentNumber});\n    }\n\n    vector<vector<int>> result;\n    for (int k = 0; k < uniqueRows.size(); ++k)\n    {\n        auto &row = uniqueRows[k];\n        result.emplace_back(row.begin(), row.end());\n    }\n\n    return result;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <unordered_set>\n#include <vector>\nusing namespace std;\n\nvector<vector<int>> distinctRowsFrom(vector<int> &inputNumbers)\n{\n    vector<unordered_set<int>> uniqueRows;\n\n    for(int currentNumber : inputNumbers)\n    {\n        bool isInserted = false;\n        for(auto &row : uniqueRows)\n        {\n            if(row.find(currentNumber) == row.end())\n            {\n                row.insert(currentNumber);\n                isInserted = true;\n                break;\n            }\n        }\n\n        if(!isInserted)\n            uniqueRows.push_back({currentNumber});\n    }\n\n    vector<vector<int>> result;\n    for(auto &row : uniqueRows)\n    {\n        result.emplace_back(row.begin(), row.end());\n    }\n\n    return result;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxPoints(const vector<int> &firstMouseRewards, const vector<int> &secondMouseRewards, int k)\n{\n    vector<pair<int, int>> rewardGap(firstMouseRewards.size());\n    for(size_t index= 0; index < firstMouseRewards.size(); ++index)\n    {\n        rewardGap[index]= {secondMouseRewards[index] - firstMouseRewards[index], index};\n    }\n    sort(rewardGap.rbegin(), rewardGap.rend());\n    int totalFirstMousePoints= 0;\n    int totalSecondMousePoints= 0;\n    for(int i= 0; i < k; ++i)\n    {\n        totalFirstMousePoints+= firstMouseRewards[rewardGap[i].second];\n    }\n    for(int i= k; i < firstMouseRewards.size(); ++i)\n    {\n        totalSecondMousePoints+= secondMouseRewards[rewardGap[i].second];\n    }\n    return totalFirstMousePoints + totalSecondMousePoints;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxPoints(const vector<int> &firstMouseRewards, const vector<int> &secondMouseRewards, int k)\n{\n    vector<pair<int, int>> rewardGap(firstMouseRewards.size());\n    for(size_t index= 0; index < firstMouseRewards.size(); ++index)\n    {\n        rewardGap[index]= {secondMouseRewards[index] - firstMouseRewards[index], index};\n    }\n    sort(rewardGap.rbegin(), rewardGap.rend());\n    int totalFirstMousePoints= 0;\n    int totalSecondMousePoints= 0;\n    for(int i= 0; i < k; ++i)\n    {\n        totalFirstMousePoints+= firstMouseRewards[rewardGap[i].second];\n    }\n    for(int i= k; i < firstMouseRewards.size(); ++i)\n    {\n        totalSecondMousePoints+= secondMouseRewards[rewardGap[i].second];\n    }\n    return totalFirstMousePoints + totalSecondMousePoints;\n}\n```"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> reachPosition(int totalPositions, int targetPosition, vector<int> &bannedPositions, int stepSize)\n{\n    set<int> bannedSet(bannedPositions.begin(), bannedPositions.end());\n    vector<int> result(totalPositions, 0);\n\n    for(int currentPosition= 0; currentPosition < totalPositions; ++currentPosition)\n    {\n        if(bannedSet.find(currentPosition) != bannedSet.end() || currentPosition == targetPosition)\n        {\n            result[currentPosition]= -1;\n            continue;\n        }\n\n        int stepsRequired= 0;\n        int distance= abs(targetPosition - currentPosition) / stepSize;\n        if((abs(targetPosition - currentPosition) % stepSize == 0) && ((distance & 1) == (((totalPositions - 1) & 1) ^ (stepSize & 1))))\n        {\n            stepsRequired= distance;\n        }\n        else\n        {\n            stepsRequired= -1;\n        }\n\n        result[currentPosition]= stepsRequired;\n    }\n\n    result[targetPosition]= 0;\n    return result;\n}### Code Examples in Target Style ###\n## Code Example 1\n```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxNumberOfCopies(string sourceString, string targetString)\n{\n    vector<int> sourceCounts(26, 0);\n    vector<int> targetCounts(26, 0);\n\n    for(char character : sourceString)\n        sourceCounts[character - 'a']++;\n\n    for(char character : targetString)\n        targetCounts[character - 'a']++;\n\n    int maxCopies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies = min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n```\n## Code Example 2\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &beanCounts)\n{\n    unordered_map<int, int> beanFrequency;\n    for(int bean : beanCounts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= beanCounts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n```\n## Code Example 3\n```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int numSlots)\n{\n    vector<int> slot(numSlots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= numSlots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n## Code Example 4\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minSteps(string sourceString, string targetString)\n{\n    unordered_map<char, int> characterCount;\n    for(char currentCharacter : sourceString)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : targetString)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travelTimes, int totalTrips)\n{\n    sort(travelTimes.begin(), travelTimes.end());\n\n    int lowerBound = 0, upperBound = travelTimes.back() * totalTrips;\n    while(lowerBound < upperBound)\n    {\n        int midTime = lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips = 0;\n        for(int travelTime : travelTimes)\n        {\n            completedTrips += midTime / travelTime;\n        }\n        if(completedTrips < totalTrips)\n        {\n            lowerBound = midTime + 1;\n        }\n        else\n        {\n            upperBound = midTime;\n        }\n    }\n\n    return lowerBound;\n}\n```\n## Code Example 6\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring repeatLimitedString(string inputString, int repeatLimit)\n{\n    string outputString= \"\";\n    sort(inputString.begin(), inputString.end(), greater<char>());\n\n    for(char currentChar : inputString)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeatLimit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n```\n## Code Example 7\n```cpp\n#include <vector>\nusing namespace std;\n\nint countPairs(vector<int> &numberList, int divisor)\n{\n    vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : numberList)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n```\n## Code Example 8\n#include <vector>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &taxBrackets, int totalIncome)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(vector<int> &taxBracket : taxBrackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (min(upperLimit, totalIncome) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(totalIncome <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> nodeMap;\n    for(const auto &description : descriptions)\n    {\n        nodeMap[description[0]] = new TreeNode(description[0]);\n        nodeMap[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            nodeMap[description[0]]->leftChild = nodeMap[description[1]];\n        else\n            nodeMap[description[0]]->rightChild = nodeMap[description[1]];\n    }\n\n    return nodeMap[descriptions.front()[0]];\n}\n```\n## Code Example 10\n```cpp\n#include <string>\nusing namespace std;\n\nint getMaxOccurrences(const string &inputText, const string &pattern)\n{\n    int occurrenceCount[2] = {0, 0};\n    for(char currentChar : inputText)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1] += occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0] += 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n```\n## Code Example 11\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int totalSum = 0, halfSum = 0, operationCount = 0;\n    for(int number : numbers)\n        totalSum += number;\n    for(int number : numbers)\n    {\n        halfSum += number;\n        operationCount++;\n        if(halfSum >= (totalSum + 1) / 2)\n            break;\n    }\n    return operationCount;\n}\n```\n## Code Example 12\n```cpp\n#include <string>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &inputString)\n{\n    int starCount = 0;\n    int pipeCount = 0;\n\n    for(char character : inputString)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n```\n## Code Example 13\n#include <string>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int keyValue, int distance)\n{\n    vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= max(0, currentIndex - distance); startIndex <= min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == keyValue)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n```\n## Code Example 15\n#include <climits>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(int numNodes, vector<vector<int>> &edges, int source1, int source2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacencyList(numNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(numNodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source1ToAllDistances= dijkstra(source1);\n    vector<int> source2ToAllDistances= dijkstra(source2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <vector>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<int> &nodeXorValues, vector<vector<int>> &adjacencyList)\n{\n    int currentXorValue= nodeXorValues[currentNode];\n    for(int childNode : adjacencyList[currentNode])\n    {\n        if(childNode != parentNode)\n        {\n            currentXorValue^= depthFirstSearch(childNode, currentNode, nodeXorValues, adjacencyList);\n        }\n    }\n    return currentXorValue;\n}\n\nint minimumScore(vector<int> &nodeValues, vector<vector<int>> &edgeList)\n{\n    int nodeCount= nodeValues.size();\n    vector<vector<int>> adjacencyList(nodeCount);\n\n    for(vector<int> &edge : edgeList)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> nodeXorValues(nodeCount);\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i]= depthFirstSearch(i, -1, nodeValues, adjacencyList);\n    }\n\n    int minimumDifference= INT_MAX;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        for(int j= i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1= nodeXorValues[i];\n            int xorValue2= nodeXorValues[j] ^ nodeValues[i];\n            int xorValue3= nodeValues[i] ^ nodeValues[j];\n            int maxXorValue= max({xorValue1, xorValue2, xorValue3});\n            int minXorValue= min({xorValue1, xorValue2, xorValue3});\n            minimumDifference= min(minimumDifference, maxXorValue - minXorValue);\n        }\n    }\n\n    return minimumDifference;\n}\n## Code Example 17\n```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string evenDigits= \"\";\n    string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    sort(evenDigits.rbegin(), evenDigits.rend());\n    sort(oddDigits.rbegin(), oddDigits.rend());\n\n    string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int inputNumber)\n{\n    string numberString= to_string(inputNumber);\n    return stoi(largestSwap(numberString));\n}\n```\n## Code Example 18\n```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxBeauty(vector<int> &flowerCounts, int availableNewFlowers, int beautyTarget, int fullBeauty, int partialBeauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flowerCounts)\n        totalBeauty+= (flowerCount >= beautyTarget) ? fullBeauty : partialBeauty * flowerCount;\n\n    sort(flowerCounts.begin(), flowerCounts.end());\n\n    for(int i= 0; i < flowerCounts.size() && availableNewFlowers > 0; ++i)\n    {\n        int flowersNeeded= beautyTarget - flowerCounts[i];\n        if(flowersNeeded <= availableNewFlowers)\n        {\n            totalBeauty+= fullBeauty - partialBeauty * flowerCounts[i];\n            flowerCounts[i]= beautyTarget;\n            availableNewFlowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n```\n## Code Example 19\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &busTimes, vector<int> &passengerTimes, int busCapacity)\n{\n    sort(busTimes.begin(), busTimes.end());\n    sort(passengerTimes.begin(), passengerTimes.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : busTimes)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passengerTimes.size() && passengerTimes[lastPassengerIndex] <= busTime && count < busCapacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? busTimes[0] - 1 : passengerTimes[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <vector>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &numberList)\n{\n    vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : numberList)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int currentNumber : numbers)\n    {\n        int sumOfDigits= 0;\n        for(int tempNumber= currentNumber; tempNumber; tempNumber/= 10)\n        {\n            sumOfDigits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sumOfDigits];\n        if(previousMax)\n        {\n            result= max(result, currentNumber + previousMax);\n        }\n        digitSumToMax[sumOfDigits]= max(currentNumber, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "```cpp\n#include <set>\n#include <vector>\nusing namespace std;\n\nvector<int> reachPosition(int totalPositions, int targetPosition, vector<int> &bannedPositions, int stepSize)\n{\n    set<int> bannedSet(bannedPositions.begin(), bannedPositions.end());\n    vector<int> result(totalPositions, 0);\n\n    for(int currentPosition= 0; currentPosition < totalPositions; ++currentPosition)\n    {\n        if(bannedSet.find(currentPosition) != bannedSet.end() || currentPosition == targetPosition)\n        {\n            result[currentPosition]= -1;\n            continue;\n        }\n\n        int stepsRequired= 0;\n        int distance= abs(targetPosition - currentPosition) / stepSize;\n        if((abs(targetPosition - currentPosition) % stepSize == 0) && ((distance & 1) == (((totalPositions - 1) & 1) ^ (stepSize & 1))))\n        {\n            stepsRequired= distance;\n        }\n        else\n        {\n            stepsRequired= -1;\n        }\n\n        result[currentPosition]= stepsRequired;\n    }\n\n    result[targetPosition]= 0;\n    return result;\n}\n```"
  }
]