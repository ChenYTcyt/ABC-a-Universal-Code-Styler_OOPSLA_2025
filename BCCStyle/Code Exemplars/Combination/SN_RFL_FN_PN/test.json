[
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring findOddWord(vector<string> &wordList)\n{\n    auto calculateDifferenceArray = [](const string &currentWord)\n    {\n        vector<int> differenceArray;\n        for(size_t index = 1; index < currentWord.size(); index++)\n        {\n            differenceArray.push_back(currentWord[index] - currentWord[index - 1]);\n        }\n        return differenceArray;\n    };\n\n    vector<vector<int>> differenceArrays;\n    for (int i = 0; i < wordList.size(); ++i)\n    {\n        const auto &currentWord = wordList[i];\n        differenceArrays.push_back(calculateDifferenceArray(currentWord));\n    }\n\n    int oddArrayIndex = -1;\n    for (int index = 1; index < differenceArrays.size(); index++)\n    {\n        int matchCount = 0;\n        for (int j = 0; j < differenceArrays[index].size(); j++)\n        {\n            if (differenceArrays[0][j] == differenceArrays[index][j])\n            {\n                matchCount++;\n            }\n        }\n\n        if (matchCount == 0)\n        {\n            oddArrayIndex = index;\n            break;\n        }\n    }\n\n    return wordList[oddArrayIndex];\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nstd::string FindOddWord(std::vector<std::string> &word_list)\n{\n    auto CalculateDifferenceArray= [](const std::string &current_word)\n    {\n        std::vector<int> differenceArray;\n        for(size_t index= 1; index < current_word.size(); index++)\n        {\n            differenceArray.push_back(current_word[index] - current_word[index - 1]);\n        }\n        return differenceArray;\n    };\n\n    std::vector<std::vector<int>> differenceArrays;\n    for(const auto &currentWord : word_list)\n    {\n        differenceArrays.push_back(CalculateDifferenceArray(currentWord));\n    }\n\n    int oddArrayIndex= -1;\n    for(int index= 1; index < differenceArrays.size(); index++)\n    {\n        int matchCount= 0;\n        for(int j= 0; j < differenceArrays[index].size(); j++)\n        {\n            if(differenceArrays[0][j] == differenceArrays[index][j])\n            {\n                matchCount++;\n            }\n        }\n\n        if(matchCount == 0)\n        {\n            oddArrayIndex= index;\n            break;\n        }\n    }\n\n    return word_list[oddArrayIndex];\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countDifferences(const string &sourceWord, const string &targetWord)\n{\n    int differenceCount = 0;\n    for(int index = 0; index < sourceWord.size(); ++index)\n    {\n        if(sourceWord[index] != targetWord[index])\n        {\n            ++differenceCount;\n        }\n    }\n    return differenceCount;\n}\n\nvector<string> findMatchingWords(const vector<string> &queryWords, const vector<string> &dictionaryWords)\n{\n    vector<string> matchedWords;\n    for (int i = 0; i < queryWords.size(); ++i)\n    {\n        const string &query = queryWords[i];\n        for (int j = 0; j < dictionaryWords.size(); ++j)\n        {\n            const string &dictionaryWord = dictionaryWords[j];\n            if (countDifferences(query, dictionaryWord) <= 2)\n            {\n                matchedWords.push_back(query);\n                break;\n            }\n        }\n    }\n    return matchedWords;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint CountDifferences(const std::string &source_word, const std::string &target_word)\n{\n    int differenceCount= 0;\n    for(int index= 0; index < source_word.size(); ++index)\n    {\n        if(source_word[index] != target_word[index])\n        {\n            ++differenceCount;\n        }\n    }\n    return differenceCount;\n}\n\nstd::vector<std::string> FindMatchingWords(const std::vector<std::string> &query_words, const std::vector<std::string> &dictionary_words)\n{\n    std::vector<std::string> matchedWords;\n    for(const std::string &query : query_words)\n    {\n        for(const std::string &dictionaryWord : dictionary_words)\n        {\n            if(CountDifferences(query, dictionaryWord) <= 2)\n            {\n                matchedWords.push_back(query);\n                break;\n            }\n        }\n    }\n    return matchedWords;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint findMinSeededValue(vector<int> &numbers, int space)\n{\n    unordered_map<int, int> remainderCount;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int number = numbers[i];\n        remainderCount[number % space]++;\n    }\n    return max_element(remainderCount.begin(), remainderCount.end(), [](const auto &a, const auto &b)\n                       { return a.second < b.second || (a.second == b.second && a.first > b.first); })\n        ->first;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint FindMinSeededValue(std::vector<int> &numbers, int space)\n{\n    std::unordered_map<int, int> remainderCount;\n    for(int number : numbers)\n    {\n        remainderCount[number % space]++;\n    }\n    return std::max_element(remainderCount.begin(), remainderCount.end(), [](const auto &a, const auto &b)\n                       { return a.second < b.second || (a.second == b.second && a.first > b.first); })\n        ->first;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findSecondGreater(const vector<int> &inputNumbers)\n{\n    int totalNumbers= inputNumbers.size();\n    vector<int> result(totalNumbers, -1);\n    for(int currentIndex= 0; currentIndex < totalNumbers; currentIndex++)\n    {\n        for(int nextIndex= currentIndex + 1, secondGreaterIndex= -1; nextIndex < totalNumbers; nextIndex++)\n        {\n            if(inputNumbers[nextIndex] > inputNumbers[currentIndex])\n            {\n                if(secondGreaterIndex == -1)\n                {\n                    secondGreaterIndex= nextIndex;\n                }\n                else\n                {\n                    result[currentIndex]= inputNumbers[nextIndex];\n                    break;\n                }\n            }\n        }\n    }\n    return result;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> FindSecondGreater(const std::vector<int> &input_numbers)\n{\n    int totalNumbers= input_numbers.size();\n    std::vector<int> result(totalNumbers, -1);\n    for(int currentIndex= 0; currentIndex < totalNumbers; currentIndex++)\n    {\n        for(int nextIndex= currentIndex + 1, secondGreaterIndex= -1; nextIndex < totalNumbers; nextIndex++)\n        {\n            if(input_numbers[nextIndex] > input_numbers[currentIndex])\n            {\n                if(secondGreaterIndex == -1)\n                {\n                    secondGreaterIndex= nextIndex;\n                }\n                else\n                {\n                    result[currentIndex]= input_numbers[nextIndex];\n                    break;\n                }\n            }\n        }\n    }\n    return result;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint averageEvenDivisibleByThree(const vector<int> &numbers)\n{\n    int totalSum = 0;\n    int count = 0;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int number = numbers[i];\n        if (number % 2 == 0 && number % 3 == 0)\n        {\n            totalSum += number;\n            count++;\n        }\n    }\n    return count == 0 ? 0 : totalSum / count;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int AverageEvenDivisibleByThree(const std::vector<int> &numbers)\n{\n    int totalSum= 0;\n    int count= 0;\n    for(int number : numbers)\n    {\n        if(number % 2 == 0 && number % 3 == 0)\n        {\n            totalSum+= number;\n            count++;\n        }\n    }\n    return count == 0 ? 0 : totalSum / count;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<string>> getHighestPopularity(vector<string> &creatorNames, vector<string> &videoIds, vector<int> &viewCounts)\n{\n    unordered_map<string, int> creatorPopularity;\n    unordered_map<string, pair<string, int>> mostViewedVideos;\n    for(int index = 0; index < creatorNames.size(); index++)\n    {\n        creatorPopularity[creatorNames[index]] += viewCounts[index];\n        if(!mostViewedVideos.count(creatorNames[index]) || viewCounts[index] > mostViewedVideos[creatorNames[index]].second || (viewCounts[index] == mostViewedVideos[creatorNames[index]].second && videoIds[index] < mostViewedVideos[creatorNames[index]].first))\n        {\n            mostViewedVideos[creatorNames[index]] = {videoIds[index], viewCounts[index]};\n        }\n    }\n\n    int maxPopularity = 0;\n    for(auto it = creatorPopularity.begin(); it != creatorPopularity.end(); ++it)\n    {\n        maxPopularity = max(maxPopularity, it->second);\n    }\n\n    vector<vector<string>> result;\n    for(auto it = creatorPopularity.begin(); it != creatorPopularity.end(); ++it)\n    {\n        if(it->second == maxPopularity)\n        {\n            result.push_back({it->first, mostViewedVideos[it->first].first});\n        }\n    }\n    return result;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<std::string>> GetHighestPopularity(std::vector<std::string> &creator_names, std::vector<std::string> &video_ids, std::vector<int> &view_counts)\n{\n    std::unordered_map<std::string, int> creatorPopularity;\n    std::unordered_map<std::string, std::pair<std::string, int>> mostViewedVideos;\n    for(int index= 0; index < creator_names.size(); index++)\n    {\n        creatorPopularity[creator_names[index]]+= view_counts[index];\n        if(!mostViewedVideos.count(creator_names[index]) || view_counts[index] > mostViewedVideos[creator_names[index]].second || (view_counts[index] == mostViewedVideos[creator_names[index]].second && video_ids[index] < mostViewedVideos[creator_names[index]].first))\n        {\n            mostViewedVideos[creator_names[index]]= {video_ids[index], view_counts[index]};\n        }\n    }\n\n    int maxPopularity= 0;\n    for(auto &[creator, popularity] : creatorPopularity)\n    {\n        maxPopularity= std::max(maxPopularity, popularity);\n    }\n\n    std::vector<std::vector<std::string>> result;\n    for(auto &[creator, popularity] : creatorPopularity)\n    {\n        if(popularity == maxPopularity)\n        {\n            result.push_back({creator, mostViewedVideos[creator].first});\n        }\n    }\n    return result;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint digitSum(int number)\n{\n    int totalSum= 0;\n    while(number)\n    {\n        totalSum+= number % 10;\n        number/= 10;\n    }\n    return totalSum;\n}\n\nint minimumBeautiful(int baseNumber, int targetSum)\n{\n    int increment= 0;\n    while(digitSum(baseNumber + increment) > targetSum)\n    {\n        ++increment;\n    }\n    return increment;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int DigitSum(int number)\n{\n    int totalSum= 0;\n    while(number)\n    {\n        totalSum+= number % 10;\n        number/= 10;\n    }\n    return totalSum;\n}\n\nint MinimumBeautiful(int base_number, int target_sum)\n{\n    int increment= 0;\n    while(DigitSum(base_number + increment) > target_sum)\n    {\n        ++increment;\n    }\n    return increment;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nclass Solution\n{\n  public:\n    vector<int> removeSubtrees(TreeNode *rootNode, vector<int> &queries)\n    {\n        vector<int> answer(queries.size());\n\n        for(int i= 0; i < queries.size(); ++i)\n        {\n            removeSubtree(rootNode, queries[i]);\n            answer[i]= findHeight(rootNode);\n        }\n\n        return answer;\n    }\n\n    void removeSubtree(TreeNode *currentNode, int value)\n    {\n        if(currentNode == NULL)\n            return;\n\n        if(currentNode->leftChild && currentNode->leftChild->value == value)\n            currentNode->leftChild= NULL;\n        else\n            removeSubtree(currentNode->leftChild, value);\n\n        if(currentNode->rightChild && currentNode->rightChild->value == value)\n            currentNode->rightChild= NULL;\n        else\n            removeSubtree(currentNode->rightChild, value);\n    }\n\n    int findHeight(TreeNode *currentNode)\n    {\n        if(currentNode == NULL)\n            return -1;\n\n        return 1 + max(findHeight(currentNode->leftChild), findHeight(currentNode->rightChild));\n    }\n};### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\n// Definition for a binary tree node.\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nclass Solution\n{\n  public:\n    std::vector<int> RemoveSubtrees(TreeNode *root_node, std::vector<int> &queries)\n    {\n        std::vector<int> answer(queries.size());\n\n        for(int i= 0; i < queries.size(); ++i)\n        {\n            RemoveSubtree(root_node, queries[i]);\n            answer[i]= FindHeight(root_node);\n        }\n\n        return answer;\n    }\n\n    void RemoveSubtree(TreeNode *current_node, int value)\n    {\n        if(current_node == NULL)\n            return;\n\n        if(current_node->leftChild && current_node->leftChild->value == value)\n            current_node->leftChild= NULL;\n        else\n            RemoveSubtree(current_node->leftChild, value);\n\n        if(current_node->rightChild && current_node->rightChild->value == value)\n            current_node->rightChild= NULL;\n        else\n            RemoveSubtree(current_node->rightChild, value);\n    }\n\n    int FindHeight(TreeNode *current_node)\n    {\n        if(current_node == NULL)\n            return -1;\n\n        return 1 + std::max(FindHeight(current_node->leftChild), FindHeight(current_node->rightChild));\n    }\n};"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numberList)\n{\n    int size= numberList.size();\n    int indexOfZero= -1;\n\n    for(int index= 0; index < size; index++)\n    {\n        if(numberList[index] == 0)\n        {\n            indexOfZero= index;\n            break;\n        }\n    }\n\n    int countIncrements= 0, countDecrements= 0;\n\n    for(int index= 1; index < size; index++)\n    {\n        if(abs(numberList[index] - numberList[index - 1]) != 1)\n        {\n            countIncrements+= abs(numberList[index] - numberList[index - 1]) - 1;\n        }\n    }\n\n    for(int index= indexOfZero + 1; index < size; index++)\n    {\n        if(numberList[index] < numberList[index - 1])\n        {\n            countDecrements++;\n        }\n    }\n\n    return min(countIncrements, countDecrements);\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &number_list)\n{\n    int size= number_list.size();\n    int indexOfZero= -1;\n\n    for(int index= 0; index < size; index++)\n    {\n        if(number_list[index] == 0)\n        {\n            indexOfZero= index;\n            break;\n        }\n    }\n\n    int countIncrements= 0, countDecrements= 0;\n\n    for(int index= 1; index < size; index++)\n    {\n        if(std::abs(number_list[index] - number_list[index - 1]) != 1)\n        {\n            countIncrements+= std::abs(number_list[index] - number_list[index - 1]) - 1;\n        }\n    }\n\n    for(int index= indexOfZero + 1; index < size; index++)\n    {\n        if(number_list[index] < number_list[index - 1])\n        {\n            countDecrements++;\n        }\n    }\n\n    return std::min(countIncrements, countDecrements);\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> performOps(vector<int> &numberList)\n{\n    int listSize= numberList.size();\n    for(int currentIndex= 0; currentIndex < listSize - 1; ++currentIndex)\n    {\n        if(numberList[currentIndex] == numberList[currentIndex + 1])\n        {\n            numberList[currentIndex]*= 2;\n            numberList[currentIndex + 1]= 0;\n        }\n    }\n    int nonZeroCount= 0;\n    for(int currentIndex= 0; currentIndex < listSize; ++currentIndex)\n    {\n        if(numberList[currentIndex] != 0)\n        {\n            numberList[nonZeroCount++]= numberList[currentIndex];\n        }\n    }\n    while(nonZeroCount < listSize)\n    {\n        numberList[nonZeroCount++]= 0;\n    }\n    return numberList;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> PerformOps(std::vector<int> &number_list)\n{\n    int listSize = number_list.size();\n    for(int currentIndex = 0; currentIndex < listSize - 1; ++currentIndex)\n    {\n        if(number_list[currentIndex] == number_list[currentIndex + 1])\n        {\n            number_list[currentIndex] *= 2;\n            number_list[currentIndex + 1] = 0;\n        }\n    }\n    int nonZeroCount = 0;\n    for(int currentIndex = 0; currentIndex < listSize; ++currentIndex)\n    {\n        if(number_list[currentIndex] != 0)\n        {\n            number_list[nonZeroCount++] = number_list[currentIndex];\n        }\n    }\n    while(nonZeroCount < listSize)\n    {\n        number_list[nonZeroCount++] = 0;\n    }\n    return number_list;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSubarraySumWithDistinctElements(vector<int> &numbers, int windowSize)\n{\n    int maxSum = 0, currentWindowSum = 0;\n    unordered_map<int, int> frequencyMap;\n\n    for (int index = 0; index < numbers.size(); index++)\n    {\n        frequencyMap[numbers[index]]++;\n        currentWindowSum += numbers[index];\n        if (index >= windowSize)\n        {\n            frequencyMap[numbers[index - windowSize]]--;\n            currentWindowSum -= numbers[index - windowSize];\n        }\n        if (index >= windowSize - 1)\n        {\n            bool isDistinct = true;\n            // Modify the range-based for loop to a traditional for loop\n            for (int i = 0; i < frequencyMap.size(); ++i)\n            {\n                auto it = frequencyMap.begin();\n                advance(it, i);\n                if (it->second > 1)\n                {\n                    isDistinct = false;\n                    break;\n                }\n            }\n            if (isDistinct)\n            {\n                maxSum = max(maxSum, currentWindowSum);\n            }\n        }\n    }\n    return maxSum;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint MaxSubarraySumWithDistinctElements(std::vector<int> &numbers, int window_size)\n{\n    int maxSum= 0, currentWindowSum= 0;\n    std::unordered_map<int, int> frequencyMap;\n\n    for(int index= 0; index < numbers.size(); index++)\n    {\n        frequencyMap[numbers[index]]++;\n        currentWindowSum+= numbers[index];\n        if(index >= window_size)\n        {\n            frequencyMap[numbers[index - window_size]]--;\n            currentWindowSum-= numbers[index - window_size];\n        }\n        if(index >= window_size - 1)\n        {\n            bool isDistinct= true;\n            for(const auto &pair : frequencyMap)\n            {\n                if(pair.second > 1)\n                {\n                    isDistinct= false;\n                    break;\n                }\n            }\n            if(isDistinct)\n            {\n                maxSum= std::max(maxSum, currentWindowSum);\n            }\n        }\n    }\n    return maxSum;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint hireWorkers(vector<int> &workerCosts, int numberOfWorkers, int candidateLimit)\n{\n    int totalCosts= workerCosts.size();\n    vector<pair<int, int>> workers;\n    for(int i= 0; i < totalCosts; ++i)\n        workers.emplace_back(workerCosts[i], i);\n    sort(workers.begin(), workers.end());\n\n    int totalCost= 0;\n    for(int i= 0; i < numberOfWorkers; ++i)\n    {\n        if(min(workers[i].second, totalCosts - workers[i].second - 1) < candidateLimit)\n            totalCost+= workers[i].first;\n    }\n    return totalCost;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint HireWorkers(std::vector<int> &worker_costs, int number_of_workers, int candidate_limit)\n{\n    int totalCosts= worker_costs.size();\n    std::vector<std::pair<int, int>> workers;\n    for(int i= 0; i < totalCosts; ++i)\n        workers.emplace_back(worker_costs[i], i);\n    std::sort(workers.begin(), workers.end());\n\n    int totalCost= 0;\n    for(int i= 0; i < number_of_workers; ++i)\n    {\n        if(std::min(workers[i].second, totalCosts - workers[i].second - 1) < candidate_limit)\n            totalCost+= workers[i].first;\n    }\n    return totalCost;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\n// for abs\nusing namespace std;\n\nint calculateMinimumTotalDistance(vector<int> &robotPositions, vector<vector<int>> &factoryLocations)\n{\n    sort(robotPositions.begin(), robotPositions.end());\n    sort(factoryLocations.begin(), factoryLocations.end());\n\n    int totalDistance = 0, robotIndex = 0;\n    for (int i = 0; i < factoryLocations.size(); ++i)\n    {\n        const auto &factory = factoryLocations[i];\n        int availableCapacity = factory[1];\n        while (availableCapacity-- > 0 && robotIndex < robotPositions.size())\n        {\n            totalDistance += abs(factory[0] - robotPositions[robotIndex]);\n            robotIndex++;\n        }\n    }\n\n    return totalDistance;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint CalculateMinimumTotalDistance(std::vector<int> &robot_positions, std::vector<std::vector<int>> &factory_locations)\n{\n    std::sort(robot_positions.begin(), robot_positions.end());\n    std::sort(factory_locations.begin(), factory_locations.end());\n\n    int totalDistance= 0, robotIndex= 0;\n    for(const auto &factory : factory_locations)\n    {\n        int availableCapacity= factory[1];\n        while(availableCapacity-- > 0 && robotIndex < robot_positions.size())\n        {\n            totalDistance+= std::abs(factory[0] - robot_positions[robotIndex]);\n            robotIndex++;\n        }\n    }\n\n    return totalDistance;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minValidSubarrays(vector<int> &numberList)\n{\n    int subarrayCount= 0;\n    for(int currentIndex= 0; currentIndex < numberList.size(); currentIndex++)\n    {\n        while(currentIndex < numberList.size() && gcd(numberList[currentIndex], numberList.back()) == 1)\n        {\n            currentIndex++;\n        }\n        if(currentIndex < numberList.size())\n        {\n            subarrayCount++;\n            numberList.pop_back();\n        }\n    }\n    return subarrayCount > 0 ? subarrayCount : -1;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint MinValidSubarrays(vector<int> &number_list)\n{\n    int subarrayCount= 0;\n    for(int currentIndex= 0; currentIndex < number_list.size(); currentIndex++)\n    {\n        while(currentIndex < number_list.size() && std::gcd(number_list[currentIndex], number_list.back()) == 1)\n        {\n            currentIndex++;\n        }\n        if(currentIndex < number_list.size())\n        {\n            subarrayCount++;\n            number_list.pop_back();\n        }\n    }\n    return subarrayCount > 0 ? subarrayCount : -1;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint distinctAverages(vector<int> &numberList)\n{\n    set<double> uniqueAverages;\n    sort(numberList.begin(), numberList.end());\n    int listSize= numberList.size();\n    for(int index= 0; index < listSize / 2; index++)\n    {\n        uniqueAverages.insert((numberList[index] + numberList[listSize - 1 - index]) / 2.0);\n    }\n    return uniqueAverages.size();\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint DistinctAverages(std::vector<int> &number_list)\n{\n    std::set<double> uniqueAverages;\n    std::sort(number_list.begin(), number_list.end());\n    int listSize= number_list.size();\n    for(int index= 0; index < listSize / 2; index++)\n    {\n        uniqueAverages.insert((number_list[index] + number_list[listSize - 1 - index]) / 2.0);\n    }\n    return uniqueAverages.size();\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint modulusPower(long base, int exponent, int modulus)\n{\n    long result= 1;\n    while(exponent > 0)\n    {\n        if(exponent % 2 == 1)\n        {\n            result= (result * base) % modulus;\n        }\n        base= (base * base) % modulus;\n        exponent/= 2;\n    }\n    return (int)result;\n}\n\nint countGoodStrings(int minLength, int maxLength, int zeroCount, int oneCount)\n{\n    long modulus= 1000000007;\n    return (((modulusPower(2, maxLength, modulus) - modulusPower(2, minLength - 1, modulus) + 1) * (zeroCount + 1)) % modulus * (oneCount + 1)) % modulus;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int ModulusPower(long base, int exponent, int modulus)\n{\n    long result= 1;\n    while(exponent > 0)\n    {\n        if(exponent % 2 == 1)\n        {\n            result= (result * base) % modulus;\n        }\n        base= (base * base) % modulus;\n        exponent/= 2;\n    }\n    return (int)result;\n}\n\nint CountGoodStrings(int min_length, int max_length, int zero_count, int one_count)\n{\n    long modulus= 1000000007;\n    return (((ModulusPower(2, max_length, modulus) - ModulusPower(2, min_length - 1, modulus) + 1) * (zero_count + 1)) % modulus * (one_count + 1)) % modulus;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid depthFirstSearch(int currentNode, int parentNode, int bobTime, int currentTime, int &aliceIncome, int &maximumIncome, vector<int> &amounts, unordered_map<int, vector<int>> &tree)\n{\n    if(currentTime < bobTime || amounts[currentNode] >= 0)\n    {\n        aliceIncome += amounts[currentNode];\n    }\n    else\n    {\n        aliceIncome += amounts[currentNode] / 2;\n    }\n    amounts[currentNode] = 0;\n    bool isLeafNode = true;\n    for(int j = 0; j < tree[currentNode].size(); ++j)\n    {\n        int childNode = tree[currentNode][j];\n        if(childNode != parentNode)\n        {\n            isLeafNode = false;\n            int temporaryIncome = aliceIncome;\n            depthFirstSearch(childNode, currentNode, bobTime, currentTime + 1, temporaryIncome, maximumIncome, amounts, tree);\n        }\n    }\n    if(isLeafNode)\n    {\n        maximumIncome = max(maximumIncome, aliceIncome);\n    }\n}\n\nint calculateMaxNetIncome(vector<vector<int>> &edges, int bobTime, vector<int> &amounts)\n{\n    unordered_map<int, vector<int>> tree;\n    for(const auto &edge : edges)\n    {\n        tree[edge[0]].emplace_back(edge[1]);\n        tree[edge[1]].emplace_back(edge[0]);\n    }\n    int maximumIncome = -100000;\n    int aliceIncome = 0;\n    depthFirstSearch(0, -1, bobTime, 0, aliceIncome, maximumIncome, amounts, tree);\n    return maximumIncome;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nvoid DepthFirstSearch(int current_node, int parent_node, int bob_time, int current_time, int &alice_income, int &maximum_income, std::vector<int> &amounts, std::unordered_map<int, std::vector<int>> &tree)\n{\n    if(current_time < bob_time || amounts[current_node] >= 0)\n    {\n        alice_income+= amounts[current_node];\n    }\n    else\n    {\n        alice_income+= amounts[current_node] / 2;\n    }\n    amounts[current_node]= 0;\n    bool isLeafNode= true;\n    for(int child_node : tree[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            isLeafNode= false;\n            int temporary_income= alice_income;\n            DepthFirstSearch(child_node, current_node, bob_time, current_time + 1, temporary_income, maximum_income, amounts, tree);\n        }\n    }\n    if(isLeafNode)\n    {\n        maximum_income= std::max(maximum_income, alice_income);\n    }\n}\n\nint CalculateMaxNetIncome(std::vector<std::vector<int>> &edges, int bob_time, std::vector<int> &amounts)\n{\n    std::unordered_map<int, std::vector<int>> tree;\n    for(const auto &edge : edges)\n    {\n        tree[edge[0]].emplace_back(edge[1]);\n        tree[edge[1]].emplace_back(edge[0]);\n    }\n    int maximum_income= -100000;\n    int alice_income= 0;\n    DepthFirstSearch(0, -1, bob_time, 0, alice_income, maximum_income, amounts, tree);\n    return maximum_income;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> splitMessage(string inputMessage, int characterLimit)\n{\n    int messageLength= inputMessage.size();\n    int extraCharacters= (characterLimit - 3) * (messageLength / (characterLimit - 3)) - messageLength;\n    int fullParts= messageLength / (characterLimit - 3);\n    if((messageLength + fullParts + extraCharacters) % (characterLimit - 2) != 0)\n        return {};\n    int numberOfParts= (messageLength + fullParts + extraCharacters) / (characterLimit - 2);\n    vector<string> messageParts;\n    for(int currentIndex= 0, partIndex= 1, characterCount= 0; currentIndex < messageLength || partIndex <= numberOfParts;)\n    {\n        string tempPart;\n        while(characterCount < characterLimit - 3)\n        {\n            characterCount++;\n            tempPart+= inputMessage[currentIndex++];\n            if(currentIndex == messageLength)\n                break;\n        }\n        characterCount= 0;\n        tempPart+= to_string(partIndex) + \"/\" + to_string(numberOfParts) + \" \";\n        partIndex++;\n        messageParts.push_back(tempPart);\n    }\n    return messageParts;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::string> SplitMessage(std::string input_message, int character_limit)\n{\n    int messageLength = input_message.size();\n    int extraCharacters = (character_limit - 3) * (messageLength / (character_limit - 3)) - messageLength;\n    int fullParts = messageLength / (character_limit - 3);\n    if ((messageLength + fullParts + extraCharacters) % (character_limit - 2) != 0)\n        return {};\n    int numberOfParts = (messageLength + fullParts + extraCharacters) / (character_limit - 2);\n    std::vector<std::string> messageParts;\n    for (int currentIndex = 0, partIndex = 1, characterCount = 0; currentIndex < messageLength || partIndex <= numberOfParts;)\n    {\n        std::string tempPart;\n        while (characterCount < character_limit - 3)\n        {\n            characterCount++;\n            tempPart += input_message[currentIndex++];\n            if (currentIndex == messageLength)\n                break;\n        }\n        characterCount = 0;\n        tempPart += std::to_string(partIndex) + \"/\" + std::to_string(numberOfParts) + \" \";\n        partIndex++;\n        messageParts.push_back(tempPart);\n    }\n    return messageParts;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<double> convertTemperature(double celsiusTemperature)\n{\n    double kelvinTemperature = celsiusTemperature + 273.15;\n    double fahrenheitTemperature = celsiusTemperature * 1.80 + 32.00;\n    return {kelvinTemperature, fahrenheitTemperature};\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nstd::vector<double> ConvertTemperature(double celsius_temperature)\n{\n    double kelvinTemperature= celsius_temperature + 273.15;\n    double fahrenheitTemperature= celsius_temperature * 1.80 + 32.00;\n    return {kelvinTemperature, fahrenheitTemperature};\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lcm(int firstNumber, int secondNumber)\n{\n    int currentMultiple= firstNumber;\n    while((currentMultiple % secondNumber) != 0)\n    {\n        currentMultiple+= firstNumber;\n    }\n    return currentMultiple;\n}\n\nint countLcmSubarrays(vector<int> &numberArray, int targetLcm)\n{\n    int subarrayCount= 0;\n    for(int startIndex= 0; startIndex < numberArray.size(); startIndex++)\n    {\n        int currentLcm= numberArray[startIndex];\n        for(int endIndex= startIndex; endIndex < numberArray.size(); endIndex++)\n        {\n            currentLcm= lcm(currentLcm, numberArray[endIndex]);\n            if(currentLcm == targetLcm)\n            {\n                subarrayCount++;\n            }\n        }\n    }\n    return subarrayCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint Lcm(int first_number, int second_number)\n{\n    int currentMultiple= first_number;\n    while((currentMultiple % second_number) != 0)\n    {\n        currentMultiple+= first_number;\n    }\n    return currentMultiple;\n}\n\nint CountLcmSubarrays(std::vector<int> &number_array, int target_lcm)\n{\n    int subarrayCount= 0;\n    for(int startIndex= 0; startIndex < number_array.size(); startIndex++)\n    {\n        int currentLcm= number_array[startIndex];\n        for(int endIndex= startIndex; endIndex < number_array.size(); endIndex++)\n        {\n            currentLcm= Lcm(currentLcm, number_array[endIndex]);\n            if(currentLcm == target_lcm)\n            {\n                subarrayCount++;\n            }\n        }\n    }\n    return subarrayCount;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nint calculateMinSwaps(TreeNode *rootNode)\n{\n    int swapCount= 0;\n    queue<pair<TreeNode *, int>> nodeQueue;\n    nodeQueue.push({rootNode, 0});\n\n    vector<int> levelValues;\n    int previousDepth= -1;\n\n    while(!nodeQueue.empty())\n    {\n        auto currentNode= nodeQueue.front();\n        nodeQueue.pop();\n        TreeNode *currentTreeNode= currentNode.first;\n        int currentDepth= currentNode.second;\n\n        if(previousDepth != currentDepth)\n        {\n            sort(levelValues.begin(), levelValues.end());\n            for(int i= 1; i < levelValues.size(); ++i)\n            {\n                swapCount+= abs(levelValues[i] - levelValues[i - 1]) - 1;\n            }\n            previousDepth= currentDepth;\n            levelValues.clear();\n        }\n        levelValues.push_back(currentTreeNode->value);\n\n        if(currentTreeNode->leftChild)\n            nodeQueue.push({currentTreeNode->leftChild, currentDepth + 1});\n        if(currentTreeNode->rightChild)\n            nodeQueue.push({currentTreeNode->rightChild, currentDepth + 1});\n    }\n\n    sort(levelValues.begin(), levelValues.end());\n    for(int i= 1; i < levelValues.size(); ++i)\n    {\n        swapCount+= abs(levelValues[i] - levelValues[i - 1]) - 1;\n    }\n\n    return swapCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nint CalculateMinSwaps(TreeNode *root_node)\n{\n    int swapCount= 0;\n    std::queue<std::pair<TreeNode *, int>> nodeQueue;\n    nodeQueue.push({root_node, 0});\n\n    std::vector<int> levelValues;\n    int previousDepth= -1;\n\n    while(!nodeQueue.empty())\n    {\n        auto currentNode= nodeQueue.front();\n        nodeQueue.pop();\n        TreeNode *currentTreeNode= currentNode.first;\n        int currentDepth= currentNode.second;\n\n        if(previousDepth != currentDepth)\n        {\n            std::sort(levelValues.begin(), levelValues.end());\n            for(int i= 1; i < levelValues.size(); ++i)\n            {\n                swapCount+= std::abs(levelValues[i] - levelValues[i - 1]) - 1;\n            }\n            previousDepth= currentDepth;\n            levelValues.clear();\n        }\n        levelValues.push_back(currentTreeNode->value);\n\n        if(currentTreeNode->leftChild)\n            nodeQueue.push({currentTreeNode->leftChild, currentDepth + 1});\n        if(currentTreeNode->rightChild)\n            nodeQueue.push({currentTreeNode->rightChild, currentDepth + 1});\n    }\n\n    std::sort(levelValues.begin(), levelValues.end());\n    for(int i= 1; i < levelValues.size(); ++i)\n    {\n        swapCount+= std::abs(levelValues[i] - levelValues[i - 1]) - 1;\n    }\n\n    return swapCount;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countMaxPalindromicSubstrings(string inputString, int minLength)\n{\n    int stringLength= inputString.size();\n    if(stringLength < minLength)\n    {\n        return 0;\n    }\n    int palindromeCount= 0;\n    vector<vector<bool>> isPalindrome(stringLength, vector<bool>(stringLength, false));\n    for(int startIndex= stringLength - 1; startIndex >= 0; startIndex--)\n    {\n        for(int endIndex= startIndex; endIndex < stringLength; endIndex++)\n        {\n            if(startIndex == endIndex)\n            {\n                isPalindrome[startIndex][endIndex]= true;\n            }\n            else if(inputString[startIndex] == inputString[endIndex])\n            {\n                isPalindrome[startIndex][endIndex]= startIndex + 1 > endIndex - 1 || isPalindrome[startIndex + 1][endIndex - 1];\n            }\n            else\n            {\n                isPalindrome[startIndex][endIndex]= false;\n            }\n            if(endIndex - startIndex + 1 >= minLength && isPalindrome[startIndex][endIndex])\n            {\n                palindromeCount++;\n                startIndex= endIndex;\n                break;\n            }\n        }\n    }\n    return palindromeCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint CountMaxPalindromicSubstrings(std::string input_string, int min_length)\n{\n    int stringLength= input_string.size();\n    if(stringLength < min_length)\n    {\n        return 0;\n    }\n    int palindromeCount= 0;\n    std::vector<std::vector<bool>> isPalindrome(stringLength, std::vector<bool>(stringLength, false));\n    for(int startIndex= stringLength - 1; startIndex >= 0; startIndex--)\n    {\n        for(int endIndex= startIndex; endIndex < stringLength; endIndex++)\n        {\n            if(startIndex == endIndex)\n            {\n                isPalindrome[startIndex][endIndex]= true;\n            }\n            else if(input_string[startIndex] == input_string[endIndex])\n            {\n                isPalindrome[startIndex][endIndex]= startIndex + 1 > endIndex - 1 || isPalindrome[startIndex + 1][endIndex - 1];\n            }\n            else\n            {\n                isPalindrome[startIndex][endIndex]= false;\n            }\n            if(endIndex - startIndex + 1 >= min_length && isPalindrome[startIndex][endIndex])\n            {\n                palindromeCount++;\n                startIndex= endIndex;\n                break;\n            }\n        }\n    }\n    return palindromeCount;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> minTotalCost(int numberOfCities, vector<vector<int>> &roads, vector<int> &appleCosts, int k)\n{\n    vector<vector<pair<int, int>>> cityGraph(numberOfCities + 1);\n    for (int i = 0; i < roads.size(); ++i)\n    {\n        cityGraph[roads[i][0]].push_back({roads[i][1], roads[i][2]});\n        cityGraph[roads[i][1]].push_back({roads[i][0], roads[i][2]});\n    }\n\n    vector<int> totalCosts(numberOfCities);\n    for (int startCity = 1; startCity <= numberOfCities; ++startCity)\n    {\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> minHeap;\n        vector<int> distance(numberOfCities + 1, 1e9);\n        distance[startCity] = 0;\n        minHeap.push({0, startCity});\n        while (!minHeap.empty())\n        {\n            int currentCity = minHeap.top().second;\n            int currentDistance = minHeap.top().first;\n            minHeap.pop();\n\n            if (currentDistance > distance[currentCity])\n                continue;\n\n            for (int j = 0; j < cityGraph[currentCity].size(); ++j)\n            {\n                int adjacentCity = cityGraph[currentCity][j].first;\n                int cost = currentDistance + cityGraph[currentCity][j].second + (currentCity != startCity ? cityGraph[currentCity][j].second * k : 0) + appleCosts[adjacentCity - 1];\n\n                if (cost < distance[adjacentCity])\n                {\n                    distance[adjacentCity] = cost;\n                    minHeap.push({cost, adjacentCity});\n                }\n            }\n        }\n\n        totalCosts[startCity - 1] = distance[startCity];\n    }\n    return totalCosts;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> MinTotalCost(int number_of_cities, std::vector<std::vector<int>> &roads, std::vector<int> &apple_costs, int k)\n{\n    std::vector<std::vector<std::pair<int, int>>> cityGraph(number_of_cities + 1);\n    for(auto &road : roads)\n    {\n        cityGraph[road[0]].push_back({road[1], road[2]});\n        cityGraph[road[1]].push_back({road[0], road[2]});\n    }\n\n    std::vector<int> totalCosts(number_of_cities);\n    for(int startCity= 1; startCity <= number_of_cities; ++startCity)\n    {\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> minHeap;\n        std::vector<int> distance(number_of_cities + 1, 1e9);\n        distance[startCity]= 0;\n        minHeap.push({0, startCity});\n        while(!minHeap.empty())\n        {\n            int currentCity= minHeap.top().second;\n            int currentDistance= minHeap.top().first;\n            minHeap.pop();\n\n            if(currentDistance > distance[currentCity])\n                continue;\n\n            for(auto &edge : cityGraph[currentCity])\n            {\n                int adjacentCity= edge.first;\n                int cost= currentDistance + edge.second + (currentCity != startCity ? edge.second * k : 0) + apple_costs[adjacentCity - 1];\n\n                if(cost < distance[adjacentCity])\n                {\n                    distance[adjacentCity]= cost;\n                    minHeap.push({cost, adjacentCity});\n                }\n            }\n        }\n\n        totalCosts[startCity - 1]= distance[startCity];\n    }\n    return totalCosts;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countTriplets(vector<int> &numberList)\n{\n    int tripletCount= 0;\n    int listSize= numberList.size();\n\n    for(int firstIndex= 0; firstIndex < listSize; firstIndex++)\n    {\n        for(int secondIndex= firstIndex + 1; secondIndex < listSize; secondIndex++)\n        {\n            for(int thirdIndex= secondIndex + 1; thirdIndex < listSize; thirdIndex++)\n            {\n                if(numberList[firstIndex] != numberList[secondIndex] && numberList[firstIndex] != numberList[thirdIndex] && numberList[secondIndex] != numberList[thirdIndex])\n                {\n                    tripletCount++;\n                }\n            }\n        }\n    }\n\n    return tripletCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint CountTriplets(std::vector<int> &number_list)\n{\n    int tripletCount= 0;\n    int listSize= number_list.size();\n\n    for(int firstIndex= 0; firstIndex < listSize; firstIndex++)\n    {\n        for(int secondIndex= firstIndex + 1; secondIndex < listSize; secondIndex++)\n        {\n            for(int thirdIndex= secondIndex + 1; thirdIndex < listSize; thirdIndex++)\n            {\n                if(number_list[firstIndex] != number_list[secondIndex] && number_list[firstIndex] != number_list[thirdIndex] && number_list[secondIndex] != number_list[thirdIndex])\n                {\n                    tripletCount++;\n                }\n            }\n        }\n    }\n\n    return tripletCount;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nvector<vector<int>> findMinMax(TreeNode *root, vector<int> &queries)\n{\n    if(!root)\n    {\n        return {};\n    }\n\n    vector<vector<int>> result(queries.size(), vector<int>{-1, -1});\n    for(size_t index= 0; index < queries.size(); index++)\n    {\n        TreeNode *currentNode= root;\n        int currentQuery= queries[index];\n        while(currentNode)\n        {\n            if(currentNode->value < currentQuery)\n            {\n                result[index][0]= currentNode->value;\n                currentNode= currentNode->rightChild;\n            }\n            else\n            {\n                result[index][1]= currentNode->value;\n                if(currentNode->value == currentQuery)\n                {\n                    result[index][0]= currentQuery;\n                    break;\n                }\n                currentNode= currentNode->leftChild;\n            }\n        }\n    }\n    return result;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nstd::vector<std::vector<int>> FindMinMax(TreeNode *root, std::vector<int> &queries)\n{\n    if(!root)\n    {\n        return {};\n    }\n\n    std::vector<std::vector<int>> result(queries.size(), std::vector<int>{-1, -1});\n    for(size_t index= 0; index < queries.size(); index++)\n    {\n        TreeNode *currentNode= root;\n        int currentQuery= queries[index];\n        while(currentNode)\n        {\n            if(currentNode->value < currentQuery)\n            {\n                result[index][0]= currentNode->value;\n                currentNode= currentNode->rightChild;\n            }\n            else\n            {\n                result[index][1]= currentNode->value;\n                if(currentNode->value == currentQuery)\n                {\n                    result[index][0]= currentQuery;\n                    break;\n                }\n                currentNode= currentNode->leftChild;\n            }\n        }\n    }\n    return result;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMinimumFuel(vector<vector<int>> &roadConnections, int seatCapacity)\n{\n    int numberOfCities = roadConnections.size() + 1;\n    vector<vector<int>> cityGraph(numberOfCities);\n    for (const auto &road : roadConnections) // This can remain as a range-based for loop\n    {\n        cityGraph[road[0]].push_back(road[1]);\n        cityGraph[road[1]].push_back(road[0]);\n    }\n\n    vector<int> cityDistance(numberOfCities, -1);\n    queue<int> cityQueue;\n    cityQueue.push(0);\n    cityDistance[0] = 0;\n\n    while (!cityQueue.empty())\n    {\n        int currentCity = cityQueue.front();\n        cityQueue.pop();\n        for (int neighborCity : cityGraph[currentCity]) // This can remain as a range-based for loop\n        {\n            if (cityDistance[neighborCity] == -1)\n            {\n                cityDistance[neighborCity] = cityDistance[currentCity] + 1;\n                cityQueue.push(neighborCity);\n            }\n        }\n    }\n\n    int totalFuelRequired = 0;\n    for (int cityIndex = 1; cityIndex < numberOfCities; cityIndex++)\n    {\n        totalFuelRequired += (cityDistance[cityIndex] - 1) / (seatCapacity - 1) + 1;\n    }\n    return totalFuelRequired;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint CalculateMinimumFuel(std::vector<std::vector<int>> &road_connections, int seat_capacity)\n{\n    int numberOfCities= road_connections.size() + 1;\n    std::vector<std::vector<int>> cityGraph(numberOfCities);\n    for(auto &road : road_connections)\n    {\n        cityGraph[road[0]].push_back(road[1]);\n        cityGraph[road[1]].push_back(road[0]);\n    }\n\n    std::vector<int> cityDistance(numberOfCities, -1);\n    std::queue<int> cityQueue;\n    cityQueue.push(0);\n    cityDistance[0]= 0;\n\n    while(!cityQueue.empty())\n    {\n        int currentCity= cityQueue.front();\n        cityQueue.pop();\n        for(int neighborCity : cityGraph[currentCity])\n        {\n            if(cityDistance[neighborCity] == -1)\n            {\n                cityDistance[neighborCity]= cityDistance[currentCity] + 1;\n                cityQueue.push(neighborCity);\n            }\n        }\n    }\n\n    int totalFuelRequired= 0;\n    for(int cityIndex= 1; cityIndex < numberOfCities; cityIndex++)\n    {\n        totalFuelRequired+= (cityDistance[cityIndex] - 1) / (seat_capacity - 1) + 1;\n    }\n    return totalFuelRequired;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint numBeautifulPartitions(const string &inputString, int partitionCount, int minimumLength)\n{\n    const int modulo= 1e9 + 7;\n    unordered_set<char> primeDigits= {'2', '3', '5', '7'};\n    int stringLength= inputString.length();\n    vector<vector<int>> dynamicProgramming(stringLength + 1, vector<int>(partitionCount + 1, 0));\n    dynamicProgramming[0][0]= 1;\n\n    for(int currentIndex= 1; currentIndex <= stringLength; ++currentIndex)\n    {\n        for(int currentPartitions= 1; currentPartitions <= partitionCount; ++currentPartitions)\n        {\n            for(int length= minimumLength; length <= currentIndex && currentIndex - length >= currentPartitions - 1; ++length)\n            {\n                if(primeDigits.count(inputString[currentIndex - length]) && !primeDigits.count(inputString[currentIndex - 1]))\n                {\n                    dynamicProgramming[currentIndex][currentPartitions]+= dynamicProgramming[currentIndex - length][currentPartitions - 1];\n                    if(dynamicProgramming[currentIndex][currentPartitions] >= modulo)\n                        dynamicProgramming[currentIndex][currentPartitions]-= modulo;\n                }\n            }\n        }\n    }\n\n    return dynamicProgramming[stringLength][partitionCount];\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nstd::unordered_set<char> primeDigits = {'2', '3', '5', '7'};\n\nint NumBeautifulPartitions(const std::string &input_string, int partition_count, int minimum_length)\n{\n    const int modulo = 1e9 + 7;\n    int stringLength = input_string.length();\n    std::vector<std::vector<int>> dynamicProgramming(stringLength + 1, std::vector<int>(partition_count + 1, 0));\n    dynamicProgramming[0][0] = 1;\n\n    for(int currentIndex = 1; currentIndex <= stringLength; ++currentIndex)\n    {\n        for(int currentPartitions = 1; currentPartitions <= partition_count; ++currentPartitions)\n        {\n            for(int length = minimum_length; length <= currentIndex && currentIndex - length >= currentPartitions - 1; ++length)\n            {\n                if(primeDigits.count(input_string[currentIndex - length]) && !primeDigits.count(input_string[currentIndex - 1]))\n                {\n                    dynamicProgramming[currentIndex][currentPartitions] += dynamicProgramming[currentIndex - length][currentPartitions - 1];\n                    if(dynamicProgramming[currentIndex][currentPartitions] >= modulo)\n                        dynamicProgramming[currentIndex][currentPartitions] -= modulo;\n                }\n            }\n        }\n    }\n\n    return dynamicProgramming[stringLength][partition_count];\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<vector<int>> &adjacencyList, vector<int> &nodeValues, int &maximumXor)\n{\n    int currentXorSum = nodeValues[currentNode];\n\n    for (int i = 0; i < adjacencyList[currentNode].size(); ++i)\n    {\n        int childNode = adjacencyList[currentNode][i];\n        if (childNode != parentNode)\n        {\n            currentXorSum ^= depthFirstSearch(childNode, currentNode, adjacencyList, nodeValues, maximumXor);\n        }\n    }\n\n    maximumXor = max(maximumXor, currentXorSum);\n\n    return currentXorSum;\n}\n\nint maxXorSubtree(int totalNodes, vector<vector<int>> &edges, vector<int> &nodeValues)\n{\n    vector<vector<int>> adjacencyList(totalNodes);\n\n    for (const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1]);\n        adjacencyList[edge[1]].emplace_back(edge[0]);\n    }\n\n    int maximumXor = 0;\n    int rootXorSum = depthFirstSearch(0, -1, adjacencyList, nodeValues, maximumXor);\n\n    return rootXorSum ^ maximumXor;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nstd::unordered_map<int, std::vector<int>> adjacency_list;\n\nint DepthFirstSearch(int current_node, int parent_node, std::vector<std::vector<int>> &adjacency_list, std::vector<int> &node_values, int &maximum_xor)\n{\n    int currentXorSum= node_values[current_node];\n\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorSum^= DepthFirstSearch(childNode, current_node, adjacency_list, node_values, maximum_xor);\n        }\n    }\n\n    maximum_xor= std::max(maximum_xor, currentXorSum);\n\n    return currentXorSum;\n}\n\nint MaxXorSubtree(int total_nodes, std::vector<std::vector<int>> &edges, std::vector<int> &node_values)\n{\n    std::vector<std::vector<int>> adjacencyList(total_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1]);\n        adjacencyList[edge[1]].emplace_back(edge[0]);\n    }\n\n    int maximumXor= 0;\n    int rootXorSum= DepthFirstSearch(0, -1, adjacencyList, node_values, maximumXor);\n\n    return rootXorSum ^ maximumXor;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint minCuts(int number)\n{\n    if(number % 2 == 0)\n        return number / 2;\n    else\n        return number;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int MinCuts(int number)\n{\n    if(number % 2 == 0)\n        return number / 2;\n    else\n        return number;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> createDifferenceMatrix(vector<vector<int>> &inputGrid)\n{\n    int rowCount= inputGrid.size(), columnCount= inputGrid[0].size();\n    vector<int> rowSum(rowCount, 0), columnSum(columnCount, 0);\n    vector<vector<int>> differenceMatrix(rowCount, vector<int>(columnCount));\n\n    for(int currentRowIndex= 0; currentRowIndex < rowCount; ++currentRowIndex)\n    {\n        for(int currentColIndex= 0; currentColIndex < columnCount; ++currentColIndex)\n        {\n            rowSum[currentRowIndex]+= inputGrid[currentRowIndex][currentColIndex];\n            columnSum[currentColIndex]+= inputGrid[currentRowIndex][currentColIndex];\n        }\n    }\n\n    for(int currentRowIndex= 0; currentRowIndex < rowCount; ++currentRowIndex)\n    {\n        for(int currentColIndex= 0; currentColIndex < columnCount; ++currentColIndex)\n        {\n            differenceMatrix[currentRowIndex][currentColIndex]= rowSum[currentRowIndex] + columnSum[currentColIndex] - (columnCount - rowSum[currentRowIndex]) - (rowCount - columnSum[currentColIndex]);\n        }\n    }\n\n    return differenceMatrix;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> CreateDifferenceMatrix(std::vector<std::vector<int>> &input_grid)\n{\n    int rowCount= input_grid.size(), columnCount= input_grid[0].size();\n    std::vector<int> rowSum(rowCount, 0), columnSum(columnCount, 0);\n    std::vector<std::vector<int>> differenceMatrix(rowCount, std::vector<int>(columnCount));\n\n    for(int currentRowIndex= 0; currentRowIndex < rowCount; ++currentRowIndex)\n    {\n        for(int currentColIndex= 0; currentColIndex < columnCount; ++currentColIndex)\n        {\n            rowSum[currentRowIndex]+= input_grid[currentRowIndex][currentColIndex];\n            columnSum[currentColIndex]+= input_grid[currentRowIndex][currentColIndex];\n        }\n    }\n\n    for(int currentRowIndex= 0; currentRowIndex < rowCount; ++currentRowIndex)\n    {\n        for(int currentColIndex= 0; currentColIndex < columnCount; ++currentColIndex)\n        {\n            differenceMatrix[currentRowIndex][currentColIndex]= rowSum[currentRowIndex] + columnSum[currentColIndex] - (columnCount - rowSum[currentRowIndex]) - (rowCount - columnSum[currentColIndex]);\n        }\n    }\n\n    return differenceMatrix;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minPenalty(string customerSequence)\n{\n    int customerCount = customerSequence.length();\n    int openPenalty = 0, closedPenalty = 0;\n\n    for (int i = 0; i < customerCount; ++i)\n    {\n        char currentCustomer = customerSequence[i];\n        if (currentCustomer == 'N')\n            openPenalty++;\n        else\n            closedPenalty++;\n    }\n\n    int minimumPenalty = closedPenalty;\n    int currentPenalty = closedPenalty;\n\n    for (int index = 0; index < customerCount; index++)\n    {\n        if (customerSequence[index] == 'N')\n            currentPenalty--;\n        else\n            currentPenalty++;\n\n        minimumPenalty = min(minimumPenalty, currentPenalty);\n    }\n\n    return minimumPenalty;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint MinPenalty(std::string customer_sequence)\n{\n    int customerCount= customer_sequence.length();\n    int openPenalty= 0, closedPenalty= 0;\n\n    for(char currentCustomer : customer_sequence)\n    {\n        if(currentCustomer == 'N')\n            openPenalty++;\n        else\n            closedPenalty++;\n    }\n\n    int minimumPenalty= closedPenalty;\n    int currentPenalty= closedPenalty;\n\n    for(int index= 0; index < customerCount; index++)\n    {\n        if(customer_sequence[index] == 'N')\n            currentPenalty--;\n        else\n            currentPenalty++;\n\n        minimumPenalty= std::min(minimumPenalty, currentPenalty);\n    }\n\n    return minimumPenalty;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPalindromeSubsequences(string inputString, int modulus)\n{\n    int stringLength= inputString.size();\n    const int modulusValue= 1000000007;\n    vector<vector<int>> dpTable(10, vector<int>(stringLength, 0));\n    for(int i= 0; i < stringLength; ++i)\n        dpTable[inputString[i] - '0'][i]= 1;\n    for(int length= 1; length <= 4; ++length)\n    {\n        for(int digit= 0; digit < 10; ++digit)\n        {\n            for(int i= 0, j= length; j < stringLength; ++i, ++j)\n            {\n                dpTable[digit][j]= (dpTable[digit][j - 1] + (inputString[j] - '0' == digit)) % modulusValue;\n            }\n        }\n    }\n    long long totalCount= 0;\n    for(int firstDigit= 0; firstDigit < 10; ++firstDigit)\n    {\n        for(int secondDigit= 0; secondDigit < 10; ++secondDigit)\n        {\n            totalCount+= (1LL * dpTable[firstDigit][stringLength - 5] * dpTable[secondDigit][stringLength - 1]) % modulusValue;\n        }\n    }\n    return totalCount % modulusValue;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint CountPalindromeSubsequences(std::string input_string, int modulus)\n{\n    int stringLength= input_string.size();\n    const int modulusValue= 1000000007;\n    std::vector<std::vector<int>> dpTable(10, std::vector<int>(stringLength, 0));\n    for(int i= 0; i < stringLength; ++i)\n        dpTable[input_string[i] - '0'][i]= 1;\n    for(int length= 1; length <= 4; ++length)\n    {\n        for(int digit= 0; digit < 10; ++digit)\n        {\n            for(int i= 0, j= length; j < stringLength; ++i, ++j)\n            {\n                dpTable[digit][j]= (dpTable[digit][j - 1] + (input_string[j] - '0' == digit)) % modulusValue;\n            }\n        }\n    }\n    long long totalCount= 0;\n    for(int firstDigit= 0; firstDigit < 10; ++firstDigit)\n    {\n        for(int secondDigit= 0; secondDigit < 10; ++secondDigit)\n        {\n            totalCount+= (1LL * dpTable[firstDigit][stringLength - 5] * dpTable[secondDigit][stringLength - 1]) % modulusValue;\n        }\n    }\n    return totalCount % modulusValue;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint findPivot(int totalNumbers)\n{\n    int totalSum= totalNumbers * (totalNumbers + 1) / 2;\n    int leftSum= 0;\n    for(int currentNumber= 1; currentNumber <= totalNumbers; ++currentNumber)\n    {\n        leftSum+= currentNumber;\n        if(2 * leftSum == totalSum)\n        {\n            return currentNumber;\n        }\n    }\n    return -1;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int FindPivot(int total_numbers)\n{\n    int totalSum= total_numbers * (total_numbers + 1) / 2;\n    int leftSum= 0;\n    for(int currentNumber= 1; currentNumber <= total_numbers; ++currentNumber)\n    {\n        leftSum+= currentNumber;\n        if(2 * leftSum == totalSum)\n        {\n            return currentNumber;\n        }\n    }\n    return -1;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minAddition(string sourceString, string targetString)\n{\n    int sourceLength = sourceString.length();\n    int targetLength = targetString.length();\n    int sourceIndex = 0, targetIndex = 0;\n    while(sourceIndex < sourceLength && targetIndex < targetLength)\n    {\n        if(sourceString[sourceIndex] == targetString[targetIndex])\n        {\n            targetIndex++;\n        }\n        sourceIndex++;\n    }\n    return targetLength - targetIndex;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int MinAddition(std::string source_string, std::string target_string)\n{\n    int sourceLength= source_string.length();\n    int targetLength= target_string.length();\n    int sourceIndex= 0, targetIndex= 0;\n    while(sourceIndex < sourceLength && targetIndex < targetLength)\n    {\n        if(source_string[sourceIndex] == target_string[targetIndex])\n        {\n            targetIndex++;\n        }\n        sourceIndex++;\n    }\n    return targetLength - targetIndex;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nclass ListNode\n{\n  public:\n    int value;\n    ListNode *next;\n};\n\nListNode *removeNodes(ListNode *head)\n{\n    if(!head)\n        return NULL;\n    ListNode *maxNode= head;\n    ListNode *currentNode= head;\n    ListNode *previousNode= NULL;\n\n    while(currentNode && currentNode->next)\n    {\n        if(currentNode->next->value > maxNode->value)\n        {\n            if(previousNode)\n                previousNode->next= currentNode->next;\n            else\n                head= currentNode->next;\n            maxNode= currentNode->next;\n        }\n        else\n        {\n            previousNode= currentNode;\n        }\n        currentNode= currentNode->next;\n    }\n    maxNode->next= removeNodes(maxNode->next);\n    return head;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "class ListNode\n{\n  public:\n    int value;\n    ListNode *next;\n};\n\nListNode *RemoveNodes(ListNode *head)\n{\n    if(!head)\n        return NULL;\n    ListNode *maxNode= head;\n    ListNode *currentNode= head;\n    ListNode *previousNode= NULL;\n\n    while(currentNode && currentNode->next)\n    {\n        if(currentNode->next->value > maxNode->value)\n        {\n            if(previousNode)\n                previousNode->next= currentNode->next;\n            else\n                head= currentNode->next;\n            maxNode= currentNode->next;\n        }\n        else\n        {\n            previousNode= currentNode;\n        }\n        currentNode= currentNode->next;\n    }\n    maxNode->next= RemoveNodes(maxNode->next);\n    return head;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countSubarraysWithMedian(vector<int> &numbers, int target)\n{\n    int resultCount = 0;\n    for(int startIndex = 0; startIndex < numbers.size(); ++startIndex)\n    {\n        int targetCount = 0;\n        vector<int> subarray;\n        for(int endIndex = startIndex; endIndex < numbers.size(); ++endIndex)\n        {\n            targetCount += (numbers[endIndex] == target);\n            subarray.insert(lower_bound(subarray.begin(), subarray.end(), numbers[endIndex]), numbers[endIndex]);\n            if((subarray.size() % 2 == 1) && (subarray[subarray.size() / 2] == target))\n            {\n                resultCount += targetCount;\n            }\n        }\n    }\n    return resultCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int CountSubarraysWithMedian(std::vector<int> &numbers, int target)\n{\n    int resultCount= 0;\n    for(int startIndex= 0; startIndex < numbers.size(); ++startIndex)\n    {\n        int targetCount= 0;\n        std::vector<int> subarray;\n        for(int endIndex= startIndex; endIndex < numbers.size(); ++endIndex)\n        {\n            targetCount+= (numbers[endIndex] == target);\n            subarray.insert(lower_bound(subarray.begin(), subarray.end(), numbers[endIndex]), numbers[endIndex]);\n            if((subarray.size() % 2 == 1) && (subarray[subarray.size() / 2] == target))\n            {\n                resultCount+= targetCount;\n            }\n        }\n    }\n    return resultCount;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateRatioSubstringCount(string inputString, int firstNum, int secondNum)\n{\n    int zeroCount = 0, oneCount = 0;\n    map<int, int> frequencyMap;\n    int substringCount = 0;\n\n    frequencyMap[0] = 1;\n\n    for (int i = 0; i < inputString.size(); ++i)\n    {\n        char currentChar = inputString[i];\n        if (currentChar == '0')\n            zeroCount++;\n        else\n            oneCount++;\n\n        int currentDifference = zeroCount * secondNum - oneCount * firstNum;\n        substringCount += frequencyMap[currentDifference];\n        frequencyMap[currentDifference]++;\n    }\n    return substringCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int CalculateRatioSubstringCount(std::string input_string, int first_num, int second_num)\n{\n    int zeroCount= 0, oneCount= 0;\n    std::map<int, int> frequencyMap;\n    int substringCount= 0;\n\n    frequencyMap[0]= 1;\n\n    for(char currentChar : input_string)\n    {\n        if(currentChar == '0')\n            zeroCount++;\n        else\n            oneCount++;\n\n        int currentDifference= zeroCount * second_num - oneCount * first_num;\n        substringCount+= frequencyMap[currentDifference];\n        frequencyMap[currentDifference]++;\n    }\n    return substringCount;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isCircular(string sentence)\n{\n    stringstream stream(sentence);\n    string currentWord, previousWord;\n\n    while(stream >> currentWord)\n    {\n        if(!previousWord.empty() && previousWord.back() != currentWord.front())\n        {\n            return false;\n        }\n        previousWord = currentWord;\n    }\n\n    return currentWord.back() == sentence.front();\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "bool IsCircular(std::string sentence)\n{\n    std::stringstream stream(sentence);\n    std::string currentWord, previous_word;\n\n    while(stream >> current_word)\n    {\n        if(!previous_word.empty() && previous_word.back() != current_word.front())\n        {\n            return false;\n        }\n        previous_word= current_word;\n    }\n\n    return current_word.back() == sentence.front();\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maximumChemistry(vector<int> &skillLevels)\n{\n    int totalSum = 0;\n    for (int i = 0; i < skillLevels.size(); ++i)\n    {\n        totalSum += skillLevels[i];\n    }\n    int targetSum = totalSum / 2;\n    if (totalSum % 2 == 1)\n        return -1;\n\n    unordered_map<int, int> dynamicProgrammingMap;\n    dynamicProgrammingMap[0] = 1;\n    int maxChemistry = 0;\n\n    for (int i = 0; i < skillLevels.size(); ++i)\n    {\n        int skill = skillLevels[i];\n        for (int j = targetSum - skill; j >= 0; j--)\n        {\n            if (dynamicProgrammingMap[j])\n            {\n                dynamicProgrammingMap[j + skill] += dynamicProgrammingMap[j];\n                if (j + skill == targetSum)\n                {\n                    maxChemistry += dynamicProgrammingMap[j] * skill;\n                }\n            }\n        }\n    }\n\n    return (maxChemistry > 0) ? maxChemistry : -1;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint MaximumChemistry(std::vector<int> &skill_levels)\n{\n    int totalSum = 0;\n    for(int skill : skill_levels)\n    {\n        totalSum += skill;\n    }\n    int targetSum = totalSum / 2;\n    if(totalSum % 2 == 1)\n        return -1;\n\n    std::unordered_map<int, int> dynamicProgrammingMap;\n    dynamicProgrammingMap[0] = 1;\n    int maxChemistry = 0;\n\n    for(int skill : skill_levels)\n    {\n        for(int i = targetSum - skill; i >= 0; i--)\n        {\n            if(dynamicProgrammingMap[i])\n            {\n                dynamicProgrammingMap[i + skill] += dynamicProgrammingMap[i];\n                if(i + skill == targetSum)\n                {\n                    maxChemistry += dynamicProgrammingMap[i] * skill;\n                }\n            }\n        }\n    }\n\n    return (maxChemistry > 0) ? maxChemistry : -1;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumScore(int totalCities, vector<vector<int>> &roads)\n{\n    vector<vector<pair<int, int>>> adjacencyList(totalCities + 1);\n    for (int i = 0; i < roads.size(); ++i)\n    {\n        adjacencyList[roads[i][0]].push_back({roads[i][1], roads[i][2]});\n        adjacencyList[roads[i][1]].push_back({roads[i][0], roads[i][2]});\n    }\n\n    const int infinity = 1e9;\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> priorityQueue;\n    priorityQueue.push({0, 1});\n\n    vector<int> minimumDistance(totalCities + 1, infinity);\n    while (!priorityQueue.empty())\n    {\n        int currentCity = priorityQueue.top().second;\n        int currentDistance = priorityQueue.top().first;\n        priorityQueue.pop();\n\n        if (currentCity == totalCities)\n        {\n            return currentDistance;\n        }\n\n        if (currentDistance < minimumDistance[currentCity])\n        {\n            minimumDistance[currentCity] = currentDistance;\n            for (int j = 0; j < adjacencyList[currentCity].size(); ++j)\n            {\n                const auto &neighbor = adjacencyList[currentCity][j];\n                int nextCity = neighbor.first;\n                int nextDistance = max(currentDistance, neighbor.second);\n                if (nextDistance < minimumDistance[nextCity])\n                {\n                    priorityQueue.push({nextDistance, nextCity});\n                }\n            }\n        }\n    }\n\n    return -1;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint MinimumScore(int total_cities, std::vector<std::vector<int>> &roads)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(total_cities + 1);\n    for(const auto &road : roads)\n    {\n        adjacencyList[road[0]].push_back({road[1], road[2]});\n        adjacencyList[road[1]].push_back({road[0], road[2]});\n    }\n\n    const int infinity= 1e9;\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<>> priorityQueue;\n    priorityQueue.push({0, 1});\n\n    std::vector<int> minimumDistance(total_cities + 1, infinity);\n    while(!priorityQueue.empty())\n    {\n        int currentCity= priorityQueue.top().second;\n        int currentDistance= priorityQueue.top().first;\n        priorityQueue.pop();\n\n        if(currentCity == total_cities)\n        {\n            return currentDistance;\n        }\n\n        if(currentDistance < minimumDistance[currentCity])\n        {\n            minimumDistance[currentCity]= currentDistance;\n            for(const auto &neighbor : adjacencyList[currentCity])\n            {\n                int nextCity= neighbor.first;\n                int nextDistance= std::max(currentDistance, neighbor.second);\n                if(nextDistance < minimumDistance[nextCity])\n                {\n                    priorityQueue.push({nextDistance, nextCity});\n                }\n            }\n        }\n    }\n\n    return -1;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxGroups(int numberOfNodes, vector<vector<int>> &edges)\n{\n    vector<vector<int>> adjacencyList(numberOfNodes + 1);\n    vector<int> nodeColor(numberOfNodes + 1, 0);\n\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        adjacencyList[edges[i][0]].push_back(edges[i][1]);\n        adjacencyList[edges[i][1]].push_back(edges[i][0]);\n    }\n\n    int maximumGroupSize = 0;\n    for (int nodeIndex = 1; nodeIndex <= numberOfNodes; ++nodeIndex)\n    {\n        if (nodeColor[nodeIndex] == 0)\n        {\n            queue<int> nodeQueue;\n            nodeQueue.push(nodeIndex);\n            nodeColor[nodeIndex] = 1;\n            while (!nodeQueue.empty())\n            {\n                int currentNode = nodeQueue.front();\n                nodeQueue.pop();\n                maximumGroupSize = max(maximumGroupSize, nodeColor[currentNode]);\n                for (int j = 0; j < adjacencyList[currentNode].size(); ++j)\n                {\n                    int neighbor = adjacencyList[currentNode][j];\n                    if (nodeColor[neighbor] == 0)\n                    {\n                        nodeColor[neighbor] = nodeColor[currentNode] + 1;\n                        nodeQueue.push(neighbor);\n                    }\n                    else if (nodeColor[neighbor] == nodeColor[currentNode])\n                    {\n                        return -1;\n                    }\n                }\n            }\n        }\n    }\n    return maximumGroupSize;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint MaxGroups(int number_of_nodes, std::vector<std::vector<int>> &edges)\n{\n    std::vector<std::vector<int>> adjacencyList(number_of_nodes + 1);\n    std::vector<int> nodeColor(number_of_nodes + 1, 0);\n\n    for(auto &edge : edges)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    int maximumGroupSize= 0;\n    for(int nodeIndex= 1; nodeIndex <= number_of_nodes; ++nodeIndex)\n    {\n        if(nodeColor[nodeIndex] == 0)\n        {\n            std::queue<int> nodeQueue;\n            nodeQueue.push(nodeIndex);\n            nodeColor[nodeIndex]= 1;\n            while(!nodeQueue.empty())\n            {\n                int currentNode= nodeQueue.front();\n                nodeQueue.pop();\n                maximumGroupSize= std::max(maximumGroupSize, nodeColor[currentNode]);\n                for(int neighbor : adjacencyList[currentNode])\n                {\n                    if(nodeColor[neighbor] == 0)\n                    {\n                        nodeColor[neighbor]= nodeColor[currentNode] + 1;\n                        nodeQueue.push(neighbor);\n                    }\n                    else if(nodeColor[neighbor] == nodeColor[currentNode])\n                    {\n                        return -1;\n                    }\n                }\n            }\n        }\n    }\n    return maximumGroupSize;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countOfEvenSubarrays(vector<int> &numberArray)\n{\n    int arraySize = numberArray.size();\n    int evenCount = 0, oddCount = 0, totalCount = 0;\n\n    for (int i = 0; i < arraySize; ++i)\n    {\n        int currentNumber = numberArray[i];\n        if (currentNumber % 2 == 0)\n        {\n            evenCount++;\n            totalCount += evenCount;\n        }\n        else\n        {\n            swap(evenCount, oddCount);\n            oddCount++;\n            totalCount += oddCount;\n        }\n    }\n\n    return totalCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\n// For std::swap\n\nint CountOfEvenSubarrays(std::vector<int> &number_array)\n{\n    int arraySize= number_array.size();\n    int evenCount= 0, oddCount= 0, totalCount= 0;\n\n    for(int currentNumber : number_array)\n    {\n        if(currentNumber % 2 == 0)\n        {\n            evenCount++;\n            totalCount+= evenCount;\n        }\n        else\n        {\n            std::swap(evenCount, oddCount);\n            oddCount++;\n            totalCount+= oddCount;\n        }\n    }\n\n    return totalCount;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxValue(vector<string> &stringList)\n{\n    int maxValue = 0;\n    for (int i = 0; i < stringList.size(); ++i)\n    {\n        const string &currentString = stringList[i];\n        int currentValue;\n        if (currentString.find_first_not_of(\"0123456789\") == string::npos)\n        {\n            currentValue = stoi(currentString);\n        }\n        else\n        {\n            currentValue = static_cast<int>(currentString.length());\n        }\n        maxValue = max(maxValue, currentValue);\n    }\n    return maxValue;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint MaxValue(std::vector<std::string> &string_list)\n{\n    int maxValue= 0;\n    for(const std::string &currentString : string_list)\n    {\n        int currentValue;\n        if(currentString.find_first_not_of(\"0123456789\") == std::string::npos)\n        {\n            currentValue= std::stoi(currentString);\n        }\n        else\n        {\n            currentValue= static_cast<int>(currentString.length());\n        }\n        maxValue= std::max(maxValue, currentValue);\n    }\n    return maxValue;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxStarSum(const vector<int> &nodeValues, const vector<vector<int>> &edges, int k)\n{\n    vector<int> adjacencyList[100000];\n    int maximumSum = -1e9;\n\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        const vector<int> &edge = edges[i];\n        adjacencyList[edge[0]].push_back(nodeValues[edge[1]]);\n        adjacencyList[edge[1]].push_back(nodeValues[edge[0]]);\n    }\n\n    for (int nodeIndex = 0; nodeIndex < nodeValues.size(); nodeIndex++)\n    {\n        sort(adjacencyList[nodeIndex].rbegin(), adjacencyList[nodeIndex].rend());\n        int currentSum = nodeValues[nodeIndex];\n        for (int j = 0; j < k && j < adjacencyList[nodeIndex].size(); j++)\n        {\n            currentSum += adjacencyList[nodeIndex][j];\n        }\n        maximumSum = max(maximumSum, currentSum);\n    }\n\n    return maximumSum;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint MaxStarSum(const std::vector<int> &node_values, const std::vector<std::vector<int>> &edges, int k)\n{\n    std::vector<int> adjacencyList[100000];\n    int maximumSum= -1e9;\n\n    for(const std::vector<int> &edge : edges)\n    {\n        adjacencyList[edge[0]].push_back(node_values[edge[1]]);\n        adjacencyList[edge[1]].push_back(node_values[edge[0]]);\n    }\n\n    for(int nodeIndex= 0; nodeIndex < node_values.size(); nodeIndex++)\n    {\n        std::sort(adjacencyList[nodeIndex].rbegin(), adjacencyList[nodeIndex].rend());\n        int currentSum= node_values[nodeIndex];\n        for(int j= 0; j < k && j < adjacencyList[nodeIndex].size(); j++)\n        {\n            currentSum+= adjacencyList[nodeIndex][j];\n        }\n        maximumSum= std::max(maximumSum, currentSum);\n    }\n\n    return maximumSum;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumPathCost(vector<int> &stoneCosts)\n{\n    int numberOfStones= stoneCosts.size();\n    int minimumCost= stoneCosts[numberOfStones - 1];\n    for(int index= 1; index < numberOfStones - 1; ++index)\n    {\n        minimumCost= min(minimumCost, max(stoneCosts[index], stoneCosts[numberOfStones - 1] - stoneCosts[index]));\n    }\n    return minimumCost;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint MinimumPathCost(std::vector<int> &stone_costs)\n{\n    int numberOfStones= stone_costs.size();\n    int minimumCost= stone_costs[numberOfStones - 1];\n    for(int index= 1; index < numberOfStones - 1; ++index)\n    {\n        minimumCost= std::min(minimumCost, std::max(stone_costs[index], stone_costs[numberOfStones - 1] - stone_costs[index]));\n    }\n    return minimumCost;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minCost(vector<int> &firstArray, vector<int> &secondArray)\n{\n    unordered_map<int, vector<int>> valueToIndices;\n    for(int index = 0; index < firstArray.size(); ++index)\n    {\n        valueToIndices[firstArray[index]].push_back(index);\n    }\n\n    int totalCost = 0;\n    for(int i = 0; i < secondArray.size(); ++i)\n    {\n        int value = secondArray[i];\n        if(valueToIndices[value].empty())\n            return -1;\n        totalCost += valueToIndices[value].back();\n        valueToIndices[value].pop_back();\n    }\n\n    return totalCost;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint MinCost(std::vector<int> &first_array, std::vector<int> &second_array)\n{\n    std::unordered_map<int, std::vector<int>> valueToIndices;\n    for(int index= 0; index < first_array.size(); ++index)\n    {\n        valueToIndices[first_array[index]].push_back(index);\n    }\n\n    int totalCost= 0;\n    for(int value : second_array)\n    {\n        if(valueToIndices[value].empty())\n            return -1;\n        totalCost+= valueToIndices[value].back();\n        valueToIndices[value].pop_back();\n    }\n\n    return totalCost;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxValueAfterOperations(vector<vector<int>> &grid)\n{\n    int totalMaxValue= 0;\n    while(!grid.empty())\n    {\n        int currentMaxValue= 0, maxRowIndex= -1;\n\n        for(int rowIndex= 0; rowIndex < grid.size(); ++rowIndex)\n        {\n            auto maxElementIterator= max_element(grid[rowIndex].begin(), grid[rowIndex].end());\n            if(*maxElementIterator > currentMaxValue)\n            {\n                currentMaxValue= *maxElementIterator;\n                maxRowIndex= rowIndex;\n            }\n            grid[rowIndex].erase(maxElementIterator);\n        }\n\n        totalMaxValue+= currentMaxValue;\n        if(grid[maxRowIndex].empty())\n        {\n            grid.erase(grid.begin() + maxRowIndex);\n        }\n    }\n\n    return totalMaxValue;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint MaxValueAfterOperations(std::vector<std::vector<int>> &grid)\n{\n    int totalMaxValue= 0;\n    while(!grid.empty())\n    {\n        int currentMaxValue= 0, maxRowIndex= -1;\n\n        for(int rowIndex= 0; rowIndex < grid.size(); ++rowIndex)\n        {\n            auto maxElementIterator= std::max_element(grid[rowIndex].begin(), grid[rowIndex].end());\n            if(*maxElementIterator > currentMaxValue)\n            {\n                currentMaxValue= *maxElementIterator;\n                maxRowIndex= rowIndex;\n            }\n            grid[rowIndex].erase(maxElementIterator);\n        }\n\n        totalMaxValue+= currentMaxValue;\n        if(grid[maxRowIndex].empty())\n        {\n            grid.erase(grid.begin() + maxRowIndex);\n        }\n    }\n\n    return totalMaxValue;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint longestSquareStreak(vector<int> &numberList)\n{\n    unordered_set<int> numberSet(numberList.begin(), numberList.end());\n    int longestStreak = -1;\n\n    for (auto it = numberSet.begin(); it != numberSet.end(); ++it)\n    {\n        int currentNumber = *it;\n        int currentStreak = 1;\n\n        while (numberSet.count(static_cast<int>(pow(currentNumber, 0.5))) > 0)\n        {\n            ++currentStreak;\n            currentNumber = static_cast<int>(pow(currentNumber, 0.5));\n        }\n\n        longestStreak = max(longestStreak, currentStreak);\n    }\n\n    return longestStreak >= 2 ? longestStreak : -1;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint LongestSquareStreak(std::vector<int> &number_list)\n{\n    std::unordered_set<int> numberSet(number_list.begin(), number_list.end());\n    int longestStreak= -1;\n\n    for(int currentNumber : numberSet)\n    {\n        int currentStreak= 1;\n\n        while(numberSet.count(static_cast<int>(std::pow(currentNumber, 0.5))) > 0)\n        {\n            ++currentStreak;\n            currentNumber= static_cast<int>(std::pow(currentNumber, 0.5));\n        }\n\n        longestStreak= std::max(longestStreak, currentStreak);\n    }\n\n    return longestStreak >= 2 ? longestStreak : -1;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nclass Allocator\n{\n    vector<int> memory;\n\n  public:\n    Allocator(int size) : memory(size, 0) {}\n\n    int allocate(int blockSize, int memoryId)\n    {\n        int startIndex= -1, freeCount= 0;\n        for(int i= 0; i <= memory.size(); ++i)\n        {\n            if(i < memory.size() && memory[i] == 0)\n            {\n                if(startIndex == -1)\n                    startIndex= i;\n                freeCount++;\n            }\n            else\n            {\n                if(freeCount >= blockSize)\n                {\n                    fill(memory.begin() + startIndex, memory.begin() + startIndex + blockSize, memoryId);\n                    return startIndex;\n                }\n                startIndex= -1;\n                freeCount= 0;\n            }\n        }\n        return -1;\n    }\n\n    int free(int memoryId)\n    {\n        int freedCount= 0;\n        for(int i= 0; i < memory.size(); ++i)\n        {\n            if(memory[i] == memoryId)\n            {\n                freedCount++;\n                memory[i]= 0;\n            }\n        }\n        return freedCount;\n    }\n};### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nclass Allocator\n{\n    std::vector<int> memory;\n\n  public:\n    Allocator(int size) : memory(size, 0) {}\n\n    int Allocate(int block_size, int memory_id)\n    {\n        int startIndex= -1, freeCount= 0;\n        for(int i= 0; i <= memory.size(); ++i)\n        {\n            if(i < memory.size() && memory[i] == 0)\n            {\n                if(startIndex == -1)\n                    startIndex= i;\n                freeCount++;\n            }\n            else\n            {\n                if(freeCount >= block_size)\n                {\n                    std::fill(memory.begin() + startIndex, memory.begin() + startIndex + block_size, memory_id);\n                    return startIndex;\n                }\n                startIndex= -1;\n                freeCount= 0;\n            }\n        }\n        return -1;\n    }\n\n    int Free(int memory_id)\n    {\n        int freedCount= 0;\n        for(int i= 0; i < memory.size(); ++i)\n        {\n            if(memory[i] == memory_id)\n            {\n                freedCount++;\n                memory[i]= 0;\n            }\n        }\n        return freedCount;\n    }\n};"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> traverseMatrix(vector<vector<int>> &grid, const vector<int> &queries, int rows, int columns)\n{\n    vector<int> directionX= {-1, 0, 1, 0};\n    vector<int> directionY= {0, 1, 0, -1};\n    vector<int> result(queries.size(), 0);\n\n    for(int queryIndex= 0; queryIndex < queries.size(); ++queryIndex)\n    {\n        int queryValue= queries[queryIndex];\n        int pointsCount= 0;\n        set<pair<int, int>> visitedCells;\n\n        function<void(int, int)> depthFirstSearch= [&](int currentX, int currentY)\n        {\n            if(visitedCells.find({currentX, currentY}) == visitedCells.end() && grid[currentX][currentY] < queryValue)\n            {\n                visitedCells.insert({currentX, currentY});\n                pointsCount++;\n                for(int directionIndex= 0; directionIndex < 4; ++directionIndex)\n                {\n                    int nextX= currentX + directionX[directionIndex], nextY= currentY + directionY[directionIndex];\n                    if(nextX >= 0 && nextX < rows && nextY >= 0 && nextY < columns)\n                    {\n                        depthFirstSearch(nextX, nextY);\n                    }\n                }\n            }\n        };\n\n        depthFirstSearch(0, 0);\n        result[queryIndex]= pointsCount;\n    }\n\n    return result;\n}\n\nvector<int> maxPoints(vector<vector<int>> &grid, vector<int> &queries)\n{\n    int rows= grid.size();\n    int columns= grid[0].size();\n    return traverseMatrix(grid, queries, rows, columns);\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> TraverseMatrix(std::vector<std::vector<int>> &grid, const std::vector<int> &queries, int rows, int columns)\n{\n    std::vector<int> directionX= {-1, 0, 1, 0};\n    std::vector<int> directionY= {0, 1, 0, -1};\n    std::vector<int> result(queries.size(), 0);\n\n    for(int queryIndex= 0; queryIndex < queries.size(); ++queryIndex)\n    {\n        int queryValue= queries[queryIndex];\n        int pointsCount= 0;\n        std::set<std::pair<int, int>> visitedCells;\n\n        std::function<void(int, int)> depthFirstSearch= [&](int current_x, int current_y)\n        {\n            if(visitedCells.find({current_x, current_y}) == visitedCells.end() && grid[current_x][current_y] < queryValue)\n            {\n                visitedCells.insert({current_x, current_y});\n                pointsCount++;\n                for(int directionIndex= 0; directionIndex < 4; ++directionIndex)\n                {\n                    int nextX= current_x + directionX[directionIndex], nextY= current_y + directionY[directionIndex];\n                    if(nextX >= 0 && nextX < rows && nextY >= 0 && nextY < columns)\n                    {\n                        depthFirstSearch(nextX, nextY);\n                    }\n                }\n            }\n        };\n\n        depthFirstSearch(0, 0);\n        result[queryIndex]= pointsCount;\n    }\n\n    return result;\n}\n\nstd::vector<int> MaxPoints(std::vector<std::vector<int>> &grid, std::vector<int> &queries)\n{\n    int rows= grid.size();\n    int columns= grid[0].size();\n    return TraverseMatrix(grid, queries, rows, columns);\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint subsequenceOrSum(vector<int> &numbers)\n{\n    int orResult = 0;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int currentNumber = numbers[i];\n        orResult |= currentNumber;\n    }\n    return orResult;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint SubsequenceOrSum(std::vector<int> &numbers)\n{\n    int orResult= 0;\n    for(int currentNumber : numbers)\n    {\n        orResult |= currentNumber;\n    }\n    return orResult;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countSimilarPairs(vector<string> &wordList)\n{\n    int similarPairCount = 0;\n    for(int firstIndex = 0; firstIndex < wordList.size(); ++firstIndex)\n    {\n        for(int secondIndex = firstIndex + 1; secondIndex < wordList.size(); ++secondIndex)\n        {\n            unordered_set<char> firstWordSet{wordList[firstIndex].begin(), wordList[firstIndex].end()};\n            unordered_set<char> secondWordSet{wordList[secondIndex].begin(), wordList[secondIndex].end()};\n            if(firstWordSet == secondWordSet)\n                similarPairCount++;\n        }\n    }\n    return similarPairCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint CountSimilarPairs(std::vector<std::string> &word_list)\n{\n    int similarPairCount= 0;\n    for(int firstIndex= 0; firstIndex < word_list.size(); ++firstIndex)\n    {\n        for(int secondIndex= firstIndex + 1; secondIndex < word_list.size(); ++secondIndex)\n        {\n            std::unordered_set<char> firstWordSet{word_list[firstIndex].begin(), word_list[firstIndex].end()};\n            std::unordered_set<char> secondWordSet{word_list[secondIndex].begin(), word_list[secondIndex].end()};\n            if(firstWordSet == secondWordSet)\n                similarPairCount++;\n        }\n    }\n    return similarPairCount;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint smallestFactorization(int number)\n{\n    if(number <= 3)\n        return number;\n    int factorizationResult= 0, factorMultiplier= 1;\n    for(int currentFactor= 2; currentFactor <= 5; ++currentFactor)\n    {\n        while(number % currentFactor == 0)\n        {\n            factorizationResult+= factorMultiplier * currentFactor;\n            factorMultiplier*= 10;\n            number/= currentFactor;\n        }\n    }\n    return number == 1 ? factorizationResult : number;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int SmallestFactorization(int number)\n{\n    if(number <= 3)\n        return number;\n    int factorizationResult= 0, factorMultiplier= 1;\n    for(int currentFactor= 2; currentFactor <= 5; ++currentFactor)\n    {\n        while(number % currentFactor == 0)\n        {\n            factorizationResult+= factorMultiplier * currentFactor;\n            factorMultiplier*= 10;\n            number/= currentFactor;\n        }\n    }\n    return number == 1 ? factorizationResult : number;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPossibleDegreeEven(int numberOfVertices, vector<vector<int>> &edges)\n{\n    vector<int> vertexDegrees(numberOfVertices + 1, 0);\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        vertexDegrees[edges[i][0]]++;\n        vertexDegrees[edges[i][1]]++;\n    }\n\n    int oddDegreeCount = 0;\n    for (int index = 1; index <= numberOfVertices; index++)\n    {\n        if (vertexDegrees[index] % 2 != 0)\n            oddDegreeCount++;\n    }\n\n    return (oddDegreeCount == 0 || oddDegreeCount == 2);\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nbool IsPossibleDegreeEven(int number_of_vertices, std::vector<std::vector<int>> &edges)\n{\n    std::vector<int> vertexDegrees(number_of_vertices + 1, 0);\n    for(const auto &edge : edges)\n    {\n        vertexDegrees[edge[0]]++;\n        vertexDegrees[edge[1]]++;\n    }\n\n    int oddDegreeCount= 0;\n    for(int index= 1; index <= number_of_vertices; index++)\n    {\n        if(vertexDegrees[index] % 2 != 0)\n            oddDegreeCount++;\n    }\n\n    return (oddDegreeCount == 0 || oddDegreeCount == 2);\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> lengthOfCycle(int numberOfNodes, const vector<vector<int>> &queries)\n{\n    vector<int> cycleLengths;\n    for (int i = 0; i < queries.size(); ++i)\n    {\n        const auto &query = queries[i];\n        int depthA = 0, depthB = 0, nodeA = query[0], nodeB = query[1];\n        while (nodeA != nodeB)\n        {\n            if (nodeA < nodeB)\n                swap(nodeA, nodeB);\n            nodeA >>= 1;\n            depthA++;\n        }\n        cycleLengths.push_back(depthA + depthB);\n    }\n    return cycleLengths;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> LengthOfCycle(int number_of_nodes, const std::vector<std::vector<int>> &queries)\n{\n    std::vector<int> cycleLengths;\n    for(const auto &query : queries)\n    {\n        int depth_a= 0, depth_b= 0, node_a= query[0], node_b= query[1];\n        while(node_a != node_b)\n        {\n            if(node_a < node_b)\n                std::swap(node_a, node_b);\n            node_a>>= 1;\n            depth_a++;\n        }\n        cycleLengths.push_back(depth_a + depth_b);\n    }\n    return cycleLengths;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isValidPath(vector<vector<int>> &grid, int currentRow, int currentCol, int zeroCount, int oneCount)\n{\n    if(currentRow < 0 || currentCol < 0 || currentRow >= grid.size() || currentCol >= grid[0].size())\n    {\n        return false;\n    }\n    if(grid[currentRow][currentCol] == 1)\n    {\n        oneCount++;\n    }\n    else\n    {\n        zeroCount++;\n    }\n    if(currentRow == grid.size() - 1 && currentCol == grid[0].size() - 1)\n    {\n        return zeroCount == oneCount;\n    }\n    return isValidPath(grid, currentRow + 1, currentCol, zeroCount, oneCount) || isValidPath(grid, currentRow, currentCol + 1, zeroCount, oneCount);\n}\n\nbool equalPath(vector<vector<int>> &grid)\n{\n    return isValidPath(grid, 0, 0, 0, 0);\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nbool IsValidPath(std::vector<std::vector<int>> &grid, int current_row, int current_col, int zero_count, int one_count)\n{\n    if(current_row < 0 || current_col < 0 || current_row >= grid.size() || current_col >= grid[0].size())\n    {\n        return false;\n    }\n    if(grid[current_row][current_col] == 1)\n    {\n        one_count++;\n    }\n    else\n    {\n        zero_count++;\n    }\n    if(current_row == grid.size() - 1 && current_col == grid[0].size() - 1)\n    {\n        return zero_count == one_count;\n    }\n    return IsValidPath(grid, current_row + 1, current_col, zero_count, one_count) || IsValidPath(grid, current_row, current_col + 1, zero_count, one_count);\n}\n\nbool EqualPath(std::vector<std::vector<int>> &grid)\n{\n    return IsValidPath(grid, 0, 0, 0, 0);\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxCapturedForts(vector<int> &forts)\n{\n    int totalForts= forts.size();\n    int maxCapture= 0;\n    for(int currentFort= 0; currentFort < totalForts; currentFort++)\n    {\n        if(forts[currentFort] == 1)\n        {\n            for(int nextFort= currentFort + 1; nextFort < totalForts; nextFort++)\n            {\n                if(forts[nextFort] != -1)\n                {\n                    int captureCount= 0;\n                    for(int intermediateFort= currentFort + 1; intermediateFort < nextFort; intermediateFort++)\n                    {\n                        if(forts[intermediateFort] == 0)\n                            captureCount++;\n                    }\n                    if(forts[nextFort] == 1)\n                        maxCapture= max(maxCapture, captureCount);\n                }\n            }\n        }\n    }\n    return maxCapture;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint MaxCapturedForts(std::vector<int> &forts)\n{\n    int totalForts = forts.size();\n    int maxCapture = 0;\n    for(int currentFort = 0; currentFort < totalForts; currentFort++)\n    {\n        if(forts[currentFort] == 1)\n        {\n            for(int nextFort = currentFort + 1; nextFort < totalForts; nextFort++)\n            {\n                if(forts[nextFort] != -1)\n                {\n                    int captureCount = 0;\n                    for(int intermediateFort = currentFort + 1; intermediateFort < nextFort; intermediateFort++)\n                    {\n                        if(forts[intermediateFort] == 0)\n                            captureCount++;\n                    }\n                    if(forts[nextFort] == 1)\n                        maxCapture = std::max(maxCapture, captureCount);\n                }\n            }\n        }\n    }\n    return maxCapture;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> topKStudents(const vector<string> &positiveFeedback,\n                          const vector<string> &negativeFeedback,\n                          const vector<string> &reports,\n                          const vector<int> &studentIds,\n                          int k)\n{\n    unordered_map<int, int> studentPoints;\n    for(size_t i = 0; i < reports.size(); ++i)\n    {\n        int positiveCount = 0, negativeCount = 0;\n        for(size_t j = 0; j < positiveFeedback.size(); ++j)\n        {\n            const auto &positive = positiveFeedback[j];\n            size_t positiveIndex = reports[i].find(positive);\n            while(positiveIndex != string::npos)\n            {\n                ++positiveCount;\n                positiveIndex = reports[i].find(positive, positiveIndex + positive.length());\n            }\n        }\n        for(size_t j = 0; j < negativeFeedback.size(); ++j)\n        {\n            const auto &negative = negativeFeedback[j];\n            size_t negativeIndex = reports[i].find(negative);\n            while(negativeIndex != string::npos)\n            {\n                ++negativeCount;\n                negativeIndex = reports[i].find(negative, negativeIndex + negative.length());\n            }\n        }\n        studentPoints[studentIds[i]] += 3 * positiveCount - negativeCount;\n    }\n\n    vector<int> students(studentIds.begin(), studentIds.end());\n    sort(students.begin(), students.end(), [&studentPoints](int a, int b)\n         { return studentPoints[a] != studentPoints[b] ? studentPoints[a] > studentPoints[b] : a < b; });\n\n    return vector<int>(students.begin(), students.begin() + k);\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> TopKStudents(const std::vector<std::string> &positive_feedback,\n                              const std::vector<std::string> &negative_feedback,\n                              const std::vector<std::string> &reports,\n                              const std::vector<int> &student_ids,\n                              int k)\n{\n    std::unordered_map<int, int> studentPoints;\n    for(size_t i= 0; i < reports.size(); ++i)\n    {\n        int positiveCount= 0, negativeCount= 0;\n        for(const auto &positive : positive_feedback)\n        {\n            size_t positiveIndex= reports[i].find(positive);\n            while(positiveIndex != std::string::npos)\n            {\n                ++positiveCount;\n                positiveIndex= reports[i].find(positive, positiveIndex + positive.length());\n            }\n        }\n        for(const auto &negative : negative_feedback)\n        {\n            size_t negativeIndex= reports[i].find(negative);\n            while(negativeIndex != std::string::npos)\n            {\n                ++negativeCount;\n                negativeIndex= reports[i].find(negative, negativeIndex + negative.length());\n            }\n        }\n        studentPoints[student_ids[i]]+= 3 * positiveCount - negativeCount;\n    }\n\n    std::vector<int> students(student_ids.begin(), student_ids.end());\n    std::sort(students.begin(), students.end(), [&studentPoints](int a, int b)\n              { return studentPoints[a] != studentPoints[b] ? studentPoints[a] > studentPoints[b] : a < b; });\n\n    return std::vector<int>(students.begin(), students.begin() + k);\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint calculateMinimumPossibleMax(int divisor1, int divisor2, int uniqueCount1, int uniqueCount2)\n{\n    return (divisor1 - 1) * uniqueCount1 + (divisor2 - 1) * uniqueCount2 + 1;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int CalculateMinimumPossibleMax(int divisor_1, int divisor_2, int unique_count_1, int unique_count_2)\n{\n    return (divisor_1 - 1) * unique_count_1 + (divisor_2 - 1) * unique_count_2 + 1;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\n// For std::min\nusing namespace std;\n\nint shortestDistance(vector<string> &words, string target, int startIndex)\n{\n    int totalWords = words.size();\n    int leftDistance = 0, rightDistance = 0, currentIndex = startIndex;\n    while(true)\n    {\n        if(words[currentIndex] == target)\n        {\n            return min(leftDistance, rightDistance);\n        }\n        leftDistance++;\n        rightDistance++;\n        currentIndex = (currentIndex + 1) % totalWords;\n        if(leftDistance == totalWords)\n        {\n            break;\n        }\n    }\n    return -1;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\n// For std::min\n\nint ShortestDistance(std::vector<std::string> &words, std::string target, int start_index)\n{\n    int totalWords= words.size();\n    int leftDistance= 0, rightDistance= 0, currentIndex= start_index;\n    while(true)\n    {\n        if(words[currentIndex] == target)\n        {\n            return std::min(leftDistance, rightDistance);\n        }\n        leftDistance++;\n        rightDistance++;\n        currentIndex= (currentIndex + 1) % totalWords;\n        if(leftDistance == totalWords)\n        {\n            break;\n        }\n    }\n    return -1;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minMinutes(string inputString, int requiredCount)\n{\n    int stringLength = inputString.length();\n    vector<int> leftCharacterCounts(3, 0), rightCharacterCounts(3, 0);\n    for (int i = 0; i < stringLength; ++i)\n        rightCharacterCounts[inputString[i] - 'a']++;\n\n    int minimumMinutes = stringLength, totalCount = 0;\n    while (true)\n    {\n        int leftIndex = 0, rightIndex = stringLength - 1;\n        while (leftIndex < rightIndex && leftCharacterCounts[inputString[leftIndex] - 'a'] < requiredCount && rightCharacterCounts[inputString[rightIndex] - 'a'] < requiredCount)\n        {\n            int neededLeft = max(0, requiredCount - leftCharacterCounts[inputString[leftIndex] - 'a']);\n            int neededRight = max(0, requiredCount - rightCharacterCounts[inputString[rightIndex] - 'a']);\n            if (neededLeft <= neededRight)\n            {\n                totalCount += neededLeft;\n                leftCharacterCounts[inputString[leftIndex] - 'a'] += neededLeft; // Fixed increment\n                rightCharacterCounts[inputString[leftIndex] - 'a'] -= neededLeft; // Fixed decrement\n                leftIndex++;\n            }\n            else\n            {\n                totalCount += neededRight;\n                rightCharacterCounts[inputString[rightIndex] - 'a'] -= neededRight; // Fixed decrement\n                leftCharacterCounts[inputString[rightIndex] - 'a'] += neededRight; // Fixed increment\n                rightIndex--;\n            }\n        }\n        minimumMinutes = min(minimumMinutes, totalCount);\n        if (leftIndex + 1 < inputString.length())\n        {\n            totalCount -= leftCharacterCounts[inputString[leftIndex] - 'a'];\n            leftCharacterCounts[inputString[leftIndex] - 'a']--;\n            rightCharacterCounts[inputString[leftIndex + 1] - 'a']++;\n            leftIndex++;\n        }\n        else\n            break;\n    }\n    if (leftCharacterCounts[0] >= requiredCount && leftCharacterCounts[1] >= requiredCount && leftCharacterCounts[2] >= requiredCount)\n        return minimumMinutes;\n    return -1;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint MinMinutes(std::string input_string, int required_count)\n{\n    int stringLength= input_string.length();\n    std::vector<int> leftCharacterCounts(3, 0), rightCharacterCounts(3, 0);\n    for(char character : input_string)\n        rightCharacterCounts[character - 'a']++;\n\n    int minimumMinutes= stringLength, totalCount= 0;\n    while(true)\n    {\n        int leftIndex= 0, rightIndex= stringLength - 1;\n        while(leftIndex < rightIndex && leftCharacterCounts[input_string[leftIndex] - 'a'] < required_count && rightCharacterCounts[input_string[rightIndex] - 'a'] < required_count)\n        {\n            int neededLeft= std::max(0, required_count - leftCharacterCounts[input_string[leftIndex] - 'a']);\n            int neededRight= std::max(0, required_count - rightCharacterCounts[input_string[rightIndex] - 'a']);\n            if(neededLeft <= neededRight)\n            {\n                totalCount+= neededLeft;\n                leftIndex++;\n                leftCharacterCounts[input_string[leftIndex] - 'a']++;\n                rightCharacterCounts[input_string[leftIndex] - 'a']--;\n            }\n            else\n            {\n                totalCount+= neededRight;\n                rightIndex--;\n                rightCharacterCounts[input_string[rightIndex] - 'a']--;\n                leftCharacterCounts[input_string[rightIndex] - 'a']++;\n            }\n        }\n        minimumMinutes= std::min(minimumMinutes, totalCount);\n        if(leftIndex + 1 < input_string.length())\n        {\n            totalCount-= leftCharacterCounts[input_string[leftIndex] - 'a'];\n            leftCharacterCounts[input_string[leftIndex] - 'a']--;\n            rightCharacterCounts[input_string[leftIndex + 1] - 'a']++;\n            leftIndex++;\n        }\n        else\n            break;\n    }\n    if(leftCharacterCounts[0] >= required_count && leftCharacterCounts[1] >= required_count && leftCharacterCounts[2] >= required_count)\n        return minimumMinutes;\n    return -1;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMaxTastiness(vector<int> &prices, int numberOfItems)\n{\n    sort(prices.begin(), prices.end());\n    int maxTastiness= 0;\n    for(int i= 0; i < prices.size() - numberOfItems + 1; i++)\n    {\n        int minDifference= INT_MAX;\n        for(int j= i; j < i + numberOfItems - 1; j++)\n        {\n            minDifference= min(minDifference, prices[j + 1] - prices[j]);\n        }\n        maxTastiness= max(maxTastiness, minDifference);\n    }\n\n    return maxTastiness;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint CalculateMaxTastiness(std::vector<int> &prices, int number_of_items)\n{\n    std::sort(prices.begin(), prices.end());\n    int maxTastiness= 0;\n    for(int i= 0; i < prices.size() - number_of_items + 1; i++)\n    {\n        int minDifference= std::numeric_limits<int>::max();\n        for(int j= i; j < i + number_of_items - 1; j++)\n        {\n            minDifference= std::min(minDifference, prices[j + 1] - prices[j]);\n        }\n        maxTastiness= std::max(maxTastiness, minDifference);\n    }\n\n    return maxTastiness;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPartitions(vector<int> &numbers, int target)\n{\n    long long totalSum = 0;\n    int size = numbers.size();\n    int modulus = 1000000007;\n\n    for (int i = 0; i < size; ++i)\n    {\n        totalSum += numbers[i];\n    }\n\n    if (totalSum < target * 2)\n    {\n        return 0;\n    }\n\n    vector<long long> dynamicProgramming(size + 1, 1);\n\n    for (int i = 1; i <= target - 1; i++)\n    {\n        for (int j = size - 1; j >= 1; j--)\n        {\n            dynamicProgramming[j] = (dynamicProgramming[j] * j + dynamicProgramming[j - 1]) % modulus;\n        }\n    }\n\n    long long result = 0;\n\n    for (int i = 0; i < size - 1; i++)\n    {\n        totalSum -= numbers[i];\n        if (totalSum >= target)\n        {\n            result = (result + dynamicProgramming[i + 1]) % modulus;\n        }\n    }\n\n    return (int)result;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint CountPartitions(std::vector<int> &numbers, int target)\n{\n    long long totalSum= 0;\n    int size= numbers.size();\n    int modulus= 1000000007;\n\n    for(int number : numbers)\n    {\n        totalSum+= number;\n    }\n\n    if(totalSum < target * 2)\n    {\n        return 0;\n    }\n\n    std::vector<long long> dynamicProgramming(size + 1, 1);\n\n    for(int i= 1; i <= target - 1; i++)\n    {\n        for(int j= size - 1; j >= 1; j--)\n        {\n            dynamicProgramming[j]= (dynamicProgramming[j] * j + dynamicProgramming[j - 1]) % modulus;\n        }\n    }\n\n    long long result= 0;\n\n    for(int i= 0; i < size - 1; i++)\n    {\n        totalSum-= numbers[i];\n        if(totalSum >= target)\n        {\n            result= (result + dynamicProgramming[i + 1]) % modulus;\n        }\n    }\n\n    return (int)result;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countKBigIndices(vector<int> &numbers, int threshold)\n{\n    int size= numbers.size();\n    vector<int> leftIndices(size, 0), rightIndices(size, 0);\n\n    for(int index= 1; index < size; ++index)\n    {\n        if(numbers[index] > numbers[index - 1])\n            leftIndices[index]= leftIndices[index - 1] + 1;\n\n        int reverseIndex= size - index - 1;\n        if(reverseIndex + 1 < size && numbers[reverseIndex] < numbers[reverseIndex + 1]) // Ensure we don't go out of bounds\n            rightIndices[reverseIndex]= rightIndices[reverseIndex + 1] + 1;\n    }\n\n    int totalCount= 0;\n    for(int index= 0; index < size; ++index)\n        if(leftIndices[index] >= threshold && rightIndices[index] >= threshold)\n            totalCount++;\n\n    return totalCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint CountKBigIndices(std::vector<int> &numbers, int threshold)\n{\n    int size= numbers.size();\n    std::vector<int> leftIndices(size, 0), rightIndices(size, 0);\n\n    for(int index= 1; index < size; ++index)\n    {\n        if(numbers[index] > numbers[index - 1])\n            leftIndices[index]= leftIndices[index - 1] + 1;\n\n        int reverseIndex= size - index - 1;\n        if(reverseIndex + 1 < size && numbers[reverseIndex] < numbers[reverseIndex + 1]) // Ensure we don't go out of bounds\n            rightIndices[reverseIndex]= rightIndices[reverseIndex + 1] + 1;\n    }\n\n    int totalCount= 0;\n    for(int index= 0; index < size; ++index)\n        if(leftIndices[index] >= threshold && rightIndices[index] >= threshold)\n            totalCount++;\n\n    return totalCount;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint countDigitsDividingNumber(int inputNumber)\n{\n    int divisorCount= 0, tempNumber= inputNumber;\n    while(tempNumber > 0)\n    {\n        int currentDigit= tempNumber % 10;\n        if(inputNumber % currentDigit == 0)\n        {\n            divisorCount++;\n        }\n        tempNumber/= 10;\n    }\n    return divisorCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int CountDigitsDividingNumber(int input_number)\n{\n    int divisorCount= 0, tempNumber= input_number;\n    while(tempNumber > 0)\n    {\n        int currentDigit= tempNumber % 10;\n        if(input_number % currentDigit == 0)\n        {\n            divisorCount++;\n        }\n        tempNumber/= 10;\n    }\n    return divisorCount;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countDistinctPrimeFactors(const vector<int> &numbers)\n{\n    set<int> distinctPrimeFactors;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int number = numbers[i];\n        for (int divisor = 2; divisor * divisor <= number; ++divisor)\n        {\n            if (number % divisor == 0)\n            {\n                distinctPrimeFactors.insert(divisor);\n                distinctPrimeFactors.insert(number / divisor);\n            }\n        }\n    }\n    return distinctPrimeFactors.size();\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint CountDistinctPrimeFactors(const std::vector<int> &numbers)\n{\n    std::set<int> distinctPrimeFactors;\n    for(const int number : numbers)\n    {\n        for(int divisor= 2; divisor * divisor <= number; ++divisor)\n        {\n            if(number % divisor == 0)\n            {\n                distinctPrimeFactors.insert(divisor);\n                distinctPrimeFactors.insert(number / divisor);\n            }\n        }\n    }\n    return distinctPrimeFactors.size();\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minPartitions(string numberString, int maxValue)\n{\n    int stringLength= numberString.size();\n    int partitionCount= 0, currentIndex= 0;\n\n    while(currentIndex < stringLength)\n    {\n        int currentValue= 0;\n        // Make sure the currentValue is below maxValue\n        while(currentIndex < stringLength && currentValue * 10 + (numberString[currentIndex] - '0') <= maxValue)\n        {\n            currentValue= currentValue * 10 + (numberString[currentIndex] - '0');\n            currentIndex++;\n        }\n\n        if(currentValue == 0)\n            return -1;\n        partitionCount++;\n    }\n\n    return partitionCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint MinPartitions(std::string number_string, int max_value)\n{\n    int stringLength= number_string.size();\n    int partitionCount= 0, currentIndex= 0;\n\n    while(currentIndex < stringLength)\n    {\n        int currentValue= 0;\n        // Make sure the currentValue is below max_value\n        while(currentIndex < stringLength && currentValue * 10 + (number_string[currentIndex] - '0') <= max_value)\n        {\n            currentValue= currentValue * 10 + (number_string[currentIndex] - '0');\n            currentIndex++;\n        }\n\n        if(currentValue == 0)\n            return -1;\n        partitionCount++;\n    }\n\n    return partitionCount;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPrime(int number)\n{\n    if(number <= 1)\n        return false;\n    for(int divisor= 2; divisor * divisor <= number; ++divisor)\n    {\n        if(number % divisor == 0)\n            return false;\n    }\n    return true;\n}\n\nvector<int> closestPrimePair(int rangeStart, int rangeEnd)\n{\n    int minimumDistance= rangeEnd - rangeStart + 1;\n    vector<int> result= {-1, -1};\n    for(int currentNumber= rangeStart; currentNumber <= rangeEnd; ++currentNumber)\n    {\n        if(isPrime(currentNumber))\n        {\n            for(int nextNumber= currentNumber + 1; nextNumber <= rangeEnd; ++nextNumber)\n            {\n                if(isPrime(nextNumber) && nextNumber - currentNumber < minimumDistance)\n                {\n                    minimumDistance= nextNumber - currentNumber;\n                    result= {currentNumber, nextNumber};\n                }\n            }\n        }\n    }\n    return result;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nbool IsPrime(int number)\n{\n    if(number <= 1)\n        return false;\n    for(int divisor= 2; divisor * divisor <= number; ++divisor)\n    {\n        if(number % divisor == 0)\n            return false;\n    }\n    return true;\n}\n\nstd::vector<int> ClosestPrimePair(int range_start, int range_end)\n{\n    int minimumDistance= range_end - range_start + 1;\n    std::vector<int> result= {-1, -1};\n    for(int currentNumber= range_start; currentNumber <= range_end; ++currentNumber)\n    {\n        if(IsPrime(currentNumber))\n        {\n            for(int nextNumber= currentNumber + 1; nextNumber <= range_end; ++nextNumber)\n            {\n                if(IsPrime(nextNumber) && nextNumber - currentNumber < minimumDistance)\n                {\n                    minimumDistance= nextNumber - currentNumber;\n                    result= {currentNumber, nextNumber};\n                }\n            }\n        }\n    }\n    return result;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxFrequencyScore(vector<int> &numbers, int k)\n{\n    int size= numbers.size();\n    int rightIndex= 0, currentCount= 0, maxScore= 0;\n    long long currentScore= 0;\n    unordered_map<int, int> frequencyMap;\n\n    for(int leftIndex= 0; leftIndex < size; ++leftIndex)\n    {\n        while(rightIndex < size && currentCount < k)\n        {\n            currentScore= (currentScore + (long long)numbers[rightIndex] * frequencyMap[numbers[rightIndex]]) % 1000000007;\n            frequencyMap[numbers[rightIndex]]++;\n            currentCount++;\n            rightIndex++;\n        }\n\n        maxScore= max(maxScore, (int)currentScore);\n\n        if(currentCount == k)\n        {\n            currentScore-= numbers[leftIndex] * (frequencyMap[numbers[leftIndex]] - 1);\n            frequencyMap[numbers[leftIndex]]--;\n            currentCount--;\n        }\n    }\n\n    return maxScore;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint MaxFrequencyScore(std::vector<int> &numbers, int k)\n{\n    int size= numbers.size();\n    int right_index= 0, current_count= 0, max_score= 0;\n    long long current_score= 0;\n    std::unordered_map<int, int> frequencyMap;\n\n    for(int leftIndex= 0; leftIndex < size; ++leftIndex)\n    {\n        while(right_index < size && current_count < k)\n        {\n            current_score= (current_score + (long long)numbers[right_index] * frequencyMap[numbers[right_index]]) % 1000000007;\n            frequencyMap[numbers[right_index]]++;\n            current_count++;\n            right_index++;\n        }\n\n        max_score= std::max(max_score, (int)current_score);\n\n        if(current_count == k)\n        {\n            current_score-= numbers[leftIndex] * (frequencyMap[numbers[leftIndex]] - 1);\n            frequencyMap[numbers[leftIndex]]--;\n            current_count--;\n        }\n    }\n\n    return max_score;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring getBoxCategory(int boxLength, int boxWidth, int boxHeight, int boxMass)\n{\n    bool isBulky= boxLength >= 10000 || boxWidth >= 10000 || boxHeight >= 10000 || (long)boxLength * boxWidth * boxHeight >= 1000000000;\n    bool isHeavy= boxMass >= 100;\n\n    if(isBulky && isHeavy)\n        return \"Both \";\n    if(isBulky)\n        return \"Bulky \";\n    if(isHeavy)\n        return \"Heavy \";\n    return \"Neither \";\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nstd::string GetBoxCategory(int box_length, int box_width, int box_height, int box_mass)\n{\n    bool isBulky= box_length >= 10000 || box_width >= 10000 || box_height >= 10000 || (long)box_length * box_width * box_height >= 1000000000;\n    bool isHeavy= box_mass >= 100;\n\n    if(isBulky && isHeavy)\n        return \"Both \";\n    if(isBulky)\n        return \"Bulky \";\n    if(isHeavy)\n        return \"Heavy \";\n    return \"Neither \";\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nclass DataStream\n{\n  public:\n    DataStream(int targetValue, int sequenceLength) : targetValue(targetValue), sequenceLength(sequenceLength) {}\n\n    bool consec(int num)\n    {\n        dataStream.push_back(num);\n        if(dataStream.size() > sequenceLength)\n            dataStream.pop_front();\n\n        return dataStream.size() == sequenceLength && count(dataStream.begin(), dataStream.end(), targetValue) == sequenceLength;\n    }\n\n  private:\n    int targetValue;\n    int sequenceLength;\n    deque<int> dataStream;\n};### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nclass DataStream\n{\n  public:\n    DataStream(int target_value, int sequence_length) : targetValue(target_value), sequenceLength(sequence_length) {}\n\n    bool Consec(int num)\n    {\n        dataStream.push_back(num);\n        if(dataStream.size() > sequenceLength)\n            dataStream.pop_front();\n\n        return dataStream.size() == sequenceLength && count(dataStream.begin(), dataStream.end(), targetValue) == sequenceLength;\n    }\n\n  private:\n    int targetValue;\n    int sequenceLength;\n    std::deque<int> dataStream;\n};"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateXorBeauty(vector<int> &inputNumbers)\n{\n    int numberOfElements = inputNumbers.size();\n    int maximumXorValue = 1024; // Maximum value for bitwise operations\n    vector<int> frequencyCounter(maximumXorValue, 0);\n\n    for (int i = 0; i < numberOfElements; ++i)\n    {\n        frequencyCounter[inputNumbers[i] % maximumXorValue]++;\n    }\n\n    int xorBeautyResult = 0;\n    for (int i = 0; i < maximumXorValue; i++)\n    {\n        for (int j = i; j < maximumXorValue; j++)\n        {\n            int commonBits = (i | j) & (~(i ^ j));\n            if (commonBits < maximumXorValue && commonBits >= j)\n            {\n                int countCombinations = frequencyCounter[i] * frequencyCounter[j] * (i == j ? 1 : 2);\n                if (commonBits != i && commonBits != j)\n                {\n                    countCombinations *= frequencyCounter[commonBits];\n                }\n                xorBeautyResult ^= countCombinations;\n            }\n        }\n    }\n\n    return xorBeautyResult;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint CalculateXorBeauty(std::vector<int> &input_numbers)\n{\n    int numberOfElements= input_numbers.size();\n    int maximumXorValue= 1024; // Maximum value for bitwise operations\n    std::vector<int> frequencyCounter(maximumXorValue, 0);\n\n    for(int currentNumber : input_numbers)\n    {\n        frequencyCounter[currentNumber % maximumXorValue]++;\n    }\n\n    int xorBeautyResult= 0;\n    for(int i= 0; i < maximumXorValue; i++)\n    {\n        for(int j= i; j < maximumXorValue; j++)\n        {\n            int commonBits= (i | j) & (~(i ^ j));\n            if(commonBits < maximumXorValue && commonBits >= j)\n            {\n                int countCombinations= frequencyCounter[i] * frequencyCounter[j] * (i == j ? 1 : 2);\n                if(commonBits != i && commonBits != j)\n                {\n                    countCombinations*= frequencyCounter[commonBits];\n                }\n                xorBeautyResult^= countCombinations;\n            }\n        }\n    }\n\n    return xorBeautyResult;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMaxMinPower(vector<int> &stationPowers, int range, int additionalPower)\n{\n    int numberOfStations = stationPowers.size();\n    vector<int> totalPower(numberOfStations);\n    for(int currentStation = 0; currentStation < numberOfStations; currentStation++)\n    {\n        for(int nearbyStation = max(0, currentStation - range); nearbyStation <= min(numberOfStations - 1, currentStation + range); nearbyStation++)\n        {\n            totalPower[nearbyStation] += stationPowers[currentStation];\n        }\n    }\n\n    int sumOfK = 0, minimumPower = INT_MAX;\n    for(int currentIndex = range; currentIndex < numberOfStations - range; currentIndex++)\n    {\n        sumOfK += stationPowers[currentIndex];\n        minimumPower = min(minimumPower, totalPower[currentIndex]);\n    }\n\n    for(int j = 0, i = numberOfStations - 2 * range; j < 2 * range; j++, i--)\n    {\n        sumOfK -= stationPowers[i + range + 1];\n        minimumPower -= stationPowers[j];\n        minimumPower += sumOfK;\n        minimumPower += additionalPower;\n        minimumPower = min(minimumPower, totalPower[j]);\n    }\n\n    return minimumPower;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint CalculateMaxMinPower(std::vector<int> &station_powers, int range, int additional_power)\n{\n    int numberOfStations = station_powers.size();\n    std::vector<int> totalPower(numberOfStations);\n    \n    for(int currentStation = 0; currentStation < numberOfStations; currentStation++)\n    {\n        for(int nearbyStation = std::max(0, currentStation - range); nearbyStation <= std::min(numberOfStations - 1, currentStation + range); nearbyStation++)\n        {\n            totalPower[nearbyStation] += station_powers[currentStation];\n        }\n    }\n\n    int sumOfK = 0, minimumPower = std::numeric_limits<int>::max();\n    for(int currentIndex = range; currentIndex < numberOfStations - range; currentIndex++)\n    {\n        sumOfK += station_powers[currentIndex];\n        minimumPower = std::min(minimumPower, totalPower[currentIndex]);\n    }\n\n    for(int j = 0, i = numberOfStations - 2 * range; j < 2 * range; j++, i--)\n    {\n        sumOfK -= station_powers[i + range + 1];\n        minimumPower -= station_powers[j];\n        minimumPower += sumOfK;\n        minimumPower += additional_power;\n        minimumPower = std::min(minimumPower, totalPower[j]);\n    }\n\n    return minimumPower;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxPositiveNegativeCount(const vector<int> &numbers)\n{\n    int positiveCount= upper_bound(numbers.begin(), numbers.end(), -1) - numbers.begin();\n    int negativeCount= numbers.size() - positiveCount;\n    return max(positiveCount, negativeCount);\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint MaxPositiveNegativeCount(const std::vector<int> &numbers)\n{\n    int positiveCount= std::upper_bound(numbers.begin(), numbers.end(), -1) - numbers.begin();\n    int negativeCount= numbers.size() - positiveCount;\n    return std::max(positiveCount, negativeCount);\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxScore(const vector<int> &numbers, int numberOfPicks)\n{\n    priority_queue<int> maxHeap(numbers.begin(), numbers.end());\n    int totalScore= 0;\n\n    for(int i= 0; i < numberOfPicks; i++)\n    {\n        int currentNumber= maxHeap.top();\n        maxHeap.pop();\n        totalScore+= currentNumber;\n        maxHeap.push(currentNumber / 3);\n    }\n\n    return totalScore;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint MaxScore(const std::vector<int> &numbers, int number_of_picks)\n{\n    std::priority_queue<int> maxHeap(numbers.begin(), numbers.end());\n    int totalScore = 0;\n\n    for(int i = 0; i < number_of_picks; i++)\n    {\n        int currentNumber = maxHeap.top();\n        maxHeap.pop();\n        totalScore += currentNumber;\n        maxHeap.push(currentNumber / 3);\n    }\n\n    return totalScore;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool compare(const string &firstWord, const string &secondWord)\n{\n    array<int, 26> letterCountsFirst = {0}, letterCountsSecond = {0};\n    for (int i = 0; i < firstWord.size(); ++i)\n        letterCountsFirst[firstWord[i] - 'a']++;\n    for (int i = 0; i < secondWord.size(); ++i)\n        letterCountsSecond[secondWord[i] - 'a']++;\n    for (int index = 0; index < 26; ++index)\n    {\n        if (letterCountsFirst[index] && letterCountsSecond[index])\n            return true;\n    }\n    return false;\n}\n\nbool swapEqualDistinct(const string &firstWord, const string &secondWord)\n{\n    bool hasCommonLetter = compare(firstWord, secondWord);\n    return hasCommonLetter && firstWord.size() == secondWord.size();\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "bool Compare(const std::string &first_word, const std::string &second_word)\n{\n    std::array<int, 26> letterCountsFirst= {0}, letterCountsSecond= {0};\n    for(char character : first_word)\n        letterCountsFirst[character - 'a']++;\n    for(char character : second_word)\n        letterCountsSecond[character - 'a']++;\n    for(int index= 0; index < 26; ++index)\n    {\n        if(letterCountsFirst[index] && letterCountsSecond[index])\n            return true;\n    }\n    return false;\n}\n\nbool SwapEqualDistinct(const std::string &first_word, const std::string &second_word)\n{\n    bool hasCommonLetter= Compare(first_word, second_word);\n    return hasCommonLetter && first_word.size() == second_word.size();\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getLastMoment(int totalMoments, int numElements, vector<vector<int>> &elementTimes)\n{\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> leftQueue, rightQueue;\n    for(int index= 0; index < numElements; index++)\n    {\n        leftQueue.push({elementTimes[index][0] + elementTimes[index][2], index});\n    }\n\n    while(totalMoments)\n    {\n        while(!rightQueue.empty() && rightQueue.top().first <= leftQueue.top().first)\n        {\n            auto rightTopElement= rightQueue.top();\n            rightQueue.pop();\n            leftQueue.push({rightTopElement.first + elementTimes[rightTopElement.second][0] + elementTimes[rightTopElement.second][2], rightTopElement.second});\n        }\n        auto leftTopElement= leftQueue.top();\n        leftQueue.pop();\n        elementTimes[leftTopElement.second][2]+= elementTimes[leftTopElement.second][3] + elementTimes[leftTopElement.second][0] + elementTimes[leftTopElement.second][1];\n        rightQueue.push({leftTopElement.first + elementTimes[leftTopElement.second][1], leftTopElement.second});\n        totalMoments--;\n    }\n\n    int lastMoment= -1;\n    while(!rightQueue.empty())\n    {\n        lastMoment= max(lastMoment, elementTimes[rightQueue.top().second][2]);\n        rightQueue.pop();\n    }\n    return lastMoment;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint GetLastMoment(int total_moments, int num_elements, std::vector<std::vector<int>> &element_times)\n{\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> leftQueue, rightQueue;\n    for(int index= 0; index < num_elements; index++)\n    {\n        leftQueue.push({element_times[index][0] + element_times[index][2], index});\n    }\n\n    while(total_moments)\n    {\n        while(!rightQueue.empty() && rightQueue.top().first <= leftQueue.top().first)\n        {\n            auto rightTopElement= rightQueue.top();\n            rightQueue.pop();\n            leftQueue.push({rightTopElement.first + element_times[rightTopElement.second][0] + element_times[rightTopElement.second][2], rightTopElement.second});\n        }\n        auto leftTopElement= leftQueue.top();\n        leftQueue.pop();\n        element_times[leftTopElement.second][2]+= element_times[leftTopElement.second][3] + element_times[leftTopElement.second][0] + element_times[leftTopElement.second][1];\n        rightQueue.push({leftTopElement.first + element_times[leftTopElement.second][1], leftTopElement.second});\n        total_moments--;\n    }\n\n    int lastMoment= -1;\n    while(!rightQueue.empty())\n    {\n        lastMoment= std::max(lastMoment, element_times[rightQueue.top().second][2]);\n        rightQueue.pop();\n    }\n    return lastMoment;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\n// for std::max\nusing namespace std;\n\nint countGoodStrings(int minLength, int maxLength, int oneGroupSize, int zeroGroupSize, int modulo = 1000000007)\n{\n    int maxCount = maxLength / oneGroupSize + maxLength / zeroGroupSize;\n\n    vector<long long> dynamicProgramming(maxCount + 1);\n    dynamicProgramming[0] = 1;\n\n    for (int index = 1; index <= maxCount; index++)\n        dynamicProgramming[index] = (dynamicProgramming[index - 1] * (index % oneGroupSize == 0 || index % zeroGroupSize == 0)) % modulo;\n\n    long long result = 0;\n    for (int index = 0; index <= maxCount; index++)\n    {\n        result = (result + dynamicProgramming[minLength / oneGroupSize + minLength / zeroGroupSize - index] - \n            (minLength - 1) / oneGroupSize - (minLength - 1) / zeroGroupSize + index < 0 ? 0\n            : dynamicProgramming[(minLength - 1) / oneGroupSize + (minLength - 1) / zeroGroupSize - index]) % modulo;\n    }\n\n    return result;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint CountGoodStrings(int min_length, int max_length, int one_group_size, int zero_group_size, int modulo= 1000000007)\n{\n    int maxCount= max_length / one_group_size + max_length / zero_group_size;\n\n    std::vector<long long> dynamicProgramming(maxCount + 1);\n    dynamicProgramming[0]= 1;\n\n    for(int index= 1; index <= maxCount; index++)\n        dynamicProgramming[index]= (dynamicProgramming[index - 1] * (index % one_group_size == 0 || index % zero_group_size == 0)) % modulo;\n\n    long long result= 0;\n    for(int index= 0; index <= maxCount; index++)\n    {\n        result= (result + dynamicProgramming[min_length / one_group_size + min_length / zero_group_size - index] - (min_length - 1) / one_group_size - (min_length - 1) / zero_group_size + index < 0 ? 0\n                                                                                                                                                                                          : dynamicProgramming[(min_length - 1) / one_group_size + (min_length - 1) / zero_group_size - index]) %\n                modulo;\n    }\n\n    return result;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> timeCrossingTheDoor(vector<int> &arrivalTimes, vector<int> &personState)\n{\n    int numberOfPersons= arrivalTimes.size();\n    vector<int> crossingTimes(numberOfPersons);\n    vector<int> lastSeenTimeAtDoor(2, -1);\n\n    for(int personIndex= 0, currentTime= 0; personIndex < numberOfPersons; ++personIndex, ++currentTime)\n    {\n        while(currentTime < arrivalTimes[personIndex])\n            currentTime++;\n\n        int direction= (lastSeenTimeAtDoor[1] != currentTime - 1) ? 1 : 0;\n\n        if(personState[personIndex] == direction)\n        {\n            lastSeenTimeAtDoor[personState[personIndex]]= currentTime;\n        }\n        else\n        {\n            while(personIndex + 1 < numberOfPersons && arrivalTimes[personIndex + 1] == currentTime && personState[personIndex + 1] != direction)\n                ++personIndex;\n\n            if(personIndex + 1 < numberOfPersons && arrivalTimes[personIndex + 1] == currentTime && personState[personIndex + 1] == direction)\n            {\n                lastSeenTimeAtDoor[personState[personIndex= personIndex + 1]]= currentTime;\n            }\n            else\n            {\n                currentTime--, personIndex--;\n            }\n        }\n        crossingTimes[personIndex]= lastSeenTimeAtDoor[personState[personIndex]];\n    }\n    return crossingTimes;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> TimeCrossingTheDoor(std::vector<int> &arrival_times, std::vector<int> &person_state)\n{\n    int numberOfPersons = arrival_times.size();\n    std::vector<int> crossingTimes(numberOfPersons);\n    std::vector<int> lastSeenTimeAtDoor(2, -1);\n\n    for(int personIndex = 0, currentTime = 0; personIndex < numberOfPersons; ++personIndex, ++currentTime)\n    {\n        while(currentTime < arrival_times[personIndex])\n            currentTime++;\n\n        int direction = (lastSeenTimeAtDoor[1] != currentTime - 1) ? 1 : 0;\n\n        if(person_state[personIndex] == direction)\n        {\n            lastSeenTimeAtDoor[person_state[personIndex]] = currentTime;\n        }\n        else\n        {\n            while(personIndex + 1 < numberOfPersons && arrival_times[personIndex + 1] == currentTime && person_state[personIndex + 1] != direction)\n                ++personIndex;\n\n            if(personIndex + 1 < numberOfPersons && arrival_times[personIndex + 1] == currentTime && person_state[personIndex + 1] == direction)\n            {\n                lastSeenTimeAtDoor[person_state[personIndex = personIndex + 1]] = currentTime;\n            }\n            else\n            {\n                currentTime--, personIndex--;\n            }\n        }\n        crossingTimes[personIndex] = lastSeenTimeAtDoor[person_state[personIndex]];\n    }\n    return crossingTimes;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\n// For abs function\nusing namespace std;\n\nint differenceBetweenElementAndDigitSum(vector<int> &numbers)\n{\n    int totalElementSum = 0, totalDigitSum = 0;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int currentNumber = numbers[i];\n        totalElementSum += currentNumber;\n        int tempNumber = currentNumber; // Create a temporary variable to hold the current number\n        while (tempNumber > 0)\n        {\n            totalDigitSum += tempNumber % 10;\n            tempNumber /= 10;\n        }\n    }\n    return abs(totalElementSum - totalDigitSum);\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint DifferenceBetweenElementAndDigitSum(std::vector<int> &numbers)\n{\n    int totalElementSum= 0, totalDigitSum= 0;\n    for(int current_number : numbers)\n    {\n        totalElementSum+= current_number;\n        int tempNumber= current_number; // Create a temporary variable to hold the current number\n        while(tempNumber > 0)\n        {\n            totalDigitSum+= tempNumber % 10;\n            tempNumber/= 10;\n        }\n    }\n    return std::abs(totalElementSum - totalDigitSum);\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> applyQueries(int matrixSize, vector<vector<int>> &queryList)\n{\n    vector<vector<int>> matrix(matrixSize, vector<int>(matrixSize, 0));\n\n    for (int i = 0; i < queryList.size(); ++i)\n    {\n        auto &query = queryList[i];\n        for (int row = query[0]; row <= query[2]; ++row)\n        {\n            for (int col = query[1]; col <= query[3]; ++col)\n            {\n                matrix[row][col]++;\n            }\n        }\n    }\n\n    return matrix;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> ApplyQueries(int matrix_size, std::vector<std::vector<int>> &query_list)\n{\n    std::vector<std::vector<int>> matrix(matrix_size, std::vector<int>(matrix_size, 0));\n\n    for(auto &query : query_list)\n    {\n        for(int row= query[0]; row <= query[2]; ++row)\n        {\n            for(int col= query[1]; col <= query[3]; ++col)\n            {\n                matrix[row][col]++;\n            }\n        }\n    }\n\n    return matrix;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countGoodSubarrays(vector<int> &numbers, int targetSum)\n{\n    unordered_map<int, int> prefixSumCount;\n    int totalGoodSubarrays = 0, currentPrefixSum = 0;\n\n    prefixSumCount[0] = 1;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int number = numbers[i];\n        currentPrefixSum += number - 1;\n        totalGoodSubarrays += prefixSumCount[currentPrefixSum - targetSum];\n        prefixSumCount[currentPrefixSum]++;\n    }\n\n    return totalGoodSubarrays;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint CountGoodSubarrays(std::vector<int> &numbers, int target_sum)\n{\n    std::unordered_map<int, int> prefixSumCount;\n    int totalGoodSubarrays= 0, currentPrefixSum= 0;\n\n    prefixSumCount[0]= 1;\n    for(int number : numbers)\n    {\n        currentPrefixSum+= number - 1;\n        totalGoodSubarrays+= prefixSumCount[currentPrefixSum - target_sum];\n        prefixSumCount[currentPrefixSum]++;\n    }\n\n    return totalGoodSubarrays;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adjacencyList;\nvector<int> nodePrices;\nvector<pair<vector<long long>, vector<long long>>> dynamicProgramming;\n\nvoid depthFirstSearch(int currentNode, int parentNode)\n{\n    dynamicProgramming[currentNode].first[0] = nodePrices[currentNode];\n    dynamicProgramming[currentNode].first[1] = 0;\n    dynamicProgramming[currentNode].second[0] = nodePrices[currentNode];\n    dynamicProgramming[currentNode].second[1] = 0;\n\n    for (int i = 0; i < adjacencyList[currentNode].size(); ++i)\n    {\n        int neighborNode = adjacencyList[currentNode][i];\n        if (neighborNode == parentNode)\n            continue;\n        depthFirstSearch(neighborNode, currentNode);\n        dynamicProgramming[currentNode].first.push_back(dynamicProgramming[neighborNode].first[0] + nodePrices[currentNode] - dynamicProgramming[neighborNode].second[0]);\n        dynamicProgramming[currentNode].first.push_back(dynamicProgramming[neighborNode].first[1]);\n        dynamicProgramming[currentNode].second.push_back(dynamicProgramming[neighborNode].second[0] + nodePrices[currentNode] - dynamicProgramming[neighborNode].first[0]);\n        dynamicProgramming[currentNode].second.push_back(dynamicProgramming[neighborNode].second[1]);\n\n        sort(dynamicProgramming[currentNode].first.begin(), dynamicProgramming[currentNode].first.end());\n        sort(dynamicProgramming[currentNode].second.begin(), dynamicProgramming[currentNode].second.end());\n    }\n}\n\nint getMaxCost(int numberOfNodes, vector<vector<int>> &edges, vector<int> &priceList)\n{\n    adjacencyList.resize(numberOfNodes);\n    nodePrices = priceList;\n    dynamicProgramming.resize(numberOfNodes, pair<vector<long long>, vector<long long>>(vector<long long>(2), vector<long long>(2)));\n\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        vector<int> &edge = edges[i];\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    depthFirstSearch(0, -1);\n\n    long long maximumCost = 0;\n    for (int i = 0; i < numberOfNodes; ++i)\n    {\n        maximumCost = max(maximumCost, dynamicProgramming[i].first.back() - dynamicProgramming[i].second.back());\n    }\n\n    return maximumCost;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> adjacencyList;\nstd::vector<int> nodePrices;\nstd::vector<std::pair<std::vector<long long>, std::vector<long long>>> dynamicProgramming;\n\nvoid DepthFirstSearch(int current_node, int parent_node)\n{\n    dynamicProgramming[current_node].first[0] = nodePrices[current_node];\n    dynamicProgramming[current_node].first[1] = 0;\n    dynamicProgramming[current_node].second[0] = nodePrices[current_node];\n    dynamicProgramming[current_node].second[1] = 0;\n\n    for(int neighbor_node : adjacencyList[current_node])\n    {\n        if(neighbor_node == parent_node)\n            continue;\n        DepthFirstSearch(neighbor_node, current_node);\n        dynamicProgramming[current_node].first.push_back(dynamicProgramming[neighbor_node].first[0] + nodePrices[current_node] - dynamicProgramming[neighbor_node].second[0]);\n        dynamicProgramming[current_node].first.push_back(dynamicProgramming[neighbor_node].first[1]);\n        dynamicProgramming[current_node].second.push_back(dynamicProgramming[neighbor_node].second[0] + nodePrices[current_node] - dynamicProgramming[neighbor_node].first[0]);\n        dynamicProgramming[current_node].second.push_back(dynamicProgramming[neighbor_node].second[1]);\n\n        std::sort(dynamicProgramming[current_node].first.begin(), dynamicProgramming[current_node].first.end());\n        std::sort(dynamicProgramming[current_node].second.begin(), dynamicProgramming[current_node].second.end());\n    }\n}\n\nint GetMaxCost(int number_of_nodes, std::vector<std::vector<int>> &edges, std::vector<int> &price_list)\n{\n    adjacencyList.resize(number_of_nodes);\n    nodePrices = price_list;\n    dynamicProgramming.resize(number_of_nodes, std::pair<std::vector<long long>, std::vector<long long>>(std::vector<long long>(2), std::vector<long long>(2)));\n\n    for(std::vector<int> &edge : edges)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    DepthFirstSearch(0, -1);\n\n    long long maximumCost = 0;\n    for(int i = 0; i < number_of_nodes; ++i)\n    {\n        maximumCost = std::max(maximumCost, dynamicProgramming[i].first.back() - dynamicProgramming[i].second.back());\n    }\n\n    return maximumCost;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countOfGoodSubsequences(string inputString)\n{\n    vector<int> characterCount(26, 0);\n    long totalCount = 0;\n    const int modulo = 1000000007;\n\n    for (char currentChar : inputString)\n    {\n        characterCount[currentChar - 'a']++;\n    }\n\n    for (int i = 0; i < characterCount.size(); ++i)\n    {\n        int occurrence = characterCount[i];\n        totalCount = (totalCount + (1L << occurrence) - 1) % modulo;\n    }\n\n    return totalCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint CountOfGoodSubsequences(std::string input_string)\n{\n    std::vector<int> characterCount(26, 0);\n    long totalCount= 0;\n    const int modulo= 1000000007;\n\n    for(char currentChar : input_string)\n    {\n        characterCount[currentChar - 'a']++;\n    }\n\n    for(int occurrence : characterCount)\n    {\n        totalCount= (totalCount + (1L << occurrence) - 1) % modulo;\n    }\n\n    return totalCount;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint findMinimumCommonNumber(vector<int> &firstArray, vector<int> &secondArray)\n{\n    int firstIndex= 0, secondIndex= 0;\n    while(firstIndex < firstArray.size() && secondIndex < secondArray.size())\n    {\n        if(firstArray[firstIndex] == secondArray[secondIndex])\n        {\n            return firstArray[firstIndex];\n        }\n        else if(firstArray[firstIndex] < secondArray[secondIndex])\n        {\n            firstIndex++;\n        }\n        else\n        {\n            secondIndex++;\n        }\n    }\n    return -1;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint FindMinimumCommonNumber(std::vector<int> &first_array, std::vector<int> &second_array)\n{\n    int firstIndex= 0, secondIndex= 0;\n    while(firstIndex < first_array.size() && secondIndex < second_array.size())\n    {\n        if(first_array[firstIndex] == second_array[secondIndex])\n        {\n            return first_array[firstIndex];\n        }\n        else if(first_array[firstIndex] < second_array[secondIndex])\n        {\n            firstIndex++;\n        }\n        else\n        {\n            secondIndex++;\n        }\n    }\n    return -1;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\n// For abs function\nusing namespace std;\n\nint minChanges(vector<int> &firstArray, vector<int> &secondArray, int differenceFactor)\n{\n    int arraySize= firstArray.size();\n    int totalOperations= 0;\n    for(int index= 0; index < arraySize; ++index)\n    {\n        int difference= abs(firstArray[index] - secondArray[index]);\n        if(difference % differenceFactor != 0)\n            return -1;\n        totalOperations+= difference / differenceFactor;\n    }\n    return totalOperations;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\n// For std::abs\n\nint MinChanges(std::vector<int> &first_array, std::vector<int> &second_array, int difference_factor)\n{\n    int arraySize = first_array.size();\n    int totalOperations = 0;\n    for(int index = 0; index < arraySize; ++index)\n    {\n        int difference = std::abs(first_array[index] - second_array[index]);\n        if(difference % difference_factor != 0)\n            return -1;\n        totalOperations += difference / difference_factor;\n    }\n    return totalOperations;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxScore(vector<int> &firstArray, vector<int> &secondArray, int maxElements)\n{\n    int arraySize = firstArray.size();\n    int maximumResult = 0;\n    int sumFirstArray = 0, minimumSecondArray = secondArray[0];\n    for(int startIndex = 0, endIndex = 0; endIndex < arraySize; ++endIndex)\n    {\n        sumFirstArray += firstArray[endIndex];\n        minimumSecondArray = min(minimumSecondArray, secondArray[endIndex]);\n        if(endIndex - startIndex + 1 > maxElements)\n            sumFirstArray -= firstArray[startIndex++];\n        if(endIndex + 1 >= maxElements)\n            maximumResult = max(maximumResult, sumFirstArray * minimumSecondArray);\n    }\n    return maximumResult;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint MaxScore(std::vector<int> &first_array, std::vector<int> &second_array, int max_elements)\n{\n    int arraySize = first_array.size();\n    int maximumResult = 0;\n    int sumFirstArray = 0, minimumSecondArray = second_array[0];\n    \n    for(int startIndex = 0, endIndex = 0; endIndex < arraySize; ++endIndex)\n    {\n        sumFirstArray += first_array[endIndex];\n        minimumSecondArray = std::min(minimumSecondArray, second_array[endIndex]);\n        \n        if(endIndex - startIndex + 1 > max_elements)\n            sumFirstArray -= first_array[startIndex++];\n        \n        if(endIndex + 1 >= max_elements)\n            maximumResult = std::max(maximumResult, sumFirstArray * minimumSecondArray);\n    }\n    \n    return maximumResult;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nbool canReach(int targetX, int targetY)\n{\n    while(targetX > 1 && targetY > 1)\n    {\n        if(targetX < targetY)\n            swap(targetX, targetY);\n        targetX-= targetY;\n    }\n    return targetX == 1 || targetY == 1;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "bool CanReach(int target_x, int target_y)\n{\n    while(target_x > 1 && target_y > 1)\n    {\n        if(target_x < target_y)\n            swap(target_x, target_y);\n        target_x-= target_y;\n    }\n    return target_x == 1 || target_y == 1;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint sumOfDigits(int inputNumber)\n{\n    int digitSum= 0;\n    bool isPositive= true;\n\n    while(inputNumber > 0)\n    {\n        int currentDigit= inputNumber % 10;\n        inputNumber/= 10;\n\n        if(isPositive)\n        {\n            digitSum+= currentDigit;\n        }\n        else\n        {\n            digitSum-= currentDigit;\n        }\n\n        isPositive= !isPositive;\n    }\n\n    return digitSum;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int SumOfDigits(int input_number)\n{\n    int digitSum= 0;\n    bool isPositive= true;\n\n    while(input_number > 0)\n    {\n        int currentDigit= input_number % 10;\n        input_number/= 10;\n\n        if(isPositive)\n        {\n            digitSum+= currentDigit;\n        }\n        else\n        {\n            digitSum-= currentDigit;\n        }\n\n        isPositive= !isPositive;\n    }\n\n    return digitSum;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> sortStudents(vector<vector<int>> &studentScores, int scoreIndex)\n{\n    sort(studentScores.begin(), studentScores.end(), [scoreIndex](const vector<int> &firstStudent, const vector<int> &secondStudent)\n         { return firstStudent[scoreIndex] > secondStudent[scoreIndex]; });\n    return studentScores;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> SortStudents(std::vector<std::vector<int>> &student_scores, int score_index)\n{\n    std::sort(student_scores.begin(), student_scores.end(), [score_index](const std::vector<int> &first_student, const std::vector<int> &second_student)\n         { return first_student[score_index] > second_student[score_index]; });\n    return student_scores;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool canMakeEqual(string sourceString, string targetString)\n{\n    int sourceCountOnes= count(sourceString.begin(), sourceString.end(), '1');\n    int targetCountOnes= count(targetString.begin(), targetString.end(), '1');\n    return sourceCountOnes >= targetCountOnes;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nbool CanMakeEqual(std::string source_string, std::string target_string)\n{\n    int sourceCountOnes = std::count(source_string.begin(), source_string.end(), '1');\n    int targetCountOnes = std::count(target_string.begin(), target_string.end(), '1');\n    return sourceCountOnes >= targetCountOnes;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\n// For std::min\nusing namespace std;\n\nint getCost(int endIndex, vector<int> &frequencyCount, vector<int> &numberList)\n{\n    return frequencyCount[numberList[endIndex]] == 1 ? 1 : 0;\n}\n\nint minCost(vector<int> &numberList, int cost)\n{\n    int listSize= numberList.size(), infinity= 1e9 + 7;\n    vector<int> frequencyCount(1001, 0), dynamicProgramming(listSize + 1, 0); // frequencyCount for frequency, dynamicProgramming for dynamic programming\n\n    for(int startIndex= 0, endIndex= 0; endIndex < listSize; ++endIndex)\n    {\n        ++frequencyCount[numberList[endIndex]];\n\n        if(frequencyCount[numberList[endIndex]] == 2) // if occurrence is 2, change dynamicProgramming\n            dynamicProgramming[endIndex + 1]= dynamicProgramming[startIndex] + cost + (endIndex - startIndex + 1);\n        else if(frequencyCount[numberList[endIndex]] > 2) // if occurrence is more than 2\n            dynamicProgramming[endIndex + 1]= min(dynamicProgramming[endIndex], dynamicProgramming[endIndex - 1] - (frequencyCount[numberList[endIndex]] - 2));\n        else\n            dynamicProgramming[endIndex + 1]= dynamicProgramming[endIndex] + getCost(endIndex, frequencyCount, numberList) + cost;\n\n        while(startIndex < endIndex + 1 && frequencyCount[numberList[startIndex]] >= 2)\n        {\n            --frequencyCount[numberList[startIndex]];\n            ++startIndex; // update first pointer startIndex when numberList[startIndex] has occurred more than once\n        }\n    }\n\n    return dynamicProgramming[listSize];\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\n// For std::min\n\nint MinCost(std::vector<int> &number_list, int cost)\n{\n    int listSize = number_list.size(), infinity = 1e9 + 7;\n    std::vector<int> frequencyCount(1001, 0), dynamicProgramming(listSize + 1, 0); // frequencyCount for frequency, dynamicProgramming for dynamic programming\n\n    for(int startIndex = 0, endIndex = 0; endIndex < listSize; ++endIndex)\n    {\n        ++frequencyCount[number_list[endIndex]];\n\n        if(frequencyCount[number_list[endIndex]] == 2) // if occurrence is 2, change dynamicProgramming\n            dynamicProgramming[endIndex + 1] = dynamicProgramming[startIndex] + cost + (endIndex - startIndex + 1);\n        else if(frequencyCount[number_list[endIndex]] > 2) // if occurrence is more than 2\n            dynamicProgramming[endIndex + 1] = std::min(dynamicProgramming[endIndex], dynamicProgramming[endIndex - 1] - (frequencyCount[number_list[endIndex]] - 2));\n        else\n            dynamicProgramming[endIndex + 1] = dynamicProgramming[endIndex] + GetCost(endIndex, frequencyCount, number_list) + cost;\n\n        while(startIndex < endIndex + 1 && frequencyCount[number_list[startIndex]] >= 2)\n        {\n            --frequencyCount[number_list[startIndex]];\n            ++startIndex; // update first pointer startIndex when numberList[startIndex] has occurred more than once\n        }\n    }\n\n    return dynamicProgramming[listSize];\n}\n\nint GetCost(int end_index, std::vector<int> &frequency_count, std::vector<int> &number_list)\n{\n    return frequency_count[number_list[end_index]] == 1 ? 1 : 0;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble maxValue(vector<vector<int>> &items, int capacity)\n{\n    sort(items.begin(), items.end(), [](const vector<int> &a, const vector<int> &b)\n         { return (double)a[0] / a[1] > (double)b[0] / b[1]; });\n\n    double maxTotalPrice = 0;\n    for (int i = 0; i < items.size(); ++i)\n    {\n        const auto &item = items[i];\n        if (capacity >= item[1])\n        {\n            capacity -= item[1];\n            maxTotalPrice += item[0];\n        }\n        else\n        {\n            maxTotalPrice += (double)item[0] * capacity / item[1];\n            break;\n        }\n    }\n\n    return maxTotalPrice;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\ndouble MaxValue(std::vector<std::vector<int>> &items, int capacity)\n{\n    std::sort(items.begin(), items.end(), [](const std::vector<int> &a, const std::vector<int> &b)\n         { return (double)a[0] / a[1] > (double)b[0] / b[1]; });\n\n    double maxTotalPrice= 0;\n    for(const auto &item : items)\n    {\n        if(capacity >= item[1])\n        {\n            capacity-= item[1];\n            maxTotalPrice+= item[0];\n        }\n        else\n        {\n            maxTotalPrice+= (double)item[0] * capacity / item[1];\n            break;\n        }\n    }\n\n    return maxTotalPrice;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint distinctCount(int totalNumbers)\n{\n    return totalNumbers - 1;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int DistinctCount(int total_numbers)\n{\n    return total_numbers - 1;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod= 1e9 + 7;\n\nint waysToCollide(int numberOfObjects)\n{\n    int powerOfTwo= 1;\n    for(int index= 0; index < numberOfObjects; index++)\n    {\n        powerOfTwo= (2LL * powerOfTwo) % mod;\n    }\n    return (powerOfTwo - numberOfObjects - 1 + mod) % mod;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nconst int mod = 1e9 + 7;\n\nint WaysToCollide(int number_of_objects)\n{\n    int powerOfTwo = 1;\n    for(int index = 0; index < number_of_objects; index++)\n    {\n        powerOfTwo = (2LL * powerOfTwo) % mod;\n    }\n    return (powerOfTwo - number_of_objects - 1 + mod) % mod;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maximizeScore(vector<int> &weightValues, int numberOfGroups)\n{\n    int totalWeights= weightValues.size();\n    vector<int> prefixSum(totalWeights + 1);\n    partial_sum(weightValues.begin(), weightValues.end(), prefixSum.begin() + 1);\n    vector<vector<int>> dynamicProgramming(totalWeights, vector<int>(numberOfGroups + 1));\n\n    for(int currentIndex= 0; currentIndex < totalWeights; currentIndex++)\n    {\n        for(int groupIndex= 1; groupIndex <= numberOfGroups; groupIndex++)\n        {\n            dynamicProgramming[currentIndex][groupIndex]= -1e9;\n        }\n    }\n\n    for(int currentIndex= 0; currentIndex < totalWeights; currentIndex++)\n    {\n        dynamicProgramming[currentIndex][1]= prefixSum[currentIndex + 1];\n        if(currentIndex > 0)\n        {\n            dynamicProgramming[currentIndex][currentIndex + 1]= prefixSum[currentIndex + 1] - prefixSum[1];\n        }\n        for(int groupIndex= 2; groupIndex <= min<int>(currentIndex + 1, numberOfGroups); groupIndex++)\n        {\n            for(int previousGroupSize= 1; previousGroupSize <= currentIndex - groupIndex + 2; previousGroupSize++)\n            {\n                dynamicProgramming[currentIndex][groupIndex]= max(dynamicProgramming[currentIndex][groupIndex],\n                                                                   dynamicProgramming[currentIndex - previousGroupSize][groupIndex - 1] + weightValues[currentIndex] + weightValues[currentIndex - previousGroupSize]);\n            }\n        }\n    }\n\n    return dynamicProgramming[totalWeights - 1][numberOfGroups] - dynamicProgramming[totalWeights - 1][1];\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint MaximizeScore(std::vector<int> &weight_values, int number_of_groups)\n{\n    int totalWeights= weight_values.size();\n    std::vector<int> prefixSum(totalWeights + 1);\n    std::partial_sum(weight_values.begin(), weight_values.end(), prefixSum.begin() + 1);\n    std::vector<std::vector<int>> dynamicProgramming(totalWeights, std::vector<int>(number_of_groups + 1));\n\n    for(int currentIndex= 0; currentIndex < totalWeights; currentIndex++)\n    {\n        for(int groupIndex= 1; groupIndex <= number_of_groups; groupIndex++)\n        {\n            dynamicProgramming[currentIndex][groupIndex]= -1e9;\n        }\n    }\n\n    for(int currentIndex= 0; currentIndex < totalWeights; currentIndex++)\n    {\n        dynamicProgramming[currentIndex][1]= prefixSum[currentIndex + 1];\n        if(currentIndex > 0)\n        {\n            dynamicProgramming[currentIndex][currentIndex + 1]= prefixSum[currentIndex + 1] - prefixSum[1];\n        }\n        for(int groupIndex= 2; groupIndex <= std::min<int>(currentIndex + 1, number_of_groups); groupIndex++)\n        {\n            for(int previousGroupSize= 1; previousGroupSize <= currentIndex - groupIndex + 2; previousGroupSize++)\n            {\n                dynamicProgramming[currentIndex][groupIndex]= std::max(dynamicProgramming[currentIndex][groupIndex],\n                                                                       dynamicProgramming[currentIndex - previousGroupSize][groupIndex - 1] + weight_values[currentIndex] + weight_values[currentIndex - previousGroupSize]);\n            }\n        }\n    }\n\n    return dynamicProgramming[totalWeights - 1][number_of_groups] - dynamicProgramming[totalWeights - 1][1];\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countIncreasingQuadruplets(vector<int> &numberList)\n{\n    int listSize= numberList.size(), quadrupletCount= 0;\n    for(int firstIndex= 0; firstIndex < listSize - 3; firstIndex++)\n    {\n        for(int secondIndex= firstIndex + 1; secondIndex < listSize - 2; secondIndex++)\n        {\n            for(int thirdIndex= secondIndex + 1; thirdIndex < listSize - 1; thirdIndex++)\n            {\n                if(numberList[firstIndex] < numberList[thirdIndex] && numberList[thirdIndex] < numberList[secondIndex])\n                {\n                    for(int fourthIndex= thirdIndex + 1; fourthIndex < listSize; fourthIndex++)\n                    {\n                        if(numberList[secondIndex] < numberList[fourthIndex])\n                        {\n                            quadrupletCount++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return quadrupletCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint CountIncreasingQuadruplets(std::vector<int> &number_list)\n{\n    int listSize= number_list.size(), quadrupletCount= 0;\n    for(int firstIndex= 0; firstIndex < listSize - 3; firstIndex++)\n    {\n        for(int secondIndex= firstIndex + 1; secondIndex < listSize - 2; secondIndex++)\n        {\n            for(int thirdIndex= secondIndex + 1; thirdIndex < listSize - 1; thirdIndex++)\n            {\n                if(number_list[firstIndex] < number_list[thirdIndex] && number_list[thirdIndex] < number_list[secondIndex])\n                {\n                    for(int fourthIndex= thirdIndex + 1; fourthIndex < listSize; fourthIndex++)\n                    {\n                        if(number_list[secondIndex] < number_list[fourthIndex])\n                        {\n                            quadrupletCount++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return quadrupletCount;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> separateDigits(const vector<int> &inputNumbers)\n{\n    vector<int> resultDigits;\n    for (int i = 0; i < inputNumbers.size(); ++i)\n    {\n        int currentNumber = inputNumbers[i];\n        vector<int> extractedDigits;\n        while (currentNumber)\n        {\n            extractedDigits.insert(extractedDigits.begin(), currentNumber % 10);\n            currentNumber /= 10;\n        }\n        resultDigits.insert(resultDigits.end(), extractedDigits.begin(), extractedDigits.end());\n    }\n    return resultDigits;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> SeparateDigits(const std::vector<int> &input_numbers)\n{\n    std::vector<int> resultDigits;\n    for(auto currentNumber : input_numbers)\n    {\n        std::vector<int> extractedDigits;\n        while(currentNumber)\n        {\n            extractedDigits.insert(extractedDigits.begin(), currentNumber % 10);\n            currentNumber/= 10;\n        }\n        resultDigits.insert(resultDigits.end(), extractedDigits.begin(), extractedDigits.end());\n    }\n    return resultDigits;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxChosenIntegers(vector<int> &bannedIntegers, int totalIntegers, int maxSum)\n{\n    unordered_set<int> bannedSet(bannedIntegers.begin(), bannedIntegers.end());\n    int chosenCount= 0, currentSum= 0;\n    for(int integer= totalIntegers; integer >= 1 && maxSum - currentSum >= integer; --integer)\n    {\n        if(bannedSet.find(integer) == bannedSet.end())\n        {\n            currentSum+= integer;\n            ++chosenCount;\n        }\n    }\n    return chosenCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint MaxChosenIntegers(std::vector<int> &banned_integers, int total_integers, int max_sum)\n{\n    std::unordered_set<int> bannedSet(banned_integers.begin(), banned_integers.end());\n    int chosenCount = 0, currentSum = 0;\n    for(int integer = total_integers; integer >= 1 && max_sum - currentSum >= integer; --integer)\n    {\n        if(bannedSet.find(integer) == bannedSet.end())\n        {\n            currentSum += integer;\n            ++chosenCount;\n        }\n    }\n    return chosenCount;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxPrizes(vector<int> &prizePositions, int maxDistance)\n{\n    int totalPositions= prizePositions.size();\n    int maximumPrizes= 0;\n    for(int currentIndex= 0; currentIndex < totalPositions; ++currentIndex)\n    {\n        int leftSegmentEnd= prizePositions[currentIndex] + maxDistance;\n        int rightSegmentStart= upper_bound(prizePositions.begin(), prizePositions.end(), leftSegmentEnd) - prizePositions.begin();\n        int rightSegmentEnd= prizePositions[rightSegmentStart] + maxDistance;\n        maximumPrizes= max(maximumPrizes, int(upper_bound(prizePositions.begin(), prizePositions.end(), rightSegmentEnd) - lower_bound(prizePositions.begin(), prizePositions.end(), prizePositions[currentIndex])));\n    }\n    return maximumPrizes;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint MaxPrizes(std::vector<int> &prize_positions, int max_distance)\n{\n    int totalPositions= prize_positions.size();\n    int maximumPrizes= 0;\n    for(int currentIndex= 0; currentIndex < totalPositions; ++currentIndex)\n    {\n        int leftSegmentEnd= prize_positions[currentIndex] + max_distance;\n        int rightSegmentStart= std::upper_bound(prize_positions.begin(), prize_positions.end(), leftSegmentEnd) - prize_positions.begin();\n        int rightSegmentEnd= prize_positions[rightSegmentStart] + max_distance;\n        maximumPrizes= std::max(maximumPrizes, int(std::upper_bound(prize_positions.begin(), prize_positions.end(), rightSegmentEnd) - std::lower_bound(prize_positions.begin(), prize_positions.end(), prize_positions[currentIndex])));\n    }\n    return maximumPrizes;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool canReach(vector<vector<int>> &grid, int currentRow, int currentCol)\n{\n    if(currentRow < 0 || currentCol < 0 || currentRow >= grid.size() || currentCol >= grid[0].size() || grid[currentRow][currentCol] == 0)\n        return false;\n\n    if(currentRow == grid.size() - 1 && currentCol == grid[0].size() - 1)\n        return true;\n\n    grid[currentRow][currentCol]= 0;\n\n    return canReach(grid, currentRow + 1, currentCol) || canReach(grid, currentRow, currentCol + 1);\n}\n\nbool canDisconnect(vector<vector<int>> &grid)\n{\n    int reachableCount= 0;\n\n    for(int currentRow= 1; currentRow < grid.size(); currentRow++)\n    {\n        for(int currentCol= 1; currentCol < grid[0].size(); currentCol++)\n        {\n            if(grid[currentRow][currentCol] == 1 && (canReach(grid, currentRow - 1, currentCol) || canReach(grid, currentRow, currentCol - 1)))\n            {\n                reachableCount++;\n                if(reachableCount > 1)\n                    return true;\n            }\n        }\n    }\n\n    return reachableCount <= 1;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nbool CanReach(std::vector<std::vector<int>> &grid, int current_row, int current_col)\n{\n    if(current_row < 0 || current_col < 0 || current_row >= grid.size() || current_col >= grid[0].size() || grid[current_row][current_col] == 0)\n        return false;\n\n    if(current_row == grid.size() - 1 && current_col == grid[0].size() - 1)\n        return true;\n\n    grid[current_row][current_col]= 0;\n\n    return CanReach(grid, current_row + 1, current_col) || CanReach(grid, current_row, current_col + 1);\n}\n\nbool CanDisconnect(std::vector<std::vector<int>> &grid)\n{\n    int reachableCount= 0;\n\n    for(int currentRow= 1; currentRow < grid.size(); currentRow++)\n    {\n        for(int currentCol= 1; currentCol < grid[0].size(); currentCol++)\n        {\n            if(grid[currentRow][currentCol] == 1 && (CanReach(grid, currentRow - 1, currentCol) || CanReach(grid, currentRow, currentCol - 1)))\n            {\n                reachableCount++;\n                if(reachableCount > 1)\n                    return true;\n            }\n        }\n    }\n\n    return reachableCount <= 1;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxChosenIntegers(vector<int> &bannedIntegers, int totalIntegers, long long maxAllowedSum)\n{\n    unordered_set<int> bannedSet(bannedIntegers.begin(), bannedIntegers.end());\n    int countChosenIntegers= 0;\n    long long currentChosenSum= 0;\n\n    for(int i= totalIntegers; i > 0 && currentChosenSum < maxAllowedSum; --i)\n    {\n        if(bannedSet.find(i) == bannedSet.end())\n        {\n            if(currentChosenSum + i <= maxAllowedSum)\n            {\n                currentChosenSum+= i;\n                countChosenIntegers++;\n            }\n            else\n            {\n                break;\n            }\n        }\n    }\n\n    return countChosenIntegers;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint MaxChosenIntegers(std::vector<int> &banned_integers, int total_integers, long long max_allowed_sum)\n{\n    std::unordered_set<int> bannedSet(banned_integers.begin(), banned_integers.end());\n    int countChosenIntegers= 0;\n    long long currentChosenSum= 0;\n\n    for(int i= total_integers; i > 0 && currentChosenSum < max_allowed_sum; --i)\n    {\n        if(bannedSet.find(i) == bannedSet.end())\n        {\n            if(currentChosenSum + i <= max_allowed_sum)\n            {\n                currentChosenSum+= i;\n                countChosenIntegers++;\n            }\n            else\n            {\n                break;\n            }\n        }\n    }\n\n    return countChosenIntegers;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint giftsRemaining(vector<int> &giftValues, int numberOfIterations)\n{\n    for(int iteration = 0; iteration < numberOfIterations; iteration++)\n    {\n        sort(giftValues.begin(), giftValues.end());\n        int maxIndex = giftValues.size() - 1;\n        giftValues[maxIndex] -= static_cast<int>(sqrt(giftValues[maxIndex]));\n    }\n    int totalRemainingGifts = 0;\n    for(int j = 0; j < giftValues.size(); j++)\n        totalRemainingGifts += giftValues[j];\n    return totalRemainingGifts;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint GiftsRemaining(std::vector<int> &gift_values, int number_of_iterations)\n{\n    for(int iteration= 0; iteration < number_of_iterations; iteration++)\n    {\n        std::sort(gift_values.begin(), gift_values.end());\n        int maxIndex= gift_values.size() - 1;\n        gift_values[maxIndex]-= static_cast<int>(sqrt(gift_values[maxIndex]));\n    }\n    int totalRemainingGifts= 0;\n    for(int gift : gift_values)\n        totalRemainingGifts+= gift;\n    return totalRemainingGifts;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isVowel(char character)\n{\n    return character == 'a' || character == 'e' || character == 'i' || character == 'o' || character == 'u';\n}\n\nvector<int> countVowelStrings(vector<string> &wordList, vector<vector<int>> &queryRanges)\n{\n    vector<int> result;\n    for (int i = 0; i < queryRanges.size(); ++i)\n    {\n        auto &query = queryRanges[i];\n        int vowelStringCount = 0;\n        for (int index = query[0]; index <= query[1]; index++)\n        {\n            if (isVowel(wordList[index].front()) && isVowel(wordList[index].back()))\n            {\n                vowelStringCount++;\n            }\n        }\n        result.push_back(vowelStringCount);\n    }\n    return result;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nbool IsVowel(char character)\n{\n    return character == 'a' || character == 'e' || character == 'i' || character == 'o' || character == 'u';\n}\n\nstd::vector<int> CountVowelStrings(std::vector<std::string> &word_list, std::vector<std::vector<int>> &query_ranges)\n{\n    std::vector<int> result;\n    for(auto &query : query_ranges)\n    {\n        int vowelStringCount= 0;\n        for(int index= query[0]; index <= query[1]; index++)\n        {\n            if(IsVowel(word_list[index].front()) && IsVowel(word_list[index].back()))\n            {\n                vowelStringCount++;\n            }\n        }\n        result.push_back(vowelStringCount);\n    }\n    return result;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint findMinimumCapability(vector<int> &numberList, int requiredCount)\n{\n    int size= numberList.size(), left= 1, right= 1e9;\n    while(left < right)\n    {\n        int mid= left + (right - left) / 2, index= 0, count= 0;\n        for(int j= 0; j < size; ++j)\n        {\n            if(numberList[j] <= mid)\n            {\n                ++count;\n                index= j + 2;\n                while(index + 1 < size && (index == j + 1 || numberList[index] > mid))\n                    ++index;\n            }\n        }\n        if(count < requiredCount)\n            left= mid + 1;\n        else\n            right= mid;\n    }\n    return left;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint FindMinimumCapability(std::vector<int> &number_list, int required_count)\n{\n    int size= number_list.size(), left= 1, right= 1e9;\n    while(left < right)\n    {\n        int mid= left + (right - left) / 2, index= 0, count= 0;\n        for(int j= 0; j < size; ++j)\n        {\n            if(number_list[j] <= mid)\n            {\n                ++count;\n                index= j + 2;\n                while(index + 1 < size && (index == j + 1 || number_list[index] > mid))\n                    ++index;\n            }\n        }\n        if(count < required_count)\n            left= mid + 1;\n        else\n            right= mid;\n    }\n    return left;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minCostToEqualBaskets(vector<int> &basket1, vector<int> &basket2)\n{\n    unordered_map<int, int> differenceCount;\n    for (int index = 0; index < basket1.size(); index++)\n    {\n        differenceCount[basket1[index] - basket2[index]]++;\n    }\n\n    int minimumCost = INT_MAX, currentCost = 0;\n    for (auto it = differenceCount.begin(); it != differenceCount.end(); ++it) // traditional for loop\n    {\n        const auto &entry = *it;\n        if (entry.second == differenceCount[-entry.first])\n        {\n            currentCost = 0;\n            for (int index = 0; index < basket1.size(); index++)\n            {\n                if (basket1[index] - basket2[index] == entry.first)\n                {\n                    currentCost += min(basket1[index], basket2[index]);\n                }\n            }\n            minimumCost = min(minimumCost, currentCost);\n        }\n    }\n\n    return minimumCost == INT_MAX ? -1 : minimumCost / 2;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint MinCostToEqualBaskets(std::vector<int> &basket1, std::vector<int> &basket2)\n{\n    std::unordered_map<int, int> differenceCount;\n    for(int index= 0; index < basket1.size(); index++)\n    {\n        differenceCount[basket1[index] - basket2[index]]++;\n    }\n\n    int minimumCost= std::numeric_limits<int>::max(), currentCost= 0;\n    for(const auto &entry : differenceCount)\n    {\n        if(entry.second == differenceCount[-entry.first])\n        {\n            currentCost= 0;\n            for(int index= 0; index < basket1.size(); index++)\n            {\n                if(basket1[index] - basket2[index] == entry.first)\n                {\n                    currentCost+= std::min(basket1[index], basket2[index]);\n                }\n            }\n            minimumCost= std::min(minimumCost, currentCost);\n        }\n    }\n\n    return minimumCost == std::numeric_limits<int>::max() ? -1 : minimumCost / 2;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint concatenationValue(vector<int> &numberList)\n{\n    int concatenatedValue= 0;\n    while(!numberList.empty())\n    {\n        int size= numberList.size();\n        if(size == 1)\n        {\n            concatenatedValue+= numberList[0];\n            numberList.pop_back();\n        }\n        else\n        {\n            concatenatedValue+= stoi(to_string(numberList[0]) + to_string(numberList[size - 1]));\n            numberList.erase(numberList.begin());\n            numberList.pop_back();\n        }\n    }\n    return concatenatedValue;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint ConcatenationValue(std::vector<int> &number_list)\n{\n    int concatenatedValue= 0;\n    while(!number_list.empty())\n    {\n        int size= number_list.size();\n        if(size == 1)\n        {\n            concatenatedValue+= number_list[0];\n            number_list.pop_back();\n        }\n        else\n        {\n            concatenatedValue+= std::stoi(std::to_string(number_list[0]) + std::to_string(number_list[size - 1]));\n            number_list.erase(number_list.begin());\n            number_list.pop_back();\n        }\n    }\n    return concatenatedValue;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countFairPairs(vector<int> &numbers, int lowerBound, int upperBound)\n{\n    int size= numbers.size();\n    int fairPairCount= 0;\n    for(int indexI= 0; indexI < size; ++indexI)\n    {\n        for(int indexJ= indexI + 1; indexJ < size; ++indexJ)\n        {\n            if((lowerBound <= numbers[indexI] + numbers[indexJ]) && (numbers[indexI] + numbers[indexJ] <= upperBound))\n            {\n                fairPairCount++;\n            }\n        }\n    }\n    return fairPairCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint CountFairPairs(std::vector<int> &numbers, int lower_bound, int upper_bound)\n{\n    int size= numbers.size();\n    int fairPairCount= 0;\n    for(int indexI= 0; indexI < size; ++indexI)\n    {\n        for(int indexJ= indexI + 1; indexJ < size; ++indexJ)\n        {\n            if((lower_bound <= numbers[indexI] + numbers[indexJ]) && (numbers[indexI] + numbers[indexJ] <= upper_bound))\n            {\n                fairPairCount++;\n            }\n        }\n    }\n    return fairPairCount;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\n// Include this for log2 function\n\nusing namespace std;\n\nvector<vector<int>> shortestSubstringQueries(const string &inputString, const vector<vector<int>> &queryPairs)\n{\n    int stringLength = inputString.length();\n    unordered_map<int, int> indexMap;\n\n    for(int currentIndex = 0, currentValue = 0, bitMask = 0; currentIndex < stringLength; currentIndex++)\n    {\n        bitMask |= 1 << (inputString[currentIndex] - '0');\n        currentValue = (currentValue << 1) | (inputString[currentIndex] - '0');\n\n        for(int bitPosition = 0; bitPosition <= 9 && currentIndex + 1 - (1 << bitPosition) >= 0; bitPosition++)\n        {\n            int newValue = currentValue & ((1 << (bitPosition + 1)) - 1);\n            if(indexMap.count(newValue) == 0)\n                indexMap[newValue] = currentIndex + 1 - (1 << bitPosition);\n        }\n    }\n\n    vector<vector<int>> result;\n    for(int i = 0; i < queryPairs.size(); ++i)\n    {\n        const auto &query = queryPairs[i];\n        int targetValue = query[0] ^ query[1];\n        if(indexMap.count(targetValue))\n            result.push_back({indexMap[targetValue], indexMap[targetValue] + static_cast<int>(log2(targetValue))});\n        else\n            result.push_back({-1, -1});\n    }\n\n    return result;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> ShortestSubstringQueries(const std::string &input_string, const std::vector<std::vector<int>> &query_pairs)\n{\n    int stringLength= input_string.length();\n    std::unordered_map<int, int> indexMap;\n\n    for(int currentIndex= 0, currentValue= 0, bitMask= 0; currentIndex < stringLength; currentIndex++)\n    {\n        bitMask|= 1 << (input_string[currentIndex] - '0');\n        currentValue= (currentValue << 1) | (input_string[currentIndex] - '0');\n\n        for(int bitPosition= 0; bitPosition <= 9 && currentIndex + 1 - (1 << bitPosition) >= 0; bitPosition++)\n        {\n            int newValue= currentValue & ((1 << (bitPosition + 1)) - 1);\n            if(indexMap.count(newValue) == 0)\n                indexMap[newValue]= currentIndex + 1 - (1 << bitPosition);\n        }\n    }\n\n    std::vector<std::vector<int>> result;\n    for(const auto &query : query_pairs)\n    {\n        int targetValue= query[0] ^ query[1];\n        if(indexMap.count(targetValue))\n            result.push_back({indexMap[targetValue], indexMap[targetValue] + static_cast<int>(log2(targetValue))});\n        else\n            result.push_back({-1, -1});\n    }\n\n    return result;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMinimumScore(string sourceString, string targetString)\n{\n    int sourceLength= sourceString.size(), targetLength= targetString.size();\n    vector<vector<int>> dynamicProgrammingTable(sourceLength + 1, vector<int>(targetLength + 1, 1e6));\n    dynamicProgrammingTable[0][0]= 0;\n    for(int sourceIndex= 0; sourceIndex < sourceLength; ++sourceIndex)\n        for(int targetIndex= 0; targetIndex < targetLength; ++targetIndex)\n            if(sourceString[sourceIndex] == targetString[targetIndex])\n                dynamicProgrammingTable[sourceIndex + 1][targetIndex + 1]= min(dynamicProgrammingTable[sourceIndex + 1][targetIndex + 1], dynamicProgrammingTable[sourceIndex][targetIndex]);\n            else\n                dynamicProgrammingTable[sourceIndex + 1][targetIndex]= min(dynamicProgrammingTable[sourceIndex + 1][targetIndex], dynamicProgrammingTable[sourceIndex][targetIndex] + 1);\n    int minimumScore= 1e6;\n    for(int sourceIndex= 0; sourceIndex < sourceLength; ++sourceIndex)\n        minimumScore= min(minimumScore, dynamicProgrammingTable[sourceIndex + 1][targetLength]);\n    return minimumScore;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint CalculateMinimumScore(std::string source_string, std::string target_string)\n{\n    int sourceLength= source_string.size(), targetLength= target_string.size();\n    std::vector<std::vector<int>> dynamicProgrammingTable(sourceLength + 1, std::vector<int>(targetLength + 1, 1e6));\n    dynamicProgrammingTable[0][0]= 0;\n    for(int sourceIndex= 0; sourceIndex < sourceLength; ++sourceIndex)\n        for(int targetIndex= 0; targetIndex < targetLength; ++targetIndex)\n            if(source_string[sourceIndex] == target_string[targetIndex])\n                dynamicProgrammingTable[sourceIndex + 1][targetIndex + 1]= std::min(dynamicProgrammingTable[sourceIndex + 1][targetIndex + 1], dynamicProgrammingTable[sourceIndex][targetIndex]);\n            else\n                dynamicProgrammingTable[sourceIndex + 1][targetIndex]= std::min(dynamicProgrammingTable[sourceIndex + 1][targetIndex], dynamicProgrammingTable[sourceIndex][targetIndex] + 1);\n    int minimumScore= 1e6;\n    for(int sourceIndex= 0; sourceIndex < sourceLength; ++sourceIndex)\n        minimumScore= std::min(minimumScore, dynamicProgrammingTable[sourceIndex + 1][targetLength]);\n    return minimumScore;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateDifferenceMaxMin(int inputNumber)\n{\n    int maxRemapValue = 1, minRemapValue = 9;\n    string numberString = to_string(inputNumber);\n    for (int i = 0; i < numberString.size(); ++i)\n    {\n        char digitChar = numberString[i];\n        int digitValue = digitChar - '0';\n        maxRemapValue = max(maxRemapValue, 9 - digitValue);\n        if (digitValue != 0)\n        {\n            minRemapValue = min(minRemapValue, digitValue);\n        }\n    }\n    int maxCalculatedValue = inputNumber + maxRemapValue * (numberString.length() - count(numberString.begin(), numberString.end(), '9' - maxRemapValue));\n    int minCalculatedValue = inputNumber - minRemapValue * count(numberString.begin(), numberString.end(), minRemapValue + '0');\n    return maxCalculatedValue - minCalculatedValue;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint CalculateDifferenceMaxMin(int input_number)\n{\n    int maxRemapValue= 1, minRemapValue= 9;\n    std::string numberString= std::to_string(input_number);\n    for(char digitChar : numberString)\n    {\n        int digitValue= digitChar - '0';\n        maxRemapValue= std::max(maxRemapValue, 9 - digitValue);\n        if(digitValue != 0)\n        {\n            minRemapValue= std::min(minRemapValue, digitValue);\n        }\n    }\n    int maxCalculatedValue= input_number + maxRemapValue * (numberString.length() - std::count(numberString.begin(), numberString.end(), '9' - maxRemapValue));\n    int minCalculatedValue= input_number - minRemapValue * std::count(numberString.begin(), numberString.end(), minRemapValue + '0');\n    return maxCalculatedValue - minCalculatedValue;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minScoreAfterChange(vector<int> &numbers)\n{\n    int size = numbers.size();\n    int firstMin = numbers[0], secondMin = numbers[1], lastMax = numbers[size - 1], secondLastMax = numbers[size - 2];\n\n    for(int index = 1; index < size - 1; index++)\n    {\n        firstMin = min(firstMin, numbers[index]);\n        secondMin = min(secondMin, numbers[index + 1]);\n        lastMax = max(lastMax, numbers[index]);\n        secondLastMax = max(secondLastMax, numbers[index - 1]);\n    }\n\n    int low = min(min(firstMin, lastMax), min(secondMin, secondLastMax));\n    int high = max(max(firstMin, lastMax), max(secondMin, secondLastMax));\n\n    return high - low;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint MinScoreAfterChange(std::vector<int> &numbers)\n{\n    int size= numbers.size();\n    int first_min= numbers[0], second_min= numbers[1], last_max= numbers[size - 1], second_last_max= numbers[size - 2];\n\n    for(int index= 1; index < size - 1; index++)\n    {\n        first_min= std::min(first_min, numbers[index]);\n        second_min= std::min(second_min, numbers[index + 1]);\n        last_max= std::max(last_max, numbers[index]);\n        second_last_max= std::max(second_last_max, numbers[index - 1]);\n    }\n\n    int low= std::min(std::min(first_min, last_max), std::min(second_min, second_last_max));\n    int high= std::max(std::max(first_min, last_max), std::max(second_min, second_last_max));\n\n    return high - low;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint findMinNonExpressibleInteger(vector<int> &sortedNumbers)\n{\n    int minimumNonExpressibleInteger = 1;\n    sort(sortedNumbers.begin(), sortedNumbers.end());\n    for (int i = 0; i < sortedNumbers.size(); ++i)\n    {\n        int currentNumber = sortedNumbers[i];\n        if (currentNumber > minimumNonExpressibleInteger)\n            break;\n        minimumNonExpressibleInteger += currentNumber;\n    }\n    return minimumNonExpressibleInteger;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint FindMinNonExpressibleInteger(std::vector<int> &sorted_numbers)\n{\n    int minimumNonExpressibleInteger = 1;\n    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n    for(int currentNumber : sorted_numbers)\n    {\n        if(currentNumber > minimumNonExpressibleInteger)\n            break;\n        minimumNonExpressibleInteger += currentNumber;\n    }\n    return minimumNonExpressibleInteger;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> solve(vector<int> &sourceArray, vector<int> &targetArray, vector<vector<int>> &queries)\n{\n    vector<int> result;\n    for (int i = 0; i < queries.size(); ++i)\n    {\n        auto &query = queries[i];\n        if (query[0] == 1)\n        {\n            for (int index = query[1]; index <= query[2]; index++)\n            {\n                sourceArray[index] ^= 1;\n            }\n        }\n        else if (query[0] == 2)\n        {\n            for (int index = 0; index < sourceArray.size(); index++)\n            {\n                targetArray[index] += sourceArray[index] * query[1];\n            }\n        }\n        else if (query[0] == 3)\n        {\n            int totalSum = 0;\n            for (int j = 0; j < targetArray.size(); ++j)\n            {\n                totalSum += targetArray[j];\n            }\n            result.push_back(totalSum);\n        }\n    }\n    return result;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> Solve(std::vector<int> &source_array, std::vector<int> &target_array, std::vector<std::vector<int>> &queries)\n{\n    std::vector<int> result;\n    for(auto &query : queries)\n    {\n        if(query[0] == 1)\n        {\n            for(int index= query[1]; index <= query[2]; index++)\n            {\n                source_array[index]^= 1;\n            }\n        }\n        else if(query[0] == 2)\n        {\n            for(int index= 0; index < source_array.size(); index++)\n            {\n                target_array[index]+= source_array[index] * query[1];\n            }\n        }\n        else if(query[0] == 3)\n        {\n            int totalSum= 0;\n            for(auto number : target_array)\n            {\n                totalSum+= number;\n            }\n            result.push_back(totalSum);\n        }\n    }\n    return result;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> mergeNumbers(vector<vector<int>> &numberList1, vector<vector<int>> &numberList2)\n{\n    map<int, int> mergedMap;\n    vector<vector<int>> mergedResult;\n\n    for (int i = 0; i < numberList1.size(); ++i)\n    {\n        const auto &currentPair = numberList1[i];\n        mergedMap[currentPair[0]] += currentPair[1];\n    }\n\n    for (int i = 0; i < numberList2.size(); ++i)\n    {\n        const auto &currentPair = numberList2[i];\n        mergedMap[currentPair[0]] += currentPair[1];\n    }\n\n    for (const auto &currentPair : mergedMap)\n    {\n        mergedResult.push_back({currentPair.first, currentPair.second});\n    }\n\n    return mergedResult;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> MergeNumbers(std::vector<std::vector<int>> &number_list1, std::vector<std::vector<int>> &number_list2)\n{\n    std::map<int, int> mergedMap;\n    std::vector<std::vector<int>> mergedResult;\n\n    for(const auto &currentPair : number_list1)\n    {\n        mergedMap[currentPair[0]]+= currentPair[1];\n    }\n\n    for(const auto &currentPair : number_list2)\n    {\n        mergedMap[currentPair[0]]+= currentPair[1];\n    }\n\n    for(const auto &currentPair : mergedMap)\n    {\n        mergedResult.push_back({currentPair.first, currentPair.second});\n    }\n\n    return mergedResult;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint minOperations(int inputNumber)\n{\n    int totalOperations= 0;\n    while(inputNumber)\n    {\n        totalOperations+= inputNumber % 2;\n        inputNumber/= 2;\n    }\n    return totalOperations;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int MinOperations(int input_number)\n{\n    int totalOperations= 0;\n    while(input_number)\n    {\n        totalOperations+= input_number % 2;\n        input_number/= 2;\n    }\n    return totalOperations;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int modulo = 1e9 + 7;\n\nint countSquareFreeSubsets(vector<int> &inputNumbers)\n{\n    unordered_map<int, int> frequencyCounter;\n    for (int number : inputNumbers)\n    {\n        frequencyCounter[number]++;\n    }\n\n    vector<vector<long long>> dynamicProgramming(61, vector<long long>(1001));\n    dynamicProgramming[0][0] = 1;\n    int currentIndex = 0;\n    for (auto it = frequencyCounter.begin(); it != frequencyCounter.end(); ++it)\n    {\n        const int number = it->first;\n        const int frequency = it->second;\n        currentIndex++;\n        for (int squareCount = 0; squareCount <= 60; squareCount++)\n        {\n            for (int nonSquareCount = 0; nonSquareCount + frequency <= 1000; nonSquareCount++)\n            {\n                dynamicProgramming[currentIndex][nonSquareCount + frequency] += dynamicProgramming[currentIndex - 1][nonSquareCount] * ((1LL << frequency) - 1) % modulo;\n                dynamicProgramming[currentIndex][nonSquareCount + frequency] %= modulo;\n                dynamicProgramming[currentIndex][nonSquareCount] += dynamicProgramming[currentIndex - 1][nonSquareCount];\n                dynamicProgramming[currentIndex][nonSquareCount] %= modulo;\n\n                if ((squareCount / number) % 2 == 1)\n                {\n                    dynamicProgramming[currentIndex][nonSquareCount + frequency] -= dynamicProgramming[currentIndex - 1][nonSquareCount] * ((1LL << (frequency - 1)) - 1) % modulo;\n                    if (dynamicProgramming[currentIndex][nonSquareCount + frequency] < 0)\n                        dynamicProgramming[currentIndex][nonSquareCount + frequency] += modulo;\n                }\n            }\n        }\n    }\n    return dynamicProgramming[currentIndex][0];\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nconst int modulo= 1e9 + 7;\n\nint CountSquareFreeSubsets(std::vector<int> &input_numbers)\n{\n    std::unordered_map<int, int> frequencyCounter;\n    for(int number : input_numbers)\n    {\n        frequencyCounter[number]++;\n    }\n\n    std::vector<std::vector<long long>> dynamicProgramming(61, std::vector<long long>(1001));\n    dynamicProgramming[0][0]= 1;\n    int currentIndex= 0;\n    for(const auto &[number, frequency] : frequencyCounter)\n    {\n        currentIndex++;\n        for(int square_count= 0; square_count <= 60; square_count++)\n        {\n            for(int non_square_count= 0; non_square_count + frequency <= 1000; non_square_count++)\n            {\n                dynamicProgramming[currentIndex][non_square_count + frequency]+= dynamicProgramming[currentIndex - 1][non_square_count] * ((1LL << frequency) - 1) % modulo;\n                dynamicProgramming[currentIndex][non_square_count + frequency]%= modulo;\n                dynamicProgramming[currentIndex][non_square_count]+= dynamicProgramming[currentIndex - 1][non_square_count];\n                dynamicProgramming[currentIndex][non_square_count]%= modulo;\n\n                if((square_count / number) % 2 == 1)\n                {\n                    dynamicProgramming[currentIndex][non_square_count + frequency]-= dynamicProgramming[currentIndex - 1][non_square_count] * ((1LL << (frequency - 1)) - 1) % modulo;\n                    if(dynamicProgramming[currentIndex][non_square_count + frequency] < 0)\n                        dynamicProgramming[currentIndex][non_square_count + frequency]+= modulo;\n                }\n            }\n        }\n    }\n    return dynamicProgramming[currentIndex][0];\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring smallestWordForLCP(vector<vector<int>> &longestCommonPrefix)\n{\n    int matrixSize = longestCommonPrefix.size();\n    string resultWord(matrixSize, 'a');\n    for(int rowIndex = 1; rowIndex < matrixSize; ++rowIndex)\n        for(int colIndex = 1; colIndex < matrixSize; ++colIndex)\n        {\n            if(longestCommonPrefix[rowIndex][colIndex] > min(longestCommonPrefix[rowIndex - 1][colIndex], longestCommonPrefix[rowIndex][colIndex - 1]))\n            {\n                resultWord[rowIndex + longestCommonPrefix[rowIndex][colIndex] - 1] = max(resultWord[rowIndex + longestCommonPrefix[rowIndex][colIndex] - 1], (char)(resultWord[rowIndex - 1] + 1));\n            }\n            else if(longestCommonPrefix[rowIndex][colIndex] < min(longestCommonPrefix[rowIndex - 1][colIndex], longestCommonPrefix[rowIndex][colIndex - 1]))\n            {\n                return \"\";\n            }\n        }\n    return resultWord;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nstd::string SmallestWordForLCP(std::vector<std::vector<int>> &longest_common_prefix)\n{\n    int matrixSize= longest_common_prefix.size();\n    std::string resultWord(matrixSize, 'a');\n    for(int rowIndex= 1; rowIndex < matrixSize; ++rowIndex)\n        for(int colIndex= 1; colIndex < matrixSize; ++colIndex)\n        {\n            if(longest_common_prefix[rowIndex][colIndex] > std::min(longest_common_prefix[rowIndex - 1][colIndex], longest_common_prefix[rowIndex][colIndex - 1]))\n            {\n                resultWord[rowIndex + longest_common_prefix[rowIndex][colIndex] - 1]= std::max(resultWord[rowIndex + longest_common_prefix[rowIndex][colIndex] - 1], (char)(resultWord[rowIndex - 1] + 1));\n            }\n            else if(longest_common_prefix[rowIndex][colIndex] < std::min(longest_common_prefix[rowIndex - 1][colIndex], longest_common_prefix[rowIndex][colIndex - 1]))\n            {\n                return \"\";\n            }\n        }\n    return resultWord;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> getAnswer(vector<int> &inputNumbers)\n{\n    int size= inputNumbers.size();\n    vector<int> leftSum(size, 0), rightSum(size, 0), result(size, 0);\n\n    for(int index= 1; index < size; index++)\n    {\n        leftSum[index]= leftSum[index - 1] + inputNumbers[index - 1];\n    }\n\n    for(int index= size - 2; index >= 0; index--)\n    {\n        rightSum[index]= rightSum[index + 1] + inputNumbers[index + 1];\n    }\n\n    for(int index= 0; index < size; index++)\n    {\n        result[index]= abs(leftSum[index] - rightSum[index]);\n    }\n\n    return result;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> GetAnswer(std::vector<int> &input_numbers)\n{\n    int size= input_numbers.size();\n    std::vector<int> leftSum(size, 0), rightSum(size, 0), result(size, 0);\n\n    for(int index= 1; index < size; index++)\n    {\n        leftSum[index]= leftSum[index - 1] + input_numbers[index - 1];\n    }\n\n    for(int index= size - 2; index >= 0; index--)\n    {\n        rightSum[index]= rightSum[index + 1] + input_numbers[index + 1];\n    }\n\n    for(int index= 0; index < size; index++)\n    {\n        result[index]= std::abs(leftSum[index] - rightSum[index]);\n    }\n\n    return result;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> divisibilityArray(string numberString, int divisor)\n{\n    vector<int> divisibilityResults(numberString.size());\n    int currentValue= 0;\n    for(size_t index= 0; index < numberString.length(); ++index)\n    {\n        currentValue= (currentValue * 10 + (numberString[index] - '0')) % divisor;\n        divisibilityResults[index]= (currentValue == 0) ? 1 : 0;\n    }\n    return divisibilityResults;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> DivisibilityArray(std::string number_string, int divisor)\n{\n    std::vector<int> divisibilityResults(number_string.size());\n    int currentValue= 0;\n    for(size_t index= 0; index < number_string.length(); ++index)\n    {\n        currentValue= (currentValue * 10 + (number_string[index] - '0')) % divisor;\n        divisibilityResults[index]= (currentValue == 0) ? 1 : 0;\n    }\n    return divisibilityResults;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minTime(vector<vector<int>> &grid)\n{\n    int rows= grid.size(), columns= grid[0].size();\n    vector<vector<int>> visited(rows, vector<int>(columns, 1000000));\n\n    const int directionX[]= {-1, 0, 1, 0};\n    const int directionY[]= {0, 1, 0, -1};\n\n    visited[0][0]= 0;\n\n    queue<pair<int, int>> positionQueue;\n    positionQueue.push({0, 0});\n\n    while(!positionQueue.empty())\n    {\n        auto [currentX, currentY]= positionQueue.front();\n        positionQueue.pop();\n\n        for(int i= 0; i < 4; i++)\n        {\n            int nextX= currentX + directionX[i];\n            int nextY= currentY + directionY[i];\n\n            if(nextX >= 0 && nextX < rows && nextY >= 0 && nextY < columns)\n            {\n                int time= max(grid[nextX][nextY], visited[currentX][currentY] + 1);\n                if(visited[nextX][nextY] > time)\n                {\n                    visited[nextX][nextY]= time;\n                    positionQueue.push({nextX, nextY});\n                }\n            }\n        }\n    }\n\n    return visited[rows - 1][columns - 1] == 1000000 ? -1 : visited[rows - 1][columns - 1];\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint MinTime(std::vector<std::vector<int>> &grid)\n{\n    int rows= grid.size(), columns= grid[0].size();\n    std::vector<std::vector<int>> visited(rows, std::vector<int>(columns, 1000000));\n\n    const int directionX[]= {-1, 0, 1, 0};\n    const int directionY[]= {0, 1, 0, -1};\n\n    visited[0][0]= 0;\n\n    std::queue<std::pair<int, int>> positionQueue;\n    positionQueue.push({0, 0});\n\n    while(!positionQueue.empty())\n    {\n        auto [currentX, currentY]= positionQueue.front();\n        positionQueue.pop();\n\n        for(int i= 0; i < 4; i++)\n        {\n            int nextX= currentX + directionX[i];\n            int nextY= currentY + directionY[i];\n\n            if(nextX >= 0 && nextX < rows && nextY >= 0 && nextY < columns)\n            {\n                int time= std::max(grid[nextX][nextY], visited[currentX][currentY] + 1);\n                if(visited[nextX][nextY] > time)\n                {\n                    visited[nextX][nextY]= time;\n                    positionQueue.push({nextX, nextY});\n                }\n            }\n        }\n    }\n\n    return visited[rows - 1][columns - 1] == 1000000 ? -1 : visited[rows - 1][columns - 1];\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMinSumOfTwoNumbers(string inputNumber)\n{\n    vector<int> digitCount(10, 0);\n    for (char digit : inputNumber)\n        digitCount[digit - '0']++;\n\n    int firstNumber = 0, secondNumber = 0;\n    for (int i = 1; i <= 9; i += 2)\n    {\n        int count = digitCount[i];\n        while (count--)\n            firstNumber = firstNumber * 10 + i;\n    }\n    for (int i = 0; i <= 9; i += 2)\n    {\n        int count = digitCount[i];\n        while (count--)\n            secondNumber = secondNumber * 10 + i;\n    }\n    return firstNumber + secondNumber;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint CalculateMinSumOfTwoNumbers(std::string input_number)\n{\n    std::vector<int> digitCount(10, 0);\n    for(char digit : input_number)\n        digitCount[digit - '0']++;\n\n    int firstNumber= 0, secondNumber= 0;\n    for(int i= 1; i <= 9; i+= 2)\n    {\n        int count= digitCount[i];\n        while(count--)\n            firstNumber= firstNumber * 10 + i;\n    }\n    for(int i= 0; i <= 9; i+= 2)\n    {\n        int count= digitCount[i];\n        while(count--)\n            secondNumber= secondNumber * 10 + i;\n    }\n    return firstNumber + secondNumber;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint calculateColoredCells(int gridSize)\n{\n    return gridSize * gridSize + (gridSize - 1) * (gridSize - 1);\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int CalculateColoredCells(int grid_size)\n{\n    return grid_size * grid_size + (grid_size - 1) * (grid_size - 1);\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int modulo = 1e9 + 7;\n\nint totalWaysToSplitRanges(vector<vector<int>> &ranges)\n{\n    sort(ranges.begin(), ranges.end(), [](const vector<int> &firstRange, const vector<int> &secondRange)\n         { return firstRange[1] < secondRange[1]; });\n    int overlappingCount = 0, nonOverlappingCount = 1, previousEnd = -1;\n    for (int i = 0; i < ranges.size(); ++i)\n    {\n        const auto &currentRange = ranges[i];\n        if (currentRange[0] <= previousEnd)\n        {\n            overlappingCount++;\n        }\n        else\n        {\n            nonOverlappingCount++;\n        }\n        previousEnd = max(previousEnd, currentRange[1]);\n    }\n    long result = 1;\n    for (int i = 1; i <= overlappingCount; ++i)\n    {\n        result = (result * 2) % modulo;\n    }\n    return result;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nconst int modulo= 1e9 + 7;\n\nint TotalWaysToSplitRanges(std::vector<std::vector<int>> &ranges)\n{\n    std::sort(ranges.begin(), ranges.end(), [](const std::vector<int> &first_range, const std::vector<int> &second_range)\n              { return first_range[1] < second_range[1]; });\n    int overlapping_count= 0, non_overlapping_count= 1, previous_end= -1;\n    for(const auto &current_range : ranges)\n    {\n        if(current_range[0] <= previous_end)\n        {\n            overlapping_count++;\n        }\n        else\n        {\n            non_overlapping_count++;\n        }\n        previous_end= std::max(previous_end, current_range[1]);\n    }\n    long result= 1;\n    for(int i= 1; i <= overlapping_count; ++i)\n    {\n        result= (result * 2) % modulo;\n    }\n    return result;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint possibleRoots(const vector<vector<int>> &edges, const vector<vector<int>> &guesses, int k)\n{\n    int nodeCount = edges.size() + 1;\n    vector<int> inDegree(nodeCount, 0);\n    unordered_set<int> guessParents;\n\n    for (int i = 0; i < guesses.size(); ++i)\n    {\n        guessParents.insert(guesses[i][0]);\n    }\n\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        inDegree[edges[i][1]]++;\n    }\n\n    int possibleRootsCount = 0;\n    for (int i = 0; i < nodeCount; ++i)\n    {\n        if (inDegree[i] == 0)\n        {\n            if (k == 0 || guessParents.find(i) != guessParents.end())\n            {\n                possibleRootsCount++;\n            }\n        }\n        else if (inDegree[i] == 1 && guesses.size() - k < inDegree[i])\n        {\n            possibleRootsCount++;\n        }\n    }\n    return possibleRootsCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint PossibleRoots(const std::vector<std::vector<int>> &edges, const std::vector<std::vector<int>> &guesses, int k)\n{\n    int nodeCount= edges.size() + 1;\n    std::vector<int> inDegree(nodeCount, 0);\n    std::unordered_set<int> guess_parents;\n\n    for(const auto &guess : guesses)\n    {\n        guess_parents.insert(guess[0]);\n    }\n\n    for(const auto &edge : edges)\n    {\n        inDegree[edge[1]]++;\n    }\n\n    int possibleRootsCount= 0;\n    for(int i= 0; i < nodeCount; ++i)\n    {\n        if(inDegree[i] == 0)\n        {\n            if(k == 0 || guess_parents.find(i) != guess_parents.end())\n            {\n                possibleRootsCount++;\n            }\n        }\n        else if(inDegree[i] == 1 && guesses.size() - k < inDegree[i])\n        {\n            possibleRootsCount++;\n        }\n    }\n    return possibleRootsCount;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint calculatePillowPosition(int numberOfPillows, int time)\n{\n    time%= (2 * numberOfPillows - 2);\n    if(time <= numberOfPillows - 1)\n        return time + 1;\n    else\n        return 2 * numberOfPillows - time - 1;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int CalculatePillowPosition(int number_of_pillows, int time)\n{\n    time%= (2 * number_of_pillows - 2);\n    if(time <= number_of_pillows - 1)\n        return time + 1;\n    else\n        return 2 * number_of_pillows - time - 1;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nint kthLargestLevelSum(TreeNode *rootNode, int k)\n{\n    vector<int> levelSums;\n    queue<TreeNode *> nodeQueue;\n    nodeQueue.push(rootNode);\n\n    while(!nodeQueue.empty())\n    {\n        int levelSum= 0;\n        int levelSize= nodeQueue.size();\n        for(int i= 0; i < levelSize; ++i)\n        {\n            TreeNode *currentNode= nodeQueue.front();\n            nodeQueue.pop();\n            levelSum+= currentNode->value;\n\n            if(currentNode->leftChild)\n                nodeQueue.push(currentNode->leftChild);\n            if(currentNode->rightChild)\n                nodeQueue.push(currentNode->rightChild);\n        }\n\n        levelSums.push_back(levelSum);\n    }\n\n    sort(levelSums.begin(), levelSums.end(), greater<int>());\n    return (k > levelSums.size() ? -1 : levelSums[k - 1]);\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nint KthLargestLevelSum(TreeNode *root_node, int k)\n{\n    std::vector<int> levelSums;\n    std::queue<TreeNode *> nodeQueue;\n    nodeQueue.push(root_node);\n\n    while(!nodeQueue.empty())\n    {\n        int levelSum= 0;\n        int levelSize= nodeQueue.size();\n        for(int i= 0; i < levelSize; ++i)\n        {\n            TreeNode *currentNode= nodeQueue.front();\n            nodeQueue.pop();\n            levelSum+= currentNode->value;\n\n            if(currentNode->leftChild)\n                nodeQueue.push(currentNode->leftChild);\n            if(currentNode->rightChild)\n                nodeQueue.push(currentNode->rightChild);\n        }\n\n        levelSums.push_back(levelSum);\n    }\n\n    std::sort(levelSums.begin(), levelSums.end(), std::greater<int>());\n    return (k > levelSums.size() ? -1 : levelSums[k - 1]);\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint gcd(int firstNumber, int secondNumber)\n{\n    return secondNumber == 0 ? firstNumber : gcd(secondNumber, firstNumber % secondNumber);\n}\n\nint findValidSplit(const vector<int> &numberList)\n{\n    int length= numberList.size();\n    vector<int> prefixProduct(length);\n    vector<int> suffixProduct(length);\n\n    prefixProduct[0]= numberList[0];\n    suffixProduct[length - 1]= numberList[length - 1];\n\n    for(int index= 1; index < length; ++index)\n        prefixProduct[index]= prefixProduct[index - 1] * numberList[index];\n\n    for(int index= length - 2; index >= 0; --index)\n        suffixProduct[index]= suffixProduct[index + 1] * numberList[index];\n\n    for(int index= 0; index < length - 1; ++index)\n    {\n        if(gcd(prefixProduct[index], suffixProduct[index + 1]) == 1)\n            return index;\n    }\n\n    return -1;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint Gcd(int first_number, int second_number)\n{\n    return second_number == 0 ? first_number : Gcd(second_number, first_number % second_number);\n}\n\nint FindValidSplit(const std::vector<int> &number_list)\n{\n    int length= number_list.size();\n    std::vector<int> prefix_product(length);\n    std::vector<int> suffix_product(length);\n\n    prefix_product[0]= number_list[0];\n    suffix_product[length - 1]= number_list[length - 1];\n\n    for(int index= 1; index < length; ++index)\n        prefix_product[index]= prefix_product[index - 1] * number_list[index];\n\n    for(int index= length - 2; index >= 0; --index)\n        suffix_product[index]= suffix_product[index + 1] * number_list[index];\n\n    for(int index= 0; index < length - 1; ++index)\n    {\n        if(Gcd(prefix_product[index], suffix_product[index + 1]) == 1)\n            return index;\n    }\n\n    return -1;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int modulo = 1e9 + 7;\n\nint numberOfWays(int target, vector<vector<int>> &itemTypes)\n{\n    vector<int> dynamicProgramming(target + 1, 0);\n    dynamicProgramming[0] = 1;\n    for (int i = 0; i < itemTypes.size(); ++i)\n    {\n        auto &itemType = itemTypes[i];\n        int itemCount = itemType[0], itemMarks = itemType[1];\n        vector<int> tempDynamicProgramming(target + 1, 0);\n        for (int currentScore = 0; currentScore <= target; ++currentScore)\n        {\n            for (int itemUsed = 0; itemUsed <= itemCount && itemUsed * itemMarks + currentScore <= target; ++itemUsed)\n            {\n                tempDynamicProgramming[currentScore + itemUsed * itemMarks] = (tempDynamicProgramming[currentScore + itemUsed * itemMarks] + dynamicProgramming[currentScore]) % modulo;\n            }\n        }\n        dynamicProgramming = tempDynamicProgramming;\n    }\n    return dynamicProgramming[target];\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nconst int modulo = 1e9 + 7;\n\nint NumberOfWays(int target, std::vector<std::vector<int>> &item_types)\n{\n    std::vector<int> dynamicProgramming(target + 1, 0);\n    dynamicProgramming[0] = 1;\n    for(auto &itemType : item_types)\n    {\n        int itemCount = itemType[0], itemMarks = itemType[1];\n        std::vector<int> tempDynamicProgramming(target + 1, 0);\n        for(int currentScore = 0; currentScore <= target; ++currentScore)\n        {\n            for(int itemUsed = 0; itemUsed <= itemCount && itemUsed * itemMarks + currentScore <= target; ++itemUsed)\n            {\n                tempDynamicProgramming[currentScore + itemUsed * itemMarks] = (tempDynamicProgramming[currentScore + itemUsed * itemMarks] + dynamicProgramming[currentScore]) % modulo;\n            }\n        }\n        dynamicProgramming = tempDynamicProgramming;\n    }\n    return dynamicProgramming[target];\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isVowel(char character)\n{\n    return character == 'a' || character == 'e' || character == 'i' || character == 'o' || character == 'u';\n}\n\nint countVowelStrings(vector<string> &words, int leftIndex, int rightIndex)\n{\n    int vowelCount= 0;\n    for(int index= leftIndex; index <= rightIndex; index++)\n    {\n        if(isVowel(words[index][0]) && isVowel(words[index][words[index].length() - 1]))\n        {\n            vowelCount++;\n        }\n    }\n    return vowelCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nbool IsVowel(char character)\n{\n    return character == 'a' || character == 'e' || character == 'i' || character == 'o' || character == 'u';\n}\n\nint CountVowelStrings(std::vector<std::string> &words, int left_index, int right_index)\n{\n    int vowelCount= 0;\n    for(int index= left_index; index <= right_index; index++)\n    {\n        if(IsVowel(words[index][0]) && IsVowel(words[index][words[index].length() - 1]))\n        {\n            vowelCount++;\n        }\n    }\n    return vowelCount;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxScore(vector<int> &scores)\n{\n    sort(scores.begin(), scores.end());\n    int count= 0, totalPrefixSum= 0;\n    for(int index= 0; index < scores.size(); ++index)\n    {\n        if(totalPrefixSum + scores[index] > 0)\n        {\n            ++count;\n            totalPrefixSum+= scores[index];\n        }\n    }\n    return count;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint MaxScore(std::vector<int> &scores)\n{\n    std::sort(scores.begin(), scores.end());\n    int count= 0, totalPrefixSum= 0;\n    for(int index= 0; index < scores.size(); ++index)\n    {\n        if(totalPrefixSum + scores[index] > 0)\n        {\n            ++count;\n            totalPrefixSum+= scores[index];\n        }\n    }\n    return count;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countBeautifulSubarrays(vector<int> &inputNumbers)\n{\n    vector<int> oddCount(20, 0);\n    vector<int> evenCount(20, 0);\n    evenCount[0] = 1;\n\n    for (int i = 0; i < inputNumbers.size(); ++i)\n    {\n        int currentNumber = inputNumbers[i];\n        bool isOdd = __builtin_parity(currentNumber);\n        for (int j = 19; j >= 0; j--)\n        {\n            int bitMask = 1 << j;\n            if (currentNumber & bitMask)\n            {\n                if (isOdd)\n                    swap(oddCount[j], evenCount[j]);\n                oddCount[j]++;\n            }\n            else\n            {\n                if (!isOdd)\n                    swap(oddCount[j], evenCount[j]);\n                evenCount[j]++;\n            }\n            currentNumber -= (currentNumber & bitMask);\n        }\n    }\n\n    long long result = 0;\n    for (int i = 0; i < 20; i++)\n        result += (long long)evenCount[i] * (evenCount[i] - 1) / 2;\n    return result;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint CountBeautifulSubarrays(std::vector<int> &input_numbers)\n{\n    std::vector<int> oddCount(20, 0);\n    std::vector<int> evenCount(20, 0);\n    evenCount[0] = 1;\n\n    for(int currentNumber : input_numbers)\n    {\n        bool isOdd = __builtin_parity(currentNumber);\n        for(int i = 19; i >= 0; i--)\n        {\n            int bitMask = 1 << i;\n            if(currentNumber & bitMask)\n            {\n                if(isOdd)\n                    std::swap(oddCount[i], evenCount[i]);\n                oddCount[i]++;\n            }\n            else\n            {\n                if(!isOdd)\n                    std::swap(oddCount[i], evenCount[i]);\n                evenCount[i]++;\n            }\n            currentNumber -= (currentNumber & bitMask);\n        }\n    }\n\n    long long result = 0;\n    for(int i = 0; i < 20; i++)\n        result += (long long)evenCount[i] * (evenCount[i] - 1) / 2;\n    return result;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minTimeOn(vector<vector<int>> &taskList)\n{\n    vector<vector<int>> timeIntervals;\n    for (int i = 0; i < taskList.size(); ++i)\n    {\n        const auto &task = taskList[i];\n        timeIntervals.push_back({task[1] + 1, task[2]});\n    }\n    sort(timeIntervals.begin(), timeIntervals.end());\n\n    vector<int> dynamicProgramming(2001, 0);\n    for (int i = 0; i < timeIntervals.size(); ++i)\n    {\n        const auto &interval = timeIntervals[i];\n        for (int time = 2000; time >= interval[0]; --time)\n        {\n            dynamicProgramming[time] = max(dynamicProgramming[time], dynamicProgramming[time - interval[1]] + interval[1]);\n        }\n    }\n    return dynamicProgramming.back();\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint MinTimeOn(std::vector<std::vector<int>> &task_list)\n{\n    std::vector<std::vector<int>> timeIntervals;\n    for(const auto &task : task_list)\n    {\n        timeIntervals.push_back({task[1] + 1, task[2]});\n    }\n    std::sort(timeIntervals.begin(), timeIntervals.end());\n\n    std::vector<int> dynamicProgramming(2001, 0);\n    for(const auto &interval : timeIntervals)\n    {\n        for(int time= 2000; time >= interval[0]; --time)\n        {\n            dynamicProgramming[time]= std::max(dynamicProgramming[time], dynamicProgramming[time - interval[1]] + interval[1]);\n        }\n    }\n    return dynamicProgramming.back();\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nclass TodoList\n{\n  public:\n    struct Task\n    {\n        int id;\n        string description;\n        int dueDate;\n        vector<string> tags;\n        bool isCompleted;\n\n        Task(int taskId, const string &taskDesc, int taskDueDate, const vector<string> &taskTags)\n            : id(taskId), description(taskDesc), dueDate(taskDueDate), tags(taskTags), isCompleted(false) {}\n    };\n\n    TodoList() : taskId(1) {}\n\n    int addTask(int userId, string taskDescription, int dueDate, vector<string> tags)\n    {\n        tasks[userId].emplace_back(taskId, taskDescription, dueDate, tags);\n        return taskId++;\n    }\n\n    vector<string> getAllTasks(int userId)\n    {\n        vector<string> result;\n        vector<Task> &userTasks = tasks[userId];\n\n        sort(userTasks.begin(), userTasks.end(), [](const Task &a, const Task &b)\n             { return a.dueDate < b.dueDate; });\n\n        for (size_t i = 0; i < userTasks.size(); ++i)\n        {\n            const auto &task = userTasks[i];\n            if (!task.isCompleted)\n            {\n                result.push_back(task.description);\n            }\n        }\n\n        return result;\n    }\n\n    vector<string> getTasksForTag(int userId, string tag)\n    {\n        vector<string> result;\n        vector<Task> &userTasks = tasks[userId];\n\n        sort(userTasks.begin(), userTasks.end(), [](const Task &a, const Task &b)\n             { return a.dueDate < b.dueDate; });\n\n        for (size_t i = 0; i < userTasks.size(); ++i)\n        {\n            const auto &task = userTasks[i];\n            if (!task.isCompleted && find(task.tags.begin(), task.tags.end(), tag) != task.tags.end())\n            {\n                result.push_back(task.description);\n            }\n        }\n\n        return result;\n    }\n\n    void completeTask(int userId, int taskId)\n    {\n        vector<Task> &userTasks = tasks[userId];\n        for (size_t i = 0; i < userTasks.size(); ++i)\n        {\n            auto &task = userTasks[i];\n            if (task.id == taskId)\n            {\n                task.isCompleted = true;\n                break;\n            }\n        }\n    }\n\n  private:\n    int taskId;\n    map<int, vector<Task>> tasks;\n};### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nclass TodoList\n{\n  public:\n    struct Task\n    {\n        int id;\n        std::string description;\n        int dueDate;\n        std::vector<std::string> tags;\n        bool isCompleted;\n\n        Task(int task_id, const std::string &task_desc, int task_due_date, const std::vector<std::string> &task_tags)\n            : id(task_id), description(task_desc), dueDate(task_due_date), tags(task_tags), isCompleted(false) {}\n    };\n\n    TodoList() : taskId(1) {}\n\n    int AddTask(int user_id, std::string task_description, int due_date, std::vector<std::string> tags)\n    {\n        tasks[user_id].emplace_back(taskId, task_description, due_date, tags);\n        return taskId++;\n    }\n\n    std::vector<std::string> GetAllTasks(int user_id)\n    {\n\n        std::vector<std::string> result;\n        std::vector<Task> &userTasks= tasks[user_id];\n\n        std::sort(userTasks.begin(), userTasks.end(), [](const Task &a, const Task &b)\n                  { return a.dueDate < b.dueDate; });\n\n        for(const auto &task : userTasks)\n        {\n            if(!task.isCompleted)\n            {\n                result.push_back(task.description);\n            }\n        }\n\n        return result;\n    }\n\n    std::vector<std::string> GetTasksForTag(int user_id, std::string tag)\n    {\n        std::vector<std::string> result;\n        std::vector<Task> &userTasks= tasks[user_id];\n\n        std::sort(userTasks.begin(), userTasks.end(), [](const Task &a, const Task &b)\n                  { return a.dueDate < b.dueDate; });\n\n        for(const auto &task : userTasks)\n        {\n            if(!task.isCompleted && std::find(task.tags.begin(), task.tags.end(), tag) != task.tags.end())\n            {\n                result.push_back(task.description);\n            }\n        }\n\n        return result;\n    }\n\n    void CompleteTask(int user_id, int task_id)\n    {\n        std::vector<Task> &userTasks= tasks[user_id];\n        for(auto &task : userTasks)\n        {\n            if(task.id == task_id)\n            {\n                task.isCompleted= true;\n                break;\n            }\n        }\n    }\n\n  private:\n    int taskId;\n    std::map<int, std::vector<Task>> tasks;\n};"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint maximumChildrenWithEightDollars(int totalMoney, int totalChildren)\n{\n    if(totalMoney < totalChildren * 1 || totalMoney > totalChildren * 8)\n        return -1;\n    int maxEights= (totalMoney - totalChildren) / 7;\n    return maxEights >= totalChildren ? totalChildren : maxEights;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int MaximumChildrenWithEightDollars(int total_money, int total_children)\n{\n    if(total_money < total_children * 1 || total_money > total_children * 8)\n        return -1;\n    int maxEights= (total_money - total_children) / 7;\n    return maxEights >= total_children ? total_children : maxEights;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMaxGreatness(vector<int> &numberList)\n{\n    sort(numberList.begin(), numberList.end());\n    int totalGreatness= 0;\n    for(int index= 1; index < numberList.size(); ++index)\n    {\n        if(numberList[index - 1] < numberList[index])\n        {\n            swap(numberList[index - 1], numberList[index]);\n            ++totalGreatness;\n        }\n    }\n    return totalGreatness;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint CalculateMaxGreatness(std::vector<int> &number_list)\n{\n    std::sort(number_list.begin(), number_list.end());\n    int totalGreatness = 0;\n    for(int index = 1; index < number_list.size(); ++index)\n    {\n        if(number_list[index - 1] < number_list[index])\n        {\n            std::swap(number_list[index - 1], number_list[index]);\n            ++totalGreatness;\n        }\n    }\n    return totalGreatness;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateScore(vector<int> &scoreList)\n{\n    int scoreCount= scoreList.size();\n    vector<int> dp(scoreCount + 2, 0);\n\n    for(int index= 0; index < scoreCount; ++index)\n    {\n        dp[index + 2]= max(dp[index + 1], dp[index] + scoreList[index]);\n    }\n\n    return dp[scoreCount + 1];\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint CalculateScore(std::vector<int> &score_list)\n{\n    int scoreCount= score_list.size();\n    std::vector<int> dp(scoreCount + 2, 0);\n\n    for(int index= 0; index < scoreCount; ++index)\n    {\n        dp[index + 2]= std::max(dp[index + 1], dp[index] + score_list[index]);\n    }\n\n    return dp[scoreCount + 1];\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minTimeToRepair(vector<int> &repairRanks, int totalCars)\n{\n    sort(repairRanks.begin(), repairRanks.end());\n    int lowerBound = 0, upperBound = 100 * totalCars * totalCars;\n    while (lowerBound < upperBound)\n    {\n        int midPoint = lowerBound + (upperBound - lowerBound) / 2;\n        int totalCarsRepaired = 0;\n        for (int i = 0; i < repairRanks.size(); ++i)\n        {\n            int rank = repairRanks[i];\n            int carsRepaired = min(totalCars, midPoint / (rank * rank));\n            totalCarsRepaired += carsRepaired;\n            if (totalCarsRepaired >= totalCars)\n                break;\n        }\n        if (totalCarsRepaired >= totalCars)\n            upperBound = midPoint;\n        else\n            lowerBound = midPoint + 1;\n    }\n    return lowerBound;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint MinTimeToRepair(std::vector<int> &repair_ranks, int total_cars)\n{\n    std::sort(repair_ranks.begin(), repair_ranks.end());\n    int lowerBound= 0, upperBound= 100 * total_cars * total_cars;\n    while(lowerBound < upperBound)\n    {\n        int midPoint= lowerBound + (upperBound - lowerBound) / 2;\n        int totalCarsRepaired= 0;\n        for(int rank : repair_ranks)\n        {\n            int carsRepaired= std::min(total_cars, midPoint / (rank * rank));\n            totalCarsRepaired+= carsRepaired;\n            if(totalCarsRepaired >= total_cars)\n                break;\n        }\n        if(totalCarsRepaired >= total_cars)\n            upperBound= midPoint;\n        else\n            lowerBound= midPoint + 1;\n    }\n    return lowerBound;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countEvenOddIndices(int inputNumber)\n{\n    vector<int> count(2, 0);\n    int currentIndex= 0;\n    while(inputNumber > 0)\n    {\n        if(inputNumber % 2)\n            count[currentIndex % 2]+= 1;\n        inputNumber/= 2;\n        currentIndex+= 1;\n    }\n    return count;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> CountEvenOddIndices(int input_number)\n{\n    std::vector<int> count(2, 0);\n    int currentIndex= 0;\n    while(input_number > 0)\n    {\n        if(input_number % 2)\n            count[currentIndex % 2]+= 1;\n        input_number/= 2;\n        currentIndex+= 1;\n    }\n    return count;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isValidMove(int currentRow, int currentCol, int nextValue, int gridSize)\n{\n    return (currentRow + 1 < gridSize && currentCol + 2 < gridSize && nextValue == gridSize * (currentRow + 1) + (currentCol + 2)) ||\n           (currentRow + 1 < gridSize && currentCol - 2 >= 0 && nextValue == gridSize * (currentRow + 1) + (currentCol - 2)) ||\n           (currentRow + 2 < gridSize && currentCol + 1 < gridSize && nextValue == gridSize * (currentRow + 2) + (currentCol + 1)) ||\n           (currentRow + 2 < gridSize && currentCol - 1 >= 0 && nextValue == gridSize * (currentRow + 2) + (currentCol - 1));\n}\n\nbool validPath(vector<vector<int>> &grid)\n{\n    int gridSize= grid.size();\n    for(int rowIndex= 0; rowIndex < gridSize; rowIndex++)\n    {\n        for(int colIndex= 0; colIndex < gridSize; colIndex++)\n        {\n            int currentValue= grid[rowIndex][colIndex];\n            if(currentValue != gridSize * gridSize - 1 && !isValidMove(rowIndex, colIndex, currentValue + 1, gridSize))\n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nbool IsValidMove(int current_row, int current_col, int next_value, int grid_size)\n{\n    return (current_row + 1 < grid_size && current_col + 2 < grid_size && next_value == grid_size * (current_row + 1) + (current_col + 2)) ||\n           (current_row + 1 < grid_size && current_col - 2 >= 0 && next_value == grid_size * (current_row + 1) + (current_col - 2)) ||\n           (current_row + 2 < grid_size && current_col + 1 < grid_size && next_value == grid_size * (current_row + 2) + (current_col + 1)) ||\n           (current_row + 2 < grid_size && current_col - 1 >= 0 && next_value == grid_size * (current_row + 2) + (current_col - 1));\n}\n\nbool ValidPath(std::vector<std::vector<int>> &grid)\n{\n    int gridSize= grid.size();\n    for(int rowIndex= 0; rowIndex < gridSize; rowIndex++)\n    {\n        for(int colIndex= 0; colIndex < gridSize; colIndex++)\n        {\n            int currentValue= grid[rowIndex][colIndex];\n            if(currentValue != gridSize * gridSize - 1 && !IsValidMove(rowIndex, colIndex, currentValue + 1, gridSize))\n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countBeautifulSubsets(vector<int> &numberList, int differenceThreshold)\n{\n    sort(numberList.begin(), numberList.end());\n    int totalCount= 0;\n    vector<int> dynamicProgramming(numberList.size(), 1);\n    for(int currentIndex= 0; currentIndex < numberList.size(); currentIndex++)\n    {\n        for(int previousIndex= 0, leftPointer= 0, rightPointer= -1; previousIndex < currentIndex; previousIndex++)\n        {\n            while(leftPointer < previousIndex && numberList[previousIndex] - numberList[leftPointer] >= differenceThreshold)\n                leftPointer++;\n            while(rightPointer + 1 < previousIndex && numberList[rightPointer + 1] - numberList[previousIndex] < differenceThreshold)\n                rightPointer++;\n            if(leftPointer <= rightPointer)\n                dynamicProgramming[previousIndex]-= dynamicProgramming[leftPointer - 1];\n            dynamicProgramming[previousIndex]+= dynamicProgramming[previousIndex - 1] + 1;\n            totalCount+= dynamicProgramming[previousIndex];\n        }\n    }\n    return totalCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint CountBeautifulSubsets(std::vector<int> &number_list, int difference_threshold)\n{\n    std::sort(number_list.begin(), number_list.end());\n    int totalCount = 0;\n    std::vector<int> dynamicProgramming(number_list.size(), 1);\n    for(int currentIndex = 0; currentIndex < number_list.size(); currentIndex++)\n    {\n        for(int previousIndex = 0, leftPointer = 0, rightPointer = -1; previousIndex < currentIndex; previousIndex++)\n        {\n            while(leftPointer < previousIndex && number_list[previousIndex] - number_list[leftPointer] >= difference_threshold)\n                leftPointer++;\n            while(rightPointer + 1 < previousIndex && number_list[rightPointer + 1] - number_list[previousIndex] < difference_threshold)\n                rightPointer++;\n            if(leftPointer <= rightPointer)\n                dynamicProgramming[previousIndex] -= dynamicProgramming[leftPointer - 1];\n            dynamicProgramming[previousIndex] += dynamicProgramming[previousIndex - 1] + 1;\n            totalCount += dynamicProgramming[previousIndex];\n        }\n    }\n    return totalCount;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMaximumMex(vector<int> &numbers, int incrementValue)\n{\n    unordered_set<int> numberSet(numbers.begin(), numbers.end());\n\n    for(int i= 0; i <= 100000; i++)\n    {\n        if(!numberSet.count(i))\n            numberSet.insert(i + incrementValue);\n    }\n\n    int minimumExcludedValue= 0;\n    while(numberSet.count(minimumExcludedValue))\n        minimumExcludedValue++;\n\n    return minimumExcludedValue;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int CalculateMaximumMex(std::vector<int> &numbers, int increment_value)\n{\n    std::unordered_set<int> numberSet(numbers.begin(), numbers.end());\n\n    for(int i= 0; i <= 100000; i++)\n    {\n        if(!numberSet.count(i))\n            numberSet.insert(i + increment_value);\n    }\n\n    int minimumExcludedValue= 0;\n    while(numberSet.count(minimumExcludedValue))\n        minimumExcludedValue++;\n\n    return minimumExcludedValue;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &nums)\n{\n    int minimumPrefixSum = 0;\n    int currentPrefixSum = 0;\n    for (int i = 0; i < nums.size(); ++i)\n    {\n        int currentNumber = nums[i];\n        currentPrefixSum += currentNumber;\n        minimumPrefixSum = min(minimumPrefixSum, currentPrefixSum);\n    }\n    return minimumPrefixSum < 0 ? -minimumPrefixSum : 0;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &nums)\n{\n    int minimumPrefixSum= 0;\n    int currentPrefixSum= 0;\n    for(int currentNumber : nums)\n    {\n        currentPrefixSum+= currentNumber;\n        minimumPrefixSum= std::min(minimumPrefixSum, currentPrefixSum);\n    }\n    return minimumPrefixSum < 0 ? -minimumPrefixSum : 0;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint maxSum(int numberOfOnes, int numberOfZeros, int numberOfNegativeOnes, int limit)\n{\n    int maximumSum= 0;\n    for(int i= 0; i <= limit; ++i)\n    {\n        int onesCount= min(i, numberOfOnes);\n        int negativeOnesCount= min(limit - i, numberOfNegativeOnes);\n        maximumSum= max(maximumSum, onesCount - negativeOnesCount);\n    }\n    return maximumSum;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int MaxSum(int number_of_ones, int number_of_zeros, int number_of_negative_ones, int limit)\n{\n    int maximumSum= 0;\n    for(int i= 0; i <= limit; ++i)\n    {\n        int onesCount= min(i, number_of_ones);\n        int negativeOnesCount= min(limit - i, number_of_negative_ones);\n        maximumSum= max(maximumSum, onesCount - negativeOnesCount);\n    }\n    return maximumSum;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool strictlyIncreasingArray(vector<int> &numberArray)\n{\n    for(int currentIndex= 0; currentIndex < numberArray.size() - 1; ++currentIndex)\n    {\n        numberArray[currentIndex]-= currentIndex;\n        if(numberArray[currentIndex] >= numberArray[currentIndex + 1])\n        {\n            return false;\n        }\n    }\n    return true;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nbool StrictlyIncreasingArray(std::vector<int> &number_array)\n{\n    for(int currentIndex= 0; currentIndex < number_array.size() - 1; ++currentIndex)\n    {\n        number_array[currentIndex]-= currentIndex;\n        if(number_array[currentIndex] >= number_array[currentIndex + 1])\n        {\n            return false;\n        }\n    }\n    return true;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> minOperations(vector<int> &numbers, vector<int> &queries)\n{\n    vector<int> operationsCount;\n    for (int i = 0; i < queries.size(); ++i)\n    {\n        int query = queries[i];\n        int totalOperations = 0;\n        for (int j = 0; j < numbers.size(); ++j)\n        {\n            int number = numbers[j];\n            totalOperations += abs(number - query);\n        }\n        operationsCount.push_back(totalOperations);\n    }\n    return operationsCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\n// for abs\n\nstd::vector<int> MinOperations(std::vector<int> &numbers, std::vector<int> &queries)\n{\n    std::vector<int> operationsCount;\n    for(int query : queries)\n    {\n        int total_operations= 0;\n        for(int number : numbers)\n        {\n            total_operations+= std::abs(number - query);\n        }\n        operationsCount.push_back(total_operations);\n    }\n    return operationsCount;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\npair<int, int> depthFirstSearch(const vector<vector<int>> &adjacencyList, const vector<int> &coinValues, int currentNode, int parentNode)\n{\n    int totalCoins = coinValues[currentNode], totalDistance = 0;\n    for (int i = 0; i < adjacencyList[currentNode].size(); ++i)\n    {\n        int neighborNode = adjacencyList[currentNode][i];\n        if (neighborNode != parentNode)\n        {\n            auto result = depthFirstSearch(adjacencyList, coinValues, neighborNode, currentNode);\n            totalCoins += result.first;\n            totalDistance += 2 * result.first + result.second;\n        }\n    }\n    return {totalCoins, totalDistance};\n}\n\nint minEdgesToCollectCoins(const vector<int> &coinValues, const vector<vector<int>> &edges)\n{\n    int numberOfNodes = coinValues.size();\n    vector<vector<int>> adjacencyList(numberOfNodes);\n    for (const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n    return depthFirstSearch(adjacencyList, coinValues, 0, -1).second / 2;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nstd::pair<int, int> DepthFirstSearch(const std::vector<std::vector<int>> &adjacency_list, const std::vector<int> &coin_values, int current_node, int parent_node)\n{\n    int totalCoins= coin_values[current_node], totalDistance= 0;\n    for(int neighborNode : adjacency_list[current_node])\n    {\n        if(neighborNode != parent_node)\n        {\n            auto result= DepthFirstSearch(adjacency_list, coin_values, neighborNode, current_node);\n            totalCoins+= result.first;\n            totalDistance+= 2 * result.first + result.second;\n        }\n    }\n    return {totalCoins, totalDistance};\n}\n\nint MinEdgesToCollectCoins(const std::vector<int> &coin_values, const std::vector<std::vector<int>> &edges)\n{\n    int numberOfNodes= coin_values.size();\n    std::vector<std::vector<int>> adjacency_list(numberOfNodes);\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n    return DepthFirstSearch(adjacency_list, coin_values, 0, -1).second / 2;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minTimeToEatGrains(vector<int> &hens, vector<int> &grains)\n{\n    sort(hens.begin(), hens.end());\n    sort(grains.begin(), grains.end());\n    int minTime = 0, maxTime = 1e9;\n\n    while (minTime < maxTime)\n    {\n        int midTime = minTime + (maxTime - minTime) / 2;\n        bool canEat = true;\n        int henIndex = 0;\n\n        for (int j = 0; j < grains.size(); ++j)\n        {\n            int grain = grains[j];\n\n            if (henIndex >= hens.size())\n            {\n                canEat = false;\n                break;\n            }\n\n            while (henIndex < hens.size() && hens[henIndex] < grain - midTime)\n            {\n                ++henIndex;\n            }\n\n            if (henIndex >= hens.size() || hens[henIndex] > grain + midTime)\n            {\n                canEat = false;\n                break;\n            }\n\n            ++henIndex;\n        }\n\n        if (canEat)\n        {\n            maxTime = midTime;\n        }\n        else\n        {\n            minTime = midTime + 1;\n        }\n    }\n\n    return minTime;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint MinTimeToEatGrains(std::vector<int> &hens, std::vector<int> &grains)\n{\n    std::sort(hens.begin(), hens.end());\n    std::sort(grains.begin(), grains.end());\n    int min_time= 0, max_time= 1e9;\n\n    while(min_time < max_time)\n    {\n        int mid_time= min_time + (max_time - min_time) / 2;\n        bool canEat= true;\n        int henIndex= 0;\n\n        for(int grain : grains)\n        {\n            if(henIndex >= hens.size())\n            {\n                canEat= false;\n                break;\n            }\n\n            while(henIndex < hens.size() && hens[henIndex] < grain - mid_time)\n            {\n                ++henIndex;\n            }\n\n            if(henIndex >= hens.size() || hens[henIndex] > grain + mid_time)\n            {\n                canEat= false;\n                break;\n            }\n\n            ++henIndex;\n        }\n\n        if(canEat)\n        {\n            max_time= mid_time;\n        }\n        else\n        {\n            min_time= mid_time + 1;\n        }\n    }\n\n    return min_time;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint findSmallestNumberWithAtLeastOneDigitFromEachArray(vector<int> &firstArray, vector<int> &secondArray)\n{\n    int minFirstArray = *min_element(firstArray.begin(), firstArray.end());\n    int minSecondArray = *min_element(secondArray.begin(), secondArray.end());\n    for (int i = 0; i < firstArray.size(); ++i)\n    {\n        int numberFromFirstArray = firstArray[i];\n        for (int j = 0; j < secondArray.size(); ++j)\n        {\n            int numberFromSecondArray = secondArray[j];\n            if (numberFromFirstArray == numberFromSecondArray)\n            {\n                return numberFromFirstArray;\n            }\n        }\n    }\n    return minFirstArray * 10 + minSecondArray;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint FindSmallestNumberWithAtLeastOneDigitFromEachArray(std::vector<int> &first_array, std::vector<int> &second_array)\n{\n    int minFirstArray = *std::min_element(first_array.begin(), first_array.end());\n    int minSecondArray = *std::min_element(second_array.begin(), second_array.end());\n    for(int numberFromFirstArray : first_array)\n    {\n        for(int numberFromSecondArray : second_array)\n        {\n            if(numberFromFirstArray == numberFromSecondArray)\n            {\n                return numberFromFirstArray;\n            }\n        }\n    }\n    return minFirstArray * 10 + minSecondArray;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxValueSubstring(string inputString, string charList, vector<int> values)\n{\n    unordered_map<char, int> charValues;\n\n    for(int index = 0; index < charList.length(); index++)\n    {\n        charValues[charList[index]] = values[index];\n    }\n\n    int maxCost = 0;\n    int currentCost = 0;\n\n    for (int i = 0; i < inputString.length(); ++i)\n    {\n        char currentChar = inputString[i];\n        int charValue = charValues.count(currentChar) ? charValues[currentChar] : static_cast<int>(currentChar - 'a' + 1);\n\n        currentCost = max(0, currentCost + charValue);\n        maxCost = max(maxCost, currentCost);\n    }\n\n    return maxCost;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int MaxValueSubstring(std::string input_string, std::string char_list, std::vector<int> values)\n{\n    std::unordered_map<char, int> charValues;\n\n    for(int index= 0; index < char_list.length(); index++)\n    {\n        charValues[char_list[index]]= values[index];\n    }\n\n    int maxCost= 0;\n    int currentCost= 0;\n\n    for(char currentChar : input_string)\n    {\n        int charValue= charValues.count(currentChar) ? charValues[currentChar] : static_cast<int>(currentChar - 'a' + 1);\n\n        currentCost= std::max(0, currentCost + charValue);\n        maxCost= std::max(maxCost, currentCost);\n    }\n\n    return maxCost;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &array, int subarraySize)\n{\n    int arraySize= array.size(), minimumCost= INT_MAX;\n    vector<int> prefixSum(arraySize + 1);\n\n    for(int index= 1; index <= arraySize; index++)\n    {\n        prefixSum[index]= prefixSum[index - 1] + array[index - 1];\n    }\n\n    for(int startIndex= 1; startIndex <= arraySize - subarraySize + 1; startIndex++)\n    {\n        int targetValue= (prefixSum[startIndex - 1] + prefixSum[arraySize] - prefixSum[startIndex + subarraySize - 1] + arraySize / subarraySize - 1) / (arraySize / subarraySize);\n        int currentCost= 0;\n        for(int elementIndex= startIndex; elementIndex < startIndex + subarraySize; elementIndex++)\n        {\n            currentCost+= abs(array[elementIndex - 1] - targetValue);\n        }\n        minimumCost= min(minimumCost, currentCost);\n    }\n    return minimumCost;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &array, int subarray_size)\n{\n    int arraySize= array.size(), minimumCost= INT_MAX;\n    std::vector<int> prefixSum(arraySize + 1);\n\n    for(int index= 1; index <= arraySize; index++)\n    {\n        prefixSum[index]= prefixSum[index - 1] + array[index - 1];\n    }\n\n    for(int startIndex= 1; startIndex <= arraySize - subarray_size + 1; startIndex++)\n    {\n        int targetValue= (prefixSum[startIndex - 1] + prefixSum[arraySize] - prefixSum[startIndex + subarray_size - 1] + arraySize / subarray_size - 1) / (arraySize / subarray_size);\n        int currentCost= 0;\n        for(int elementIndex= startIndex; elementIndex < startIndex + subarray_size; elementIndex++)\n        {\n            currentCost+= std::abs(array[elementIndex - 1] - targetValue);\n        }\n        minimumCost= std::min(minimumCost, currentCost);\n    }\n    return minimumCost;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestCycleLength(int nodeCount, vector<vector<int>> &edges)\n{\n    vector<vector<int>> adjacencyList(nodeCount);\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        const vector<int> &edge = edges[i];\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    int minimumCycleLength = nodeCount + 1;\n    for (int startNode = 0; startNode < nodeCount; ++startNode)\n    {\n        vector<int> distance(nodeCount, nodeCount + 1);\n        distance[startNode] = 0;\n        queue<int> nodeQueue;\n        nodeQueue.push(startNode);\n\n        while (!nodeQueue.empty())\n        {\n            int currentNode = nodeQueue.front();\n            nodeQueue.pop();\n            for (int j = 0; j < adjacencyList[currentNode].size(); ++j)\n            {\n                int neighbor = adjacencyList[currentNode][j];\n                if (distance[neighbor] == nodeCount + 1)\n                {\n                    distance[neighbor] = distance[currentNode] + 1;\n                    nodeQueue.push(neighbor);\n                }\n                else if (distance[neighbor] >= distance[currentNode] - 1)\n                {\n                    minimumCycleLength = min(minimumCycleLength, distance[currentNode] + distance[neighbor] + 1);\n                }\n            }\n        }\n    }\n\n    return minimumCycleLength == nodeCount + 1 ? -1 : minimumCycleLength;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint ShortestCycleLength(int node_count, std::vector<std::vector<int>> &edges)\n{\n    std::vector<std::vector<int>> adjacencyList(node_count);\n    for(const std::vector<int> &edge : edges)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    int minimumCycleLength= node_count + 1;\n    for(int startNode= 0; startNode < node_count; ++startNode)\n    {\n        std::vector<int> distance(node_count, node_count + 1);\n        distance[startNode]= 0;  // corrected from start_node to startNode\n        std::queue<int> nodeQueue;\n        nodeQueue.push(startNode);\n\n        while(!nodeQueue.empty())\n        {\n            int currentNode= nodeQueue.front();\n            nodeQueue.pop();\n            for(int neighbor : adjacencyList[currentNode])\n            {\n                if(distance[neighbor] == node_count + 1)\n                {\n                    distance[neighbor]= distance[currentNode] + 1;\n                    nodeQueue.push(neighbor);\n                }\n                else if(distance[neighbor] >= distance[currentNode] - 1)\n                {\n                    minimumCycleLength= std::min(minimumCycleLength, distance[currentNode] + distance[neighbor] + 1);\n                }\n            }\n        }\n    }\n\n    return minimumCycleLength == node_count + 1 ? -1 : minimumCycleLength;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint longestBalancedSubstring(string binaryString)\n{\n    int maxLength= 0;\n    int zeroCount= 0;\n    int oneCount= 0;\n\n    for(int index= 0; index < binaryString.size(); ++index)\n    {\n        if(binaryString[index] == '0')\n        {\n            zeroCount++;\n        }\n        else\n        {\n            oneCount++;\n        }\n        if(zeroCount == oneCount)\n        {\n            maxLength= max(maxLength, zeroCount * 2);\n        }\n        else if(zeroCount > oneCount)\n        {\n            zeroCount= oneCount= 0;\n        }\n    }\n\n    zeroCount= oneCount= 0;\n    for(int index= binaryString.size() - 1; index >= 0; --index)\n    {\n        if(binaryString[index] == '0')\n        {\n            zeroCount++;\n        }\n        else\n        {\n            oneCount++;\n        }\n        if(zeroCount == oneCount)\n        {\n            maxLength= max(maxLength, zeroCount * 2);\n        }\n        else if(zeroCount < oneCount)\n        {\n            zeroCount= oneCount= 0;\n        }\n    }\n\n    return maxLength;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint LongestBalancedSubstring(std::string binary_string)\n{\n    int maxLength= 0;\n    int zeroCount= 0;\n    int oneCount= 0;\n\n    for(int index= 0; index < binary_string.size(); ++index)\n    {\n        if(binary_string[index] == '0')\n        {\n            zeroCount++;\n        }\n        else\n        {\n            oneCount++;\n        }\n        if(zeroCount == oneCount)\n        {\n            maxLength= std::max(maxLength, zeroCount * 2);\n        }\n        else if(zeroCount > oneCount)\n        {\n            zeroCount= oneCount= 0;\n        }\n    }\n\n    zeroCount= oneCount= 0;\n    for(int index= binary_string.size() - 1; index >= 0; --index)\n    {\n        if(binary_string[index] == '0')\n        {\n            zeroCount++;\n        }\n        else\n        {\n            oneCount++;\n        }\n        if(zeroCount == oneCount)\n        {\n            maxLength= std::max(maxLength, zeroCount * 2);\n        }\n        else if(zeroCount < oneCount)\n        {\n            zeroCount= oneCount= 0;\n        }\n    }\n\n    return maxLength;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> distinctRowsFrom(vector<int> &inputNumbers)\n{\n    vector<unordered_set<int>> uniqueRows;\n\n    for (int i = 0; i < inputNumbers.size(); ++i)\n    {\n        int currentNumber = inputNumbers[i];\n        bool isInserted = false;\n        for (int j = 0; j < uniqueRows.size(); ++j)\n        {\n            auto &row = uniqueRows[j];\n            if (row.find(currentNumber) == row.end())\n            {\n                row.insert(currentNumber);\n                isInserted = true;\n                break;\n            }\n        }\n\n        if (!isInserted)\n            uniqueRows.push_back({currentNumber});\n    }\n\n    vector<vector<int>> result;\n    for (int k = 0; k < uniqueRows.size(); ++k)\n    {\n        auto &row = uniqueRows[k];\n        result.emplace_back(row.begin(), row.end());\n    }\n\n    return result;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> DistinctRowsFrom(std::vector<int> &input_numbers)\n{\n    std::vector<std::unordered_set<int>> uniqueRows;\n\n    for(int currentNumber : input_numbers)\n    {\n        bool isInserted= false;\n        for(auto &row : uniqueRows)\n        {\n            if(row.find(currentNumber) == row.end())\n            {\n                row.insert(currentNumber);\n                isInserted= true;\n                break;\n            }\n        }\n\n        if(!isInserted)\n            uniqueRows.push_back({currentNumber});\n    }\n\n    std::vector<std::vector<int>> result;\n    for(auto &row : uniqueRows)\n    {\n        result.emplace_back(row.begin(), row.end());\n    }\n\n    return result;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxPoints(const vector<int> &firstMouseRewards, const vector<int> &secondMouseRewards, int k)\n{\n    vector<pair<int, int>> rewardGap(firstMouseRewards.size());\n    for(size_t index= 0; index < firstMouseRewards.size(); ++index)\n    {\n        rewardGap[index]= {secondMouseRewards[index] - firstMouseRewards[index], index};\n    }\n    sort(rewardGap.rbegin(), rewardGap.rend());\n    int totalFirstMousePoints= 0;\n    int totalSecondMousePoints= 0;\n    for(int i= 0; i < k; ++i)\n    {\n        totalFirstMousePoints+= firstMouseRewards[rewardGap[i].second];\n    }\n    for(int i= k; i < firstMouseRewards.size(); ++i)\n    {\n        totalSecondMousePoints+= secondMouseRewards[rewardGap[i].second];\n    }\n    return totalFirstMousePoints + totalSecondMousePoints;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nint MaxPoints(const std::vector<int> &first_mouse_rewards, const std::vector<int> &second_mouse_rewards, int k)\n{\n    std::vector<std::pair<int, int>> reward_gap(first_mouse_rewards.size());\n    for(size_t index= 0; index < first_mouse_rewards.size(); ++index)\n    {\n        reward_gap[index]= {second_mouse_rewards[index] - first_mouse_rewards[index], index};\n    }\n    std::sort(reward_gap.rbegin(), reward_gap.rend());\n    int totalFirstMousePoints= 0;\n    int totalSecondMousePoints= 0;\n    for(int i= 0; i < k; ++i)\n    {\n        total_first_mouse_points+= first_mouse_rewards[reward_gap[i].second];\n    }\n    for(int i= k; i < first_mouse_rewards.size(); ++i)\n    {\n        total_second_mouse_points+= second_mouse_rewards[reward_gap[i].second];\n    }\n    return totalFirstMousePoints + totalSecondMousePoints;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> reachPosition(int totalPositions, int targetPosition, vector<int> &bannedPositions, int stepSize)\n{\n    set<int> bannedSet(bannedPositions.begin(), bannedPositions.end());\n    vector<int> result(totalPositions, 0);\n\n    for(int currentPosition= 0; currentPosition < totalPositions; ++currentPosition)\n    {\n        if(bannedSet.find(currentPosition) != bannedSet.end() || currentPosition == targetPosition)\n        {\n            result[currentPosition]= -1;\n            continue;\n        }\n\n        int stepsRequired= 0;\n        int distance= abs(targetPosition - currentPosition) / stepSize;\n        if((abs(targetPosition - currentPosition) % stepSize == 0) && ((distance & 1) == (((totalPositions - 1) & 1) ^ (stepSize & 1))))\n        {\n            stepsRequired= distance;\n        }\n        else\n        {\n            stepsRequired= -1;\n        }\n\n        result[currentPosition]= stepsRequired;\n    }\n\n    result[targetPosition]= 0;\n    return result;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nint MaxNumberOfCopies(std::string source_string, std::string target_string)\n{\n    std::vector<int> sourceCounts(26, 0);\n    std::vector<int> targetCounts(26, 0);\n\n    for(char character : source_string)\n        sourceCounts[character - 'a']++;\n\n    for(char character : target_string)\n        targetCounts[character - 'a']++;\n\n    int maxCopies= INT32_MAX;\n    for(int index= 0; index < 26; index++)\n    {\n        if(targetCounts[index] > 0)\n            maxCopies= std::min(maxCopies, sourceCounts[index] / targetCounts[index]);\n    }\n    return maxCopies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nint MinNumberOfBeansToRemove(const std::vector<int> &bean_counts)\n{\n    std::unordered_map<int, int> beanFrequency;\n    for(int bean : bean_counts)\n    {\n        beanFrequency[bean]++;\n    }\n\n    int minBeansToRemove= bean_counts.size();\n    for(const auto &currentBean : beanFrequency)\n    {\n        int beansToRemove= 0;\n        for(const auto &otherBean : beanFrequency)\n        {\n            if(otherBean.first != currentBean.first)\n            {\n                beansToRemove+= otherBean.second * std::max(0, otherBean.first - currentBean.first);\n            }\n        }\n        minBeansToRemove= std::min(minBeansToRemove, beansToRemove);\n    }\n\n    return minBeansToRemove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nint MaxAndSum(std::vector<int> &numbers, int num_slots)\n{\n    std::vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slotIndex= num_slots; slotIndex > 0; slotIndex--)\n        {\n            int newValue= number & slotIndex;\n            if(newValue > slot[slotIndex])\n                slot[slotIndex]= newValue;\n        }\n    }\n\n    return std::accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nint MinSteps(std::string source_string, std::string target_string)\n{\n    std::unordered_map<char, int> characterCount;\n    for(char currentCharacter : source_string)\n        characterCount[currentCharacter]++;\n    for(char currentCharacter : target_string)\n        characterCount[currentCharacter]--;\n\n    int totalSteps= 0;\n    for(auto &characterPair : characterCount)\n    {\n        totalSteps+= abs(characterPair.second);\n    }\n\n    return totalSteps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nint MinimumTimeForTrips(std::vector<int> &travel_times, int total_trips)\n{\n    std::sort(travel_times.begin(), travel_times.end());\n\n    int lowerBound= 0, upperBound= travel_times.back() * total_trips;\n    while(lowerBound < upperBound)\n    {\n        int midTime= lowerBound + (upperBound - lowerBound) / 2;\n        int completedTrips= 0;\n        for(int travelTime : travel_times)\n        {\n            completedTrips+= midTime / travelTime;\n        }\n        if(completedTrips < total_trips)\n        {\n            lowerBound= midTime + 1;\n        }\n        else\n        {\n            upperBound= midTime;\n        }\n    }\n\n    return lowerBound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nstd::string RepeatLimitedString(std::string input_string, int repeat_limit)\n{\n    std::string outputString= \"\";\n    std::sort(input_string.begin(), input_string.end(), std::greater<char>());\n\n    for(char currentChar : input_string)\n    {\n        size_t charPosition= outputString.find(currentChar);\n\n        if(charPosition == std::string::npos)\n        {\n            outputString.push_back(currentChar);\n        }\n        else\n        {\n            int charCount= 1;\n\n            while(charPosition + charCount < outputString.size() && outputString[charPosition + charCount] == currentChar)\n            {\n                charCount++;\n            }\n\n            if(charCount < repeat_limit)\n            {\n                outputString.insert(charPosition + charCount, 1, currentChar);\n            }\n        }\n    }\n\n    return outputString;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nint CountPairs(std::vector<int> &number_list, int divisor)\n{\n    std::vector<int> remainderCount(divisor, 0);\n    int pairCount= 0;\n\n    for(int number : number_list)\n    {\n        remainderCount[number % divisor]++;\n    }\n\n    pairCount+= remainderCount[0] * (remainderCount[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pairCount+= remainderCount[i] * remainderCount[divisor - i];\n        }\n        else\n        {\n            pairCount+= remainderCount[i] * (remainderCount[i] - 1) / 2;\n        }\n    }\n    return pairCount;\n}\n## Code Example 8\n#include <bits/stdc++.h>\ndouble CalculateTaxAmount(std::vector<std::vector<int>> &tax_brackets, int total_income)\n{\n    double totalTax= 0;\n    int previousUpperLimit= 0;\n    for(std::vector<int> &taxBracket : tax_brackets)\n    {\n        int upperLimit= taxBracket[0];\n        double taxRate= taxBracket[1] / 100.0;\n        totalTax+= (std::min(upperLimit, total_income) - previousUpperLimit) * taxRate;\n        previousUpperLimit= upperLimit;\n        if(total_income <= upperLimit)\n            break;\n    }\n    return totalTax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nTreeNode *ConstructTree(std::vector<std::vector<int>> &descriptions)\n{\n    std::unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]]= new TreeNode(description[0]);\n        node_map[description[1]]= new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->leftChild= node_map[description[1]];\n        else\n            node_map[description[0]]->rightChild= node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\nint GetMaxOccurrences(const std::string &input_text, const std::string &pattern)\n{\n    int occurrenceCount[2]= {0, 0};\n    for(char currentChar : input_text)\n    {\n        if(currentChar == pattern[1])\n        {\n            occurrenceCount[1]+= occurrenceCount[0];\n        }\n        else if(currentChar == pattern[0])\n        {\n            occurrenceCount[0]+= 1;\n        }\n    }\n    return occurrenceCount[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &numbers)\n{\n    std::sort(numbers.begin(), numbers.end(), std::greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\nint CountStarsExceptBetweenPipePairs(const std::string &input_string)\n{\n    int starCount= 0;\n    int pipeCount= 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipeCount++;\n        }\n        else if(character == '*' && pipeCount % 2 == 0)\n        {\n            starCount++;\n        }\n    }\n\n    return starCount;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nint CountCollisions(std::string directions)\n{\n    int collisionCount= 0, leftCount= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            leftCount++;\n        }\n        else if(direction == 'R')\n        {\n            collisionCount+= leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nstd::vector<int> FindDistantIndices(std::vector<int> &numbers, int key_value, int distance)\n{\n    std::vector<int> distantIndices;\n    for(int currentIndex= 0; currentIndex < numbers.size(); ++currentIndex)\n    {\n        for(int startIndex= std::max(0, currentIndex - distance); startIndex <= std::min(currentIndex + distance, static_cast<int>(numbers.size()) - 1); ++startIndex)\n        {\n            if(numbers[startIndex] == key_value)\n            {\n                distantIndices.push_back(currentIndex);\n                break;\n            }\n        }\n    }\n    return distantIndices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nint ShortestPath(int num_nodes, std::vector<std::vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        std::vector<int> distances(num_nodes, INT_MAX);\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> priorityQueue;\n\n        distances[source]= 0;\n        priorityQueue.emplace(0, source);\n\n        while(!priorityQueue.empty())\n        {\n            int currentNode= priorityQueue.top().second;\n            int currentDistance= priorityQueue.top().first;\n            priorityQueue.pop();\n\n            if(currentDistance != distances[currentNode])\n                continue;\n\n            for(const auto &edge : adjacencyList[currentNode])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[currentNode] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[currentNode] + weight;\n                    priorityQueue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    std::vector<int> source1ToAllDistances= dijkstra(source_1);\n    std::vector<int> source2ToAllDistances= dijkstra(source_2);\n\n    int minimumWeight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimumWeight= std::min(minimumWeight, source1ToAllDistances[u] + w + source2ToAllDistances[v]);\n    }\n\n    return minimumWeight == INT_MAX ? -1 : minimumWeight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nint DepthFirstSearch(int current_node, int parent_node, std::vector<int> &node_xor_values, std::vector<std::vector<int>> &adjacency_list)\n{\n    int currentXorValue = node_xor_values[current_node];\n    for(int childNode : adjacency_list[current_node])\n    {\n        if(childNode != parent_node)\n        {\n            currentXorValue ^= DepthFirstSearch(childNode, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return currentXorValue;\n}\n\nint MinimumScore(std::vector<int> &node_values, std::vector<std::vector<int>> &edge_list)\n{\n    int nodeCount = node_values.size();\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n\n    for(std::vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    std::vector<int> nodeXorValues(nodeCount);\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        nodeXorValues[i] = DepthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference = INT_MAX;\n    for(int i = 0; i < nodeCount; ++i)\n    {\n        for(int j = i + 1; j < nodeCount; ++j)\n        {\n            int xorValue1 = nodeXorValues[i];\n            int xorValue2 = nodeXorValues[j] ^ node_values[i];\n            int xorValue3 = node_values[i] ^ node_values[j];\n            int maxXorValue = std::max({xorValue1, xorValue2, xorValue3});\n            int min_xor_value = std::min({xorValue1, xorValue2, xorValue3});\n            minimum_difference = std::min(minimum_difference, maxXorValue - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nstd::string LargestSwap(std::string number)\n{\n    std::string evenDigits= \"\";\n    std::string oddDigits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            evenDigits.push_back(digit);\n        }\n        else\n        {\n            oddDigits.push_back(digit);\n        }\n    }\n\n    std::sort(evenDigits.rbegin(), evenDigits.rend());\n    std::sort(oddDigits.rbegin(), oddDigits.rend());\n\n    std::string result= \"\";\n    size_t evenIndex= 0, oddIndex= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(evenDigits[evenIndex++]);\n        }\n        else\n        {\n            result.push_back(oddDigits[oddIndex++]);\n        }\n    }\n\n    return result;\n}\n\nint LargestSwapPermutations(int input_number)\n{\n    std::string numberString= std::to_string(input_number);\n    return std::stoi(LargestSwap(numberString));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nint MaxBeauty(std::vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int totalBeauty= 0;\n    for(int flowerCount : flower_counts)\n        totalBeauty+= (flowerCount >= beauty_target) ? full_beauty : partial_beauty * flowerCount;\n\n    std::sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowersNeeded= beauty_target - flower_counts[i];\n        if(flowersNeeded <= available_new_flowers)\n        {\n            totalBeauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowersNeeded;\n        }\n    }\n\n    return totalBeauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nint LastPassengerTime(std::vector<int> &bus_times, std::vector<int> &passenger_times, int bus_capacity)\n{\n    std::sort(bus_times.begin(), bus_times.end());\n    std::sort(passenger_times.begin(), passenger_times.end());\n\n    int lastPassengerIndex= 0;\n    for(int busTime : bus_times)\n    {\n        int count= 0;\n        while(lastPassengerIndex < passenger_times.size() && passenger_times[lastPassengerIndex] <= busTime && count < bus_capacity)\n        {\n            count++;\n            lastPassengerIndex++;\n        }\n    }\n\n    return lastPassengerIndex == 0 ? bus_times[0] - 1 : passenger_times[lastPassengerIndex - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nstd::vector<int> CountPairsLeftovers(std::vector<int> &number_list)\n{\n    std::vector<int> countArray(101, 0);\n    int totalPairs= 0, totalLeftovers= 0;\n\n    for(int currentNumber : number_list)\n    {\n        countArray[currentNumber]++;\n    }\n\n    for(int count : countArray)\n    {\n        totalPairs+= count / 2;\n        totalLeftovers+= count % 2;\n    }\n\n    return {totalPairs, totalLeftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nint MaxSumNumbersWithEqualSumOfDigits(std::vector<int> &numbers)\n{\n    std::unordered_map<int, int> digitSumToMax;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int tempNumber= current_number; tempNumber; tempNumber/= 10)\n        {\n            sum_of_digits+= tempNumber % 10;\n        }\n\n        int previousMax= digitSumToMax[sum_of_digits];\n        if(previousMax)\n        {\n            result= std::max(result, current_number + previousMax);\n        }\n        digitSumToMax[sum_of_digits]= std::max(current_number, previousMax);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> ReachPosition(int total_positions, int target_position, std::vector<int> &banned_positions, int step_size)\n{\n    std::set<int> bannedSet(banned_positions.begin(), banned_positions.end());\n    std::vector<int> result(total_positions, 0);\n\n    for(int currentPosition= 0; currentPosition < total_positions; ++currentPosition)\n    {\n        if(bannedSet.find(currentPosition) != bannedSet.end() || currentPosition == target_position)\n        {\n            result[currentPosition]= -1;\n            continue;\n        }\n\n        int stepsRequired= 0;\n        int distance= abs(target_position - currentPosition) / step_size;\n        if((abs(target_position - currentPosition) % step_size == 0) && ((distance & 1) == (((total_positions - 1) & 1) ^ (step_size & 1))))\n        {\n            stepsRequired= distance;\n        }\n        else\n        {\n            stepsRequired= -1;\n        }\n\n        result[currentPosition]= stepsRequired;\n    }\n\n    result[target_position]= 0;\n    return result;\n}"
  }
]