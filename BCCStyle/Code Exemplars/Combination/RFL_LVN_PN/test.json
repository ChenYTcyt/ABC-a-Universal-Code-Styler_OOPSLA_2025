[
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring findOddWord(vector<string> &wordList)\n{\n    auto calculateDifferenceArray = [](const string &currentWord)\n    {\n        vector<int> differenceArray;\n        for(size_t index = 1; index < currentWord.size(); index++)\n        {\n            differenceArray.push_back(currentWord[index] - currentWord[index - 1]);\n        }\n        return differenceArray;\n    };\n\n    vector<vector<int>> differenceArrays;\n    for (int i = 0; i < wordList.size(); ++i)\n    {\n        const auto &currentWord = wordList[i];\n        differenceArrays.push_back(calculateDifferenceArray(currentWord));\n    }\n\n    int oddArrayIndex = -1;\n    for (int index = 1; index < differenceArrays.size(); index++)\n    {\n        int matchCount = 0;\n        for (int j = 0; j < differenceArrays[index].size(); j++)\n        {\n            if (differenceArrays[0][j] == differenceArrays[index][j])\n            {\n                matchCount++;\n            }\n        }\n\n        if (matchCount == 0)\n        {\n            oddArrayIndex = index;\n            break;\n        }\n    }\n\n    return wordList[oddArrayIndex];\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring findOddWord(vector<string> &word_list)\n{\n    auto calculate_difference_array = [](const string &current_word)\n    {\n        vector<int> difference_array;\n        for(size_t index = 1; index < current_word.size(); index++)\n        {\n            difference_array.push_back(current_word[index] - current_word[index - 1]);\n        }\n        return difference_array;\n    };\n\n    vector<vector<int>> difference_arrays;\n    for(const auto &current_word : word_list)\n    {\n        difference_arrays.push_back(calculate_difference_array(current_word));\n    }\n\n    int odd_array_index = -1;\n    for(int index = 1; index < difference_arrays.size(); index++)\n    {\n        int match_count = 0;\n        for(int j = 0; j < difference_arrays[index].size(); j++)\n        {\n            if(difference_arrays[0][j] == difference_arrays[index][j])\n            {\n                match_count++;\n            }\n        }\n\n        if(match_count == 0)\n        {\n            odd_array_index = index;\n            break;\n        }\n    }\n\n    return word_list[odd_array_index];\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countDifferences(const string &sourceWord, const string &targetWord)\n{\n    int differenceCount = 0;\n    for(int index = 0; index < sourceWord.size(); ++index)\n    {\n        if(sourceWord[index] != targetWord[index])\n        {\n            ++differenceCount;\n        }\n    }\n    return differenceCount;\n}\n\nvector<string> findMatchingWords(const vector<string> &queryWords, const vector<string> &dictionaryWords)\n{\n    vector<string> matchedWords;\n    for (int i = 0; i < queryWords.size(); ++i)\n    {\n        const string &query = queryWords[i];\n        for (int j = 0; j < dictionaryWords.size(); ++j)\n        {\n            const string &dictionaryWord = dictionaryWords[j];\n            if (countDifferences(query, dictionaryWord) <= 2)\n            {\n                matchedWords.push_back(query);\n                break;\n            }\n        }\n    }\n    return matchedWords;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countDifferences(const string &source_word, const string &target_word)\n{\n    int difference_count= 0;\n    for(int index= 0; index < source_word.size(); ++index)\n    {\n        if(source_word[index] != target_word[index])\n        {\n            ++difference_count;\n        }\n    }\n    return difference_count;\n}\n\nvector<string> findMatchingWords(const vector<string> &query_words, const vector<string> &dictionary_words)\n{\n    vector<string> matched_words;\n    for(const string &query : query_words)\n    {\n        for(const string &dictionary_word : dictionary_words)\n        {\n            if(countDifferences(query, dictionary_word) <= 2)\n            {\n                matched_words.push_back(query);\n                break;\n            }\n        }\n    }\n    return matched_words;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint findMinSeededValue(vector<int> &numbers, int space)\n{\n    unordered_map<int, int> remainderCount;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int number = numbers[i];\n        remainderCount[number % space]++;\n    }\n    return max_element(remainderCount.begin(), remainderCount.end(), [](const auto &a, const auto &b)\n                       { return a.second < b.second || (a.second == b.second && a.first > b.first); })\n        ->first;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findMinSeededValue(vector<int> &numbers, int space)\n{\n    unordered_map<int, int> remainder_count;\n    for(int number : numbers)\n    {\n        remainder_count[number % space]++;\n    }\n    return max_element(remainder_count.begin(), remainder_count.end(), [](const auto &a, const auto &b)\n                       { return a.second < b.second || (a.second == b.second && a.first > b.first); })\n        ->first;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findSecondGreater(const vector<int> &inputNumbers)\n{\n    int totalNumbers= inputNumbers.size();\n    vector<int> result(totalNumbers, -1);\n    for(int currentIndex= 0; currentIndex < totalNumbers; currentIndex++)\n    {\n        for(int nextIndex= currentIndex + 1, secondGreaterIndex= -1; nextIndex < totalNumbers; nextIndex++)\n        {\n            if(inputNumbers[nextIndex] > inputNumbers[currentIndex])\n            {\n                if(secondGreaterIndex == -1)\n                {\n                    secondGreaterIndex= nextIndex;\n                }\n                else\n                {\n                    result[currentIndex]= inputNumbers[nextIndex];\n                    break;\n                }\n            }\n        }\n    }\n    return result;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findSecondGreater(const vector<int> &input_numbers)\n{\n    int total_numbers= input_numbers.size();\n    vector<int> result(total_numbers, -1);\n    for(int current_index= 0; current_index < total_numbers; current_index++)\n    {\n        for(int next_index= current_index + 1, second_greater_index= -1; next_index < total_numbers; next_index++)\n        {\n            if(input_numbers[next_index] > input_numbers[current_index])\n            {\n                if(second_greater_index == -1)\n                {\n                    second_greater_index= next_index;\n                }\n                else\n                {\n                    result[current_index]= input_numbers[next_index];\n                    break;\n                }\n            }\n        }\n    }\n    return result;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint averageEvenDivisibleByThree(const vector<int> &numbers)\n{\n    int totalSum = 0;\n    int count = 0;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int number = numbers[i];\n        if (number % 2 == 0 && number % 3 == 0)\n        {\n            totalSum += number;\n            count++;\n        }\n    }\n    return count == 0 ? 0 : totalSum / count;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint averageEvenDivisibleByThree(const vector<int> &numbers)\n{\n    int total_sum= 0;\n    int count= 0;\n    for(int number : numbers)\n    {\n        if(number % 2 == 0 && number % 3 == 0)\n        {\n            total_sum+= number;\n            count++;\n        }\n    }\n    return count == 0 ? 0 : total_sum / count;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<string>> getHighestPopularity(vector<string> &creatorNames, vector<string> &videoIds, vector<int> &viewCounts)\n{\n    unordered_map<string, int> creatorPopularity;\n    unordered_map<string, pair<string, int>> mostViewedVideos;\n    for(int index = 0; index < creatorNames.size(); index++)\n    {\n        creatorPopularity[creatorNames[index]] += viewCounts[index];\n        if(!mostViewedVideos.count(creatorNames[index]) || viewCounts[index] > mostViewedVideos[creatorNames[index]].second || (viewCounts[index] == mostViewedVideos[creatorNames[index]].second && videoIds[index] < mostViewedVideos[creatorNames[index]].first))\n        {\n            mostViewedVideos[creatorNames[index]] = {videoIds[index], viewCounts[index]};\n        }\n    }\n\n    int maxPopularity = 0;\n    for(auto it = creatorPopularity.begin(); it != creatorPopularity.end(); ++it)\n    {\n        maxPopularity = max(maxPopularity, it->second);\n    }\n\n    vector<vector<string>> result;\n    for(auto it = creatorPopularity.begin(); it != creatorPopularity.end(); ++it)\n    {\n        if(it->second == maxPopularity)\n        {\n            result.push_back({it->first, mostViewedVideos[it->first].first});\n        }\n    }\n    return result;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<string>> getHighestPopularity(vector<string> &creator_names, vector<string> &video_ids, vector<int> &view_counts)\n{\n    unordered_map<string, int> creator_popularity;\n    unordered_map<string, pair<string, int>> most_viewed_videos;\n    for(int index= 0; index < creator_names.size(); index++)\n    {\n        creator_popularity[creator_names[index]] += view_counts[index];\n        if(!most_viewed_videos.count(creator_names[index]) || view_counts[index] > most_viewed_videos[creator_names[index]].second || (view_counts[index] == most_viewed_videos[creator_names[index]].second && video_ids[index] < most_viewed_videos[creator_names[index]].first))\n        {\n            most_viewed_videos[creator_names[index]] = {video_ids[index], view_counts[index]};\n        }\n    }\n\n    int max_popularity = 0;\n    for(auto &[creator, popularity] : creator_popularity)\n    {\n        max_popularity = max(max_popularity, popularity);\n    }\n\n    vector<vector<string>> result;\n    for(auto &[creator, popularity] : creator_popularity)\n    {\n        if(popularity == max_popularity)\n        {\n            result.push_back({creator, most_viewed_videos[creator].first});\n        }\n    }\n    return result;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint digitSum(int number)\n{\n    int totalSum= 0;\n    while(number)\n    {\n        totalSum+= number % 10;\n        number/= 10;\n    }\n    return totalSum;\n}\n\nint minimumBeautiful(int baseNumber, int targetSum)\n{\n    int increment= 0;\n    while(digitSum(baseNumber + increment) > targetSum)\n    {\n        ++increment;\n    }\n    return increment;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int digitSum(int number)\n{\n    int total_sum= 0;\n    while(number)\n    {\n        total_sum+= number % 10;\n        number/= 10;\n    }\n    return total_sum;\n}\n\nint minimumBeautiful(int base_number, int target_sum)\n{\n    int increment= 0;\n    while(digitSum(base_number + increment) > target_sum)\n    {\n        ++increment;\n    }\n    return increment;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nclass Solution\n{\n  public:\n    vector<int> removeSubtrees(TreeNode *rootNode, vector<int> &queries)\n    {\n        vector<int> answer(queries.size());\n\n        for(int i= 0; i < queries.size(); ++i)\n        {\n            removeSubtree(rootNode, queries[i]);\n            answer[i]= findHeight(rootNode);\n        }\n\n        return answer;\n    }\n\n    void removeSubtree(TreeNode *currentNode, int value)\n    {\n        if(currentNode == NULL)\n            return;\n\n        if(currentNode->leftChild && currentNode->leftChild->value == value)\n            currentNode->leftChild= NULL;\n        else\n            removeSubtree(currentNode->leftChild, value);\n\n        if(currentNode->rightChild && currentNode->rightChild->value == value)\n            currentNode->rightChild= NULL;\n        else\n            removeSubtree(currentNode->rightChild, value);\n    }\n\n    int findHeight(TreeNode *currentNode)\n    {\n        if(currentNode == NULL)\n            return -1;\n\n        return 1 + max(findHeight(currentNode->leftChild), findHeight(currentNode->rightChild));\n    }\n};### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nclass Solution\n{\n  public:\n    vector<int> removeSubtrees(TreeNode *root_node, vector<int> &queries)\n    {\n        vector<int> answer(queries.size());\n\n        for(int i= 0; i < queries.size(); ++i)\n        {\n            removeSubtree(root_node, queries[i]);\n            answer[i]= findHeight(root_node);\n        }\n\n        return answer;\n    }\n\n    void removeSubtree(TreeNode *current_node, int value)\n    {\n        if(current_node == NULL)\n            return;\n\n        if(current_node->left_child && current_node->left_child->value == value)\n            current_node->left_child= NULL;\n        else\n            removeSubtree(current_node->left_child, value);\n\n        if(current_node->right_child && current_node->right_child->value == value)\n            current_node->right_child= NULL;\n        else\n            removeSubtree(current_node->right_child, value);\n    }\n\n    int findHeight(TreeNode *current_node)\n    {\n        if(current_node == NULL)\n            return -1;\n\n        return 1 + max(findHeight(current_node->left_child), findHeight(current_node->right_child));\n    }\n};"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numberList)\n{\n    int size= numberList.size();\n    int indexOfZero= -1;\n\n    for(int index= 0; index < size; index++)\n    {\n        if(numberList[index] == 0)\n        {\n            indexOfZero= index;\n            break;\n        }\n    }\n\n    int countIncrements= 0, countDecrements= 0;\n\n    for(int index= 1; index < size; index++)\n    {\n        if(abs(numberList[index] - numberList[index - 1]) != 1)\n        {\n            countIncrements+= abs(numberList[index] - numberList[index - 1]) - 1;\n        }\n    }\n\n    for(int index= indexOfZero + 1; index < size; index++)\n    {\n        if(numberList[index] < numberList[index - 1])\n        {\n            countDecrements++;\n        }\n    }\n\n    return min(countIncrements, countDecrements);\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &number_list)\n{\n    int size= number_list.size();\n    int index_of_zero= -1;\n\n    for(int index= 0; index < size; index++)\n    {\n        if(number_list[index] == 0)\n        {\n            index_of_zero= index;\n            break;\n        }\n    }\n\n    int count_increments= 0, count_decrements= 0;\n\n    for(int index= 1; index < size; index++)\n    {\n        if(abs(number_list[index] - number_list[index - 1]) != 1)\n        {\n            count_increments+= abs(number_list[index] - number_list[index - 1]) - 1;\n        }\n    }\n\n    for(int index= index_of_zero + 1; index < size; index++)\n    {\n        if(number_list[index] < number_list[index - 1])\n        {\n            count_decrements++;\n        }\n    }\n\n    return min(count_increments, count_decrements);\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> performOps(vector<int> &numberList)\n{\n    int listSize= numberList.size();\n    for(int currentIndex= 0; currentIndex < listSize - 1; ++currentIndex)\n    {\n        if(numberList[currentIndex] == numberList[currentIndex + 1])\n        {\n            numberList[currentIndex]*= 2;\n            numberList[currentIndex + 1]= 0;\n        }\n    }\n    int nonZeroCount= 0;\n    for(int currentIndex= 0; currentIndex < listSize; ++currentIndex)\n    {\n        if(numberList[currentIndex] != 0)\n        {\n            numberList[nonZeroCount++]= numberList[currentIndex];\n        }\n    }\n    while(nonZeroCount < listSize)\n    {\n        numberList[nonZeroCount++]= 0;\n    }\n    return numberList;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> performOps(vector<int> &number_list)\n{\n    int list_size= number_list.size();\n    for(int current_index= 0; current_index < list_size - 1; ++current_index)\n    {\n        if(number_list[current_index] == number_list[current_index + 1])\n        {\n            number_list[current_index]*= 2;\n            number_list[current_index + 1]= 0;\n        }\n    }\n    int non_zero_count= 0;\n    for(int current_index= 0; current_index < list_size; ++current_index)\n    {\n        if(number_list[current_index] != 0)\n        {\n            number_list[non_zero_count++]= number_list[current_index];\n        }\n    }\n    while(non_zero_count < list_size)\n    {\n        number_list[non_zero_count++]= 0;\n    }\n    return number_list;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSubarraySumWithDistinctElements(vector<int> &numbers, int windowSize)\n{\n    int maxSum = 0, currentWindowSum = 0;\n    unordered_map<int, int> frequencyMap;\n\n    for (int index = 0; index < numbers.size(); index++)\n    {\n        frequencyMap[numbers[index]]++;\n        currentWindowSum += numbers[index];\n        if (index >= windowSize)\n        {\n            frequencyMap[numbers[index - windowSize]]--;\n            currentWindowSum -= numbers[index - windowSize];\n        }\n        if (index >= windowSize - 1)\n        {\n            bool isDistinct = true;\n            // Modify the range-based for loop to a traditional for loop\n            for (int i = 0; i < frequencyMap.size(); ++i)\n            {\n                auto it = frequencyMap.begin();\n                advance(it, i);\n                if (it->second > 1)\n                {\n                    isDistinct = false;\n                    break;\n                }\n            }\n            if (isDistinct)\n            {\n                maxSum = max(maxSum, currentWindowSum);\n            }\n        }\n    }\n    return maxSum;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSubarraySumWithDistinctElements(vector<int> &numbers, int window_size)\n{\n    int max_sum= 0, current_window_sum= 0;\n    unordered_map<int, int> frequency_map;\n\n    for(int index= 0; index < numbers.size(); index++)\n    {\n        frequency_map[numbers[index]]++;\n        current_window_sum+= numbers[index];\n        if(index >= window_size)\n        {\n            frequency_map[numbers[index - window_size]]--;\n            current_window_sum-= numbers[index - window_size];\n        }\n        if(index >= window_size - 1)\n        {\n            bool is_distinct= true;\n            for(const auto &pair : frequency_map)\n            {\n                if(pair.second > 1)\n                {\n                    is_distinct= false;\n                    break;\n                }\n            }\n            if(is_distinct)\n            {\n                max_sum= max(max_sum, current_window_sum);\n            }\n        }\n    }\n    return max_sum;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint hireWorkers(vector<int> &workerCosts, int numberOfWorkers, int candidateLimit)\n{\n    int totalCosts= workerCosts.size();\n    vector<pair<int, int>> workers;\n    for(int i= 0; i < totalCosts; ++i)\n        workers.emplace_back(workerCosts[i], i);\n    sort(workers.begin(), workers.end());\n\n    int totalCost= 0;\n    for(int i= 0; i < numberOfWorkers; ++i)\n    {\n        if(min(workers[i].second, totalCosts - workers[i].second - 1) < candidateLimit)\n            totalCost+= workers[i].first;\n    }\n    return totalCost;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint hireWorkers(vector<int> &worker_costs, int number_of_workers, int candidate_limit)\n{\n    int total_costs= worker_costs.size();\n    vector<pair<int, int>> workers;\n    for(int i= 0; i < total_costs; ++i)\n        workers.emplace_back(worker_costs[i], i);\n    sort(workers.begin(), workers.end());\n\n    int total_cost= 0;\n    for(int i= 0; i < number_of_workers; ++i)\n    {\n        if(min(workers[i].second, total_costs - workers[i].second - 1) < candidate_limit)\n            total_cost+= workers[i].first;\n    }\n    return total_cost;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\n// for abs\nusing namespace std;\n\nint calculateMinimumTotalDistance(vector<int> &robotPositions, vector<vector<int>> &factoryLocations)\n{\n    sort(robotPositions.begin(), robotPositions.end());\n    sort(factoryLocations.begin(), factoryLocations.end());\n\n    int totalDistance = 0, robotIndex = 0;\n    for (int i = 0; i < factoryLocations.size(); ++i)\n    {\n        const auto &factory = factoryLocations[i];\n        int availableCapacity = factory[1];\n        while (availableCapacity-- > 0 && robotIndex < robotPositions.size())\n        {\n            totalDistance += abs(factory[0] - robotPositions[robotIndex]);\n            robotIndex++;\n        }\n    }\n\n    return totalDistance;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMinimumTotalDistance(vector<int> &robot_positions, vector<vector<int>> &factory_locations)\n{\n    sort(robot_positions.begin(), robot_positions.end());\n    sort(factory_locations.begin(), factory_locations.end());\n\n    int total_distance= 0, robot_index= 0;\n    for(const auto &factory : factory_locations)\n    {\n        int available_capacity= factory[1];\n        while(available_capacity-- > 0 && robot_index < robot_positions.size())\n        {\n            total_distance+= abs(factory[0] - robot_positions[robot_index]);\n            robot_index++;\n        }\n    }\n\n    return total_distance;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minValidSubarrays(vector<int> &numberList)\n{\n    int subarrayCount= 0;\n    for(int currentIndex= 0; currentIndex < numberList.size(); currentIndex++)\n    {\n        while(currentIndex < numberList.size() && gcd(numberList[currentIndex], numberList.back()) == 1)\n        {\n            currentIndex++;\n        }\n        if(currentIndex < numberList.size())\n        {\n            subarrayCount++;\n            numberList.pop_back();\n        }\n    }\n    return subarrayCount > 0 ? subarrayCount : -1;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minValidSubarrays(vector<int> &number_list)\n{\n    int subarray_count= 0;\n    for(int current_index= 0; current_index < number_list.size(); current_index++)\n    {\n        while(current_index < number_list.size() && gcd(number_list[current_index], number_list.back()) == 1)\n        {\n            current_index++;\n        }\n        if(current_index < number_list.size())\n        {\n            subarray_count++;\n            number_list.pop_back();\n        }\n    }\n    return subarray_count > 0 ? subarray_count : -1;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint distinctAverages(vector<int> &numberList)\n{\n    set<double> uniqueAverages;\n    sort(numberList.begin(), numberList.end());\n    int listSize= numberList.size();\n    for(int index= 0; index < listSize / 2; index++)\n    {\n        uniqueAverages.insert((numberList[index] + numberList[listSize - 1 - index]) / 2.0);\n    }\n    return uniqueAverages.size();\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint distinctAverages(vector<int> &number_list)\n{\n    set<double> unique_averages;\n    sort(number_list.begin(), number_list.end());\n    int list_size= number_list.size();\n    for(int index= 0; index < list_size / 2; index++)\n    {\n        unique_averages.insert((number_list[index] + number_list[list_size - 1 - index]) / 2.0);\n    }\n    return unique_averages.size();\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint modulusPower(long base, int exponent, int modulus)\n{\n    long result= 1;\n    while(exponent > 0)\n    {\n        if(exponent % 2 == 1)\n        {\n            result= (result * base) % modulus;\n        }\n        base= (base * base) % modulus;\n        exponent/= 2;\n    }\n    return (int)result;\n}\n\nint countGoodStrings(int minLength, int maxLength, int zeroCount, int oneCount)\n{\n    long modulus= 1000000007;\n    return (((modulusPower(2, maxLength, modulus) - modulusPower(2, minLength - 1, modulus) + 1) * (zeroCount + 1)) % modulus * (oneCount + 1)) % modulus;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int modulusPower(long base, int exponent, int modulus)\n{\n    long result= 1;\n    while(exponent > 0)\n    {\n        if(exponent % 2 == 1)\n        {\n            result= (result * base) % modulus;\n        }\n        base= (base * base) % modulus;\n        exponent/= 2;\n    }\n    return (int)result;\n}\n\nint countGoodStrings(int min_length, int max_length, int zero_count, int one_count)\n{\n    long modulus= 1000000007;\n    return (((modulusPower(2, max_length, modulus) - modulusPower(2, min_length - 1, modulus) + 1) * (zero_count + 1)) % modulus * (one_count + 1)) % modulus;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid depthFirstSearch(int currentNode, int parentNode, int bobTime, int currentTime, int &aliceIncome, int &maximumIncome, vector<int> &amounts, unordered_map<int, vector<int>> &tree)\n{\n    if(currentTime < bobTime || amounts[currentNode] >= 0)\n    {\n        aliceIncome += amounts[currentNode];\n    }\n    else\n    {\n        aliceIncome += amounts[currentNode] / 2;\n    }\n    amounts[currentNode] = 0;\n    bool isLeafNode = true;\n    for(int j = 0; j < tree[currentNode].size(); ++j)\n    {\n        int childNode = tree[currentNode][j];\n        if(childNode != parentNode)\n        {\n            isLeafNode = false;\n            int temporaryIncome = aliceIncome;\n            depthFirstSearch(childNode, currentNode, bobTime, currentTime + 1, temporaryIncome, maximumIncome, amounts, tree);\n        }\n    }\n    if(isLeafNode)\n    {\n        maximumIncome = max(maximumIncome, aliceIncome);\n    }\n}\n\nint calculateMaxNetIncome(vector<vector<int>> &edges, int bobTime, vector<int> &amounts)\n{\n    unordered_map<int, vector<int>> tree;\n    for(const auto &edge : edges)\n    {\n        tree[edge[0]].emplace_back(edge[1]);\n        tree[edge[1]].emplace_back(edge[0]);\n    }\n    int maximumIncome = -100000;\n    int aliceIncome = 0;\n    depthFirstSearch(0, -1, bobTime, 0, aliceIncome, maximumIncome, amounts, tree);\n    return maximumIncome;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid depthFirstSearch(int current_node, int parent_node, int bob_time, int current_time, int &alice_income, int &maximum_income, vector<int> &amounts, unordered_map<int, vector<int>> &tree)\n{\n    if(current_time < bob_time || amounts[current_node] >= 0)\n    {\n        alice_income += amounts[current_node];\n    }\n    else\n    {\n        alice_income += amounts[current_node] / 2;\n    }\n    amounts[current_node] = 0;\n    bool is_leaf_node = true;\n    for(int child_node : tree[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            is_leaf_node = false;\n            int temporary_income = alice_income;\n            depthFirstSearch(child_node, current_node, bob_time, current_time + 1, temporary_income, maximum_income, amounts, tree);\n        }\n    }\n    if(is_leaf_node)\n    {\n        maximum_income = max(maximum_income, alice_income);\n    }\n}\n\nint calculateMaxNetIncome(vector<vector<int>> &edges, int bob_time, vector<int> &amounts)\n{\n    unordered_map<int, vector<int>> tree;\n    for(const auto &edge : edges)\n    {\n        tree[edge[0]].emplace_back(edge[1]);\n        tree[edge[1]].emplace_back(edge[0]);\n    }\n    int maximum_income = -100000;\n    int alice_income = 0;\n    depthFirstSearch(0, -1, bob_time, 0, alice_income, maximum_income, amounts, tree);\n    return maximum_income;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> splitMessage(string inputMessage, int characterLimit)\n{\n    int messageLength= inputMessage.size();\n    int extraCharacters= (characterLimit - 3) * (messageLength / (characterLimit - 3)) - messageLength;\n    int fullParts= messageLength / (characterLimit - 3);\n    if((messageLength + fullParts + extraCharacters) % (characterLimit - 2) != 0)\n        return {};\n    int numberOfParts= (messageLength + fullParts + extraCharacters) / (characterLimit - 2);\n    vector<string> messageParts;\n    for(int currentIndex= 0, partIndex= 1, characterCount= 0; currentIndex < messageLength || partIndex <= numberOfParts;)\n    {\n        string tempPart;\n        while(characterCount < characterLimit - 3)\n        {\n            characterCount++;\n            tempPart+= inputMessage[currentIndex++];\n            if(currentIndex == messageLength)\n                break;\n        }\n        characterCount= 0;\n        tempPart+= to_string(partIndex) + \"/\" + to_string(numberOfParts) + \" \";\n        partIndex++;\n        messageParts.push_back(tempPart);\n    }\n    return messageParts;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> splitMessage(string input_message, int character_limit)\n{\n    int message_length= input_message.size();\n    int extra_characters= (character_limit - 3) * (message_length / (character_limit - 3)) - message_length;\n    int full_parts= message_length / (character_limit - 3);\n    if((message_length + full_parts + extra_characters) % (character_limit - 2) != 0)\n        return {};\n    int number_of_parts= (message_length + full_parts + extra_characters) / (character_limit - 2);\n    vector<string> message_parts;\n    for(int current_index= 0, part_index= 1, character_count= 0; current_index < message_length || part_index <= number_of_parts;)\n    {\n        string temp_part;\n        while(character_count < character_limit - 3)\n        {\n            character_count++;\n            temp_part+= input_message[current_index++];\n            if(current_index == message_length)\n                break;\n        }\n        character_count= 0;\n        temp_part+= to_string(part_index) + \"/\" + to_string(number_of_parts) + \" \";\n        part_index++;\n        message_parts.push_back(temp_part);\n    }\n    return message_parts;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<double> convertTemperature(double celsiusTemperature)\n{\n    double kelvinTemperature = celsiusTemperature + 273.15;\n    double fahrenheitTemperature = celsiusTemperature * 1.80 + 32.00;\n    return {kelvinTemperature, fahrenheitTemperature};\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<double> convertTemperature(double celsius_temperature)\n{\n    double kelvin_temperature = celsius_temperature + 273.15;\n    double fahrenheit_temperature = celsius_temperature * 1.80 + 32.00;\n    return {kelvin_temperature, fahrenheit_temperature};\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lcm(int firstNumber, int secondNumber)\n{\n    int currentMultiple= firstNumber;\n    while((currentMultiple % secondNumber) != 0)\n    {\n        currentMultiple+= firstNumber;\n    }\n    return currentMultiple;\n}\n\nint countLcmSubarrays(vector<int> &numberArray, int targetLcm)\n{\n    int subarrayCount= 0;\n    for(int startIndex= 0; startIndex < numberArray.size(); startIndex++)\n    {\n        int currentLcm= numberArray[startIndex];\n        for(int endIndex= startIndex; endIndex < numberArray.size(); endIndex++)\n        {\n            currentLcm= lcm(currentLcm, numberArray[endIndex]);\n            if(currentLcm == targetLcm)\n            {\n                subarrayCount++;\n            }\n        }\n    }\n    return subarrayCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint lcm(int first_number, int second_number)\n{\n    int current_multiple = first_number;\n    while ((current_multiple % second_number) != 0)\n    {\n        current_multiple += first_number;\n    }\n    return current_multiple;\n}\n\nint countLcmSubarrays(vector<int> &number_array, int target_lcm)\n{\n    int subarray_count = 0;\n    for (int start_index = 0; start_index < number_array.size(); start_index++)\n    {\n        int current_lcm = number_array[start_index];\n        for (int end_index = start_index; end_index < number_array.size(); end_index++)\n        {\n            current_lcm = lcm(current_lcm, number_array[end_index]);\n            if (current_lcm == target_lcm)\n            {\n                subarray_count++;\n            }\n        }\n    }\n    return subarray_count;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nint calculateMinSwaps(TreeNode *rootNode)\n{\n    int swapCount= 0;\n    queue<pair<TreeNode *, int>> nodeQueue;\n    nodeQueue.push({rootNode, 0});\n\n    vector<int> levelValues;\n    int previousDepth= -1;\n\n    while(!nodeQueue.empty())\n    {\n        auto currentNode= nodeQueue.front();\n        nodeQueue.pop();\n        TreeNode *currentTreeNode= currentNode.first;\n        int currentDepth= currentNode.second;\n\n        if(previousDepth != currentDepth)\n        {\n            sort(levelValues.begin(), levelValues.end());\n            for(int i= 1; i < levelValues.size(); ++i)\n            {\n                swapCount+= abs(levelValues[i] - levelValues[i - 1]) - 1;\n            }\n            previousDepth= currentDepth;\n            levelValues.clear();\n        }\n        levelValues.push_back(currentTreeNode->value);\n\n        if(currentTreeNode->leftChild)\n            nodeQueue.push({currentTreeNode->leftChild, currentDepth + 1});\n        if(currentTreeNode->rightChild)\n            nodeQueue.push({currentTreeNode->rightChild, currentDepth + 1});\n    }\n\n    sort(levelValues.begin(), levelValues.end());\n    for(int i= 1; i < levelValues.size(); ++i)\n    {\n        swapCount+= abs(levelValues[i] - levelValues[i - 1]) - 1;\n    }\n\n    return swapCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nint calculateMinSwaps(TreeNode *root_node)\n{\n    int swap_count= 0;\n    queue<pair<TreeNode *, int>> node_queue;\n    node_queue.push({root_node, 0});\n\n    vector<int> level_values;\n    int previous_depth= -1;\n\n    while(!node_queue.empty())\n    {\n        auto current_node= node_queue.front();\n        node_queue.pop();\n        TreeNode *current_tree_node= current_node.first;\n        int current_depth= current_node.second;\n\n        if(previous_depth != current_depth)\n        {\n            sort(level_values.begin(), level_values.end());\n            for(int i= 1; i < level_values.size(); ++i)\n            {\n                swap_count+= abs(level_values[i] - level_values[i - 1]) - 1;\n            }\n            previous_depth= current_depth;\n            level_values.clear();\n        }\n        level_values.push_back(current_tree_node->value);\n\n        if(current_tree_node->left_child)\n            node_queue.push({current_tree_node->left_child, current_depth + 1});\n        if(current_tree_node->right_child)\n            node_queue.push({current_tree_node->right_child, current_depth + 1});\n    }\n\n    sort(level_values.begin(), level_values.end());\n    for(int i= 1; i < level_values.size(); ++i)\n    {\n        swap_count+= abs(level_values[i] - level_values[i - 1]) - 1;\n    }\n\n    return swap_count;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countMaxPalindromicSubstrings(string inputString, int minLength)\n{\n    int stringLength= inputString.size();\n    if(stringLength < minLength)\n    {\n        return 0;\n    }\n    int palindromeCount= 0;\n    vector<vector<bool>> isPalindrome(stringLength, vector<bool>(stringLength, false));\n    for(int startIndex= stringLength - 1; startIndex >= 0; startIndex--)\n    {\n        for(int endIndex= startIndex; endIndex < stringLength; endIndex++)\n        {\n            if(startIndex == endIndex)\n            {\n                isPalindrome[startIndex][endIndex]= true;\n            }\n            else if(inputString[startIndex] == inputString[endIndex])\n            {\n                isPalindrome[startIndex][endIndex]= startIndex + 1 > endIndex - 1 || isPalindrome[startIndex + 1][endIndex - 1];\n            }\n            else\n            {\n                isPalindrome[startIndex][endIndex]= false;\n            }\n            if(endIndex - startIndex + 1 >= minLength && isPalindrome[startIndex][endIndex])\n            {\n                palindromeCount++;\n                startIndex= endIndex;\n                break;\n            }\n        }\n    }\n    return palindromeCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countMaxPalindromicSubstrings(string input_string, int min_length)\n{\n    int string_length= input_string.size();\n    if(string_length < min_length)\n    {\n        return 0;\n    }\n    int palindrome_count= 0;\n    vector<vector<bool>> is_palindrome(string_length, vector<bool>(string_length, false));\n    for(int start_index= string_length - 1; start_index >= 0; start_index--)\n    {\n        for(int end_index= start_index; end_index < string_length; end_index++)\n        {\n            if(start_index == end_index)\n            {\n                is_palindrome[start_index][end_index]= true;\n            }\n            else if(input_string[start_index] == input_string[end_index])\n            {\n                is_palindrome[start_index][end_index]= start_index + 1 > end_index - 1 || is_palindrome[start_index + 1][end_index - 1];\n            }\n            else\n            {\n                is_palindrome[start_index][end_index]= false;\n            }\n            if(end_index - start_index + 1 >= min_length && is_palindrome[start_index][end_index])\n            {\n                palindrome_count++;\n                start_index= end_index;\n                break;\n            }\n        }\n    }\n    return palindrome_count;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> minTotalCost(int numberOfCities, vector<vector<int>> &roads, vector<int> &appleCosts, int k)\n{\n    vector<vector<pair<int, int>>> cityGraph(numberOfCities + 1);\n    for (int i = 0; i < roads.size(); ++i)\n    {\n        cityGraph[roads[i][0]].push_back({roads[i][1], roads[i][2]});\n        cityGraph[roads[i][1]].push_back({roads[i][0], roads[i][2]});\n    }\n\n    vector<int> totalCosts(numberOfCities);\n    for (int startCity = 1; startCity <= numberOfCities; ++startCity)\n    {\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> minHeap;\n        vector<int> distance(numberOfCities + 1, 1e9);\n        distance[startCity] = 0;\n        minHeap.push({0, startCity});\n        while (!minHeap.empty())\n        {\n            int currentCity = minHeap.top().second;\n            int currentDistance = minHeap.top().first;\n            minHeap.pop();\n\n            if (currentDistance > distance[currentCity])\n                continue;\n\n            for (int j = 0; j < cityGraph[currentCity].size(); ++j)\n            {\n                int adjacentCity = cityGraph[currentCity][j].first;\n                int cost = currentDistance + cityGraph[currentCity][j].second + (currentCity != startCity ? cityGraph[currentCity][j].second * k : 0) + appleCosts[adjacentCity - 1];\n\n                if (cost < distance[adjacentCity])\n                {\n                    distance[adjacentCity] = cost;\n                    minHeap.push({cost, adjacentCity});\n                }\n            }\n        }\n\n        totalCosts[startCity - 1] = distance[startCity];\n    }\n    return totalCosts;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> minTotalCost(int number_of_cities, vector<vector<int>> &roads, vector<int> &apple_costs, int k)\n{\n    vector<vector<pair<int, int>>> city_graph(number_of_cities + 1);\n    for(auto &road : roads)\n    {\n        city_graph[road[0]].push_back({road[1], road[2]});\n        city_graph[road[1]].push_back({road[0], road[2]});\n    }\n\n    vector<int> total_costs(number_of_cities);\n    for(int start_city= 1; start_city <= number_of_cities; ++start_city)\n    {\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> min_heap;\n        vector<int> distance(number_of_cities + 1, 1e9);\n        distance[start_city]= 0;\n        min_heap.push({0, start_city});\n        while(!min_heap.empty())\n        {\n            int current_city= min_heap.top().second;\n            int current_distance= min_heap.top().first;\n            min_heap.pop();\n\n            if(current_distance > distance[current_city])\n                continue;\n\n            for(auto &edge : city_graph[current_city])\n            {\n                int adjacent_city= edge.first;\n                int cost= current_distance + edge.second + (current_city != start_city ? edge.second * k : 0) + apple_costs[adjacent_city - 1];\n\n                if(cost < distance[adjacent_city])\n                {\n                    distance[adjacent_city]= cost;\n                    min_heap.push({cost, adjacent_city});\n                }\n            }\n        }\n\n        total_costs[start_city - 1]= distance[start_city];\n    }\n    return total_costs;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countTriplets(vector<int> &numberList)\n{\n    int tripletCount= 0;\n    int listSize= numberList.size();\n\n    for(int firstIndex= 0; firstIndex < listSize; firstIndex++)\n    {\n        for(int secondIndex= firstIndex + 1; secondIndex < listSize; secondIndex++)\n        {\n            for(int thirdIndex= secondIndex + 1; thirdIndex < listSize; thirdIndex++)\n            {\n                if(numberList[firstIndex] != numberList[secondIndex] && numberList[firstIndex] != numberList[thirdIndex] && numberList[secondIndex] != numberList[thirdIndex])\n                {\n                    tripletCount++;\n                }\n            }\n        }\n    }\n\n    return tripletCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countTriplets(vector<int> &number_list)\n{\n    int triplet_count= 0;\n    int list_size= number_list.size();\n\n    for(int first_index= 0; first_index < list_size; first_index++)\n    {\n        for(int second_index= first_index + 1; second_index < list_size; second_index++)\n        {\n            for(int third_index= second_index + 1; third_index < list_size; third_index++)\n            {\n                if(number_list[first_index] != number_list[second_index] && number_list[first_index] != number_list[third_index] && number_list[second_index] != number_list[third_index])\n                {\n                    triplet_count++;\n                }\n            }\n        }\n    }\n\n    return triplet_count;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nvector<vector<int>> findMinMax(TreeNode *root, vector<int> &queries)\n{\n    if(!root)\n    {\n        return {};\n    }\n\n    vector<vector<int>> result(queries.size(), vector<int>{-1, -1});\n    for(size_t index= 0; index < queries.size(); index++)\n    {\n        TreeNode *currentNode= root;\n        int currentQuery= queries[index];\n        while(currentNode)\n        {\n            if(currentNode->value < currentQuery)\n            {\n                result[index][0]= currentNode->value;\n                currentNode= currentNode->rightChild;\n            }\n            else\n            {\n                result[index][1]= currentNode->value;\n                if(currentNode->value == currentQuery)\n                {\n                    result[index][0]= currentQuery;\n                    break;\n                }\n                currentNode= currentNode->leftChild;\n            }\n        }\n    }\n    return result;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nvector<vector<int>> findMinMax(TreeNode *root, vector<int> &queries)\n{\n    if(!root)\n    {\n        return {};\n    }\n\n    vector<vector<int>> result(queries.size(), vector<int>{-1, -1});\n    for(size_t index= 0; index < queries.size(); index++)\n    {\n        TreeNode *current_node= root;\n        int current_query= queries[index];\n        while(current_node)\n        {\n            if(current_node->value < current_query)\n            {\n                result[index][0]= current_node->value;\n                current_node= current_node->right_child;\n            }\n            else\n            {\n                result[index][1]= current_node->value;\n                if(current_node->value == current_query)\n                {\n                    result[index][0]= current_query;\n                    break;\n                }\n                current_node= current_node->left_child;\n            }\n        }\n    }\n    return result;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMinimumFuel(vector<vector<int>> &roadConnections, int seatCapacity)\n{\n    int numberOfCities = roadConnections.size() + 1;\n    vector<vector<int>> cityGraph(numberOfCities);\n    for (const auto &road : roadConnections) // This can remain as a range-based for loop\n    {\n        cityGraph[road[0]].push_back(road[1]);\n        cityGraph[road[1]].push_back(road[0]);\n    }\n\n    vector<int> cityDistance(numberOfCities, -1);\n    queue<int> cityQueue;\n    cityQueue.push(0);\n    cityDistance[0] = 0;\n\n    while (!cityQueue.empty())\n    {\n        int currentCity = cityQueue.front();\n        cityQueue.pop();\n        for (int neighborCity : cityGraph[currentCity]) // This can remain as a range-based for loop\n        {\n            if (cityDistance[neighborCity] == -1)\n            {\n                cityDistance[neighborCity] = cityDistance[currentCity] + 1;\n                cityQueue.push(neighborCity);\n            }\n        }\n    }\n\n    int totalFuelRequired = 0;\n    for (int cityIndex = 1; cityIndex < numberOfCities; cityIndex++)\n    {\n        totalFuelRequired += (cityDistance[cityIndex] - 1) / (seatCapacity - 1) + 1;\n    }\n    return totalFuelRequired;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMinimumFuel(vector<vector<int>> &road_connections, int seat_capacity)\n{\n    int number_of_cities = road_connections.size() + 1;\n    vector<vector<int>> city_graph(number_of_cities);\n    for(auto &road : road_connections)\n    {\n        city_graph[road[0]].push_back(road[1]);\n        city_graph[road[1]].push_back(road[0]);\n    }\n\n    vector<int> city_distance(number_of_cities, -1);\n    queue<int> city_queue;\n    city_queue.push(0);\n    city_distance[0] = 0;\n\n    while(!city_queue.empty())\n    {\n        int current_city = city_queue.front();\n        city_queue.pop();\n        for(int neighbor_city : city_graph[current_city])\n        {\n            if(city_distance[neighbor_city] == -1)\n            {\n                city_distance[neighbor_city] = city_distance[current_city] + 1;\n                city_queue.push(neighbor_city);\n            }\n        }\n    }\n\n    int total_fuel_required = 0;\n    for(int city_index = 1; city_index < number_of_cities; city_index++)\n    {\n        total_fuel_required += (city_distance[city_index] - 1) / (seat_capacity - 1) + 1;\n    }\n    return total_fuel_required;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint numBeautifulPartitions(const string &inputString, int partitionCount, int minimumLength)\n{\n    const int modulo= 1e9 + 7;\n    unordered_set<char> primeDigits= {'2', '3', '5', '7'};\n    int stringLength= inputString.length();\n    vector<vector<int>> dynamicProgramming(stringLength + 1, vector<int>(partitionCount + 1, 0));\n    dynamicProgramming[0][0]= 1;\n\n    for(int currentIndex= 1; currentIndex <= stringLength; ++currentIndex)\n    {\n        for(int currentPartitions= 1; currentPartitions <= partitionCount; ++currentPartitions)\n        {\n            for(int length= minimumLength; length <= currentIndex && currentIndex - length >= currentPartitions - 1; ++length)\n            {\n                if(primeDigits.count(inputString[currentIndex - length]) && !primeDigits.count(inputString[currentIndex - 1]))\n                {\n                    dynamicProgramming[currentIndex][currentPartitions]+= dynamicProgramming[currentIndex - length][currentPartitions - 1];\n                    if(dynamicProgramming[currentIndex][currentPartitions] >= modulo)\n                        dynamicProgramming[currentIndex][currentPartitions]-= modulo;\n                }\n            }\n        }\n    }\n\n    return dynamicProgramming[stringLength][partitionCount];\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint numBeautifulPartitions(const string &input_string, int partition_count, int minimum_length)\n{\n    const int modulo= 1e9 + 7;\n    unordered_set<char> prime_digits= {'2', '3', '5', '7'};\n    int string_length= input_string.length();\n    vector<vector<int>> dynamic_programming(string_length + 1, vector<int>(partition_count + 1, 0));\n    dynamic_programming[0][0]= 1;\n\n    for(int current_index= 1; current_index <= string_length; ++current_index)\n    {\n        for(int current_partitions= 1; current_partitions <= partition_count; ++current_partitions)\n        {\n            for(int length= minimum_length; length <= current_index && current_index - length >= current_partitions - 1; ++length)\n            {\n                if(prime_digits.count(input_string[current_index - length]) && !prime_digits.count(input_string[current_index - 1]))\n                {\n                    dynamic_programming[current_index][current_partitions]+= dynamic_programming[current_index - length][current_partitions - 1];\n                    if(dynamic_programming[current_index][current_partitions] >= modulo)\n                        dynamic_programming[current_index][current_partitions]-= modulo;\n                }\n            }\n        }\n    }\n\n    return dynamic_programming[string_length][partition_count];\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<vector<int>> &adjacencyList, vector<int> &nodeValues, int &maximumXor)\n{\n    int currentXorSum = nodeValues[currentNode];\n\n    for (int i = 0; i < adjacencyList[currentNode].size(); ++i)\n    {\n        int childNode = adjacencyList[currentNode][i];\n        if (childNode != parentNode)\n        {\n            currentXorSum ^= depthFirstSearch(childNode, currentNode, adjacencyList, nodeValues, maximumXor);\n        }\n    }\n\n    maximumXor = max(maximumXor, currentXorSum);\n\n    return currentXorSum;\n}\n\nint maxXorSubtree(int totalNodes, vector<vector<int>> &edges, vector<int> &nodeValues)\n{\n    vector<vector<int>> adjacencyList(totalNodes);\n\n    for (const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1]);\n        adjacencyList[edge[1]].emplace_back(edge[0]);\n    }\n\n    int maximumXor = 0;\n    int rootXorSum = depthFirstSearch(0, -1, adjacencyList, nodeValues, maximumXor);\n\n    return rootXorSum ^ maximumXor;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<vector<int>> &adjacency_list, vector<int> &node_values, int &maximum_xor)\n{\n    int current_xor_sum= node_values[current_node];\n\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_sum^= depthFirstSearch(child_node, current_node, adjacency_list, node_values, maximum_xor);\n        }\n    }\n\n    maximum_xor= max(maximum_xor, current_xor_sum);\n\n    return current_xor_sum;\n}\n\nint maxXorSubtree(int total_nodes, vector<vector<int>> &edges, vector<int> &node_values)\n{\n    vector<vector<int>> adjacency_list(total_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1]);\n        adjacency_list[edge[1]].emplace_back(edge[0]);\n    }\n\n    int maximum_xor= 0;\n    int root_xor_sum= depthFirstSearch(0, -1, adjacency_list, node_values, maximum_xor);\n\n    return root_xor_sum ^ maximum_xor;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint minCuts(int number)\n{\n    if(number % 2 == 0)\n        return number / 2;\n    else\n        return number;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int minCuts(int number)\n{\n    if(number % 2 == 0)\n        return number / 2;\n    else\n        return number;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> createDifferenceMatrix(vector<vector<int>> &inputGrid)\n{\n    int rowCount= inputGrid.size(), columnCount= inputGrid[0].size();\n    vector<int> rowSum(rowCount, 0), columnSum(columnCount, 0);\n    vector<vector<int>> differenceMatrix(rowCount, vector<int>(columnCount));\n\n    for(int currentRowIndex= 0; currentRowIndex < rowCount; ++currentRowIndex)\n    {\n        for(int currentColIndex= 0; currentColIndex < columnCount; ++currentColIndex)\n        {\n            rowSum[currentRowIndex]+= inputGrid[currentRowIndex][currentColIndex];\n            columnSum[currentColIndex]+= inputGrid[currentRowIndex][currentColIndex];\n        }\n    }\n\n    for(int currentRowIndex= 0; currentRowIndex < rowCount; ++currentRowIndex)\n    {\n        for(int currentColIndex= 0; currentColIndex < columnCount; ++currentColIndex)\n        {\n            differenceMatrix[currentRowIndex][currentColIndex]= rowSum[currentRowIndex] + columnSum[currentColIndex] - (columnCount - rowSum[currentRowIndex]) - (rowCount - columnSum[currentColIndex]);\n        }\n    }\n\n    return differenceMatrix;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> createDifferenceMatrix(vector<vector<int>> &input_grid)\n{\n    int row_count= input_grid.size(), column_count= input_grid[0].size();\n    vector<int> row_sum(row_count, 0), column_sum(column_count, 0);\n    vector<vector<int>> difference_matrix(row_count, vector<int>(column_count));\n\n    for(int current_row_index= 0; current_row_index < row_count; ++current_row_index)\n    {\n        for(int current_col_index= 0; current_col_index < column_count; ++current_col_index)\n        {\n            row_sum[current_row_index]+= input_grid[current_row_index][current_col_index];\n            column_sum[current_col_index]+= input_grid[current_row_index][current_col_index];\n        }\n    }\n\n    for(int current_row_index= 0; current_row_index < row_count; ++current_row_index)\n    {\n        for(int current_col_index= 0; current_col_index < column_count; ++current_col_index)\n        {\n            difference_matrix[current_row_index][current_col_index]= row_sum[current_row_index] + column_sum[current_col_index] - (column_count - row_sum[current_row_index]) - (row_count - column_sum[current_col_index]);\n        }\n    }\n\n    return difference_matrix;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minPenalty(string customerSequence)\n{\n    int customerCount = customerSequence.length();\n    int openPenalty = 0, closedPenalty = 0;\n\n    for (int i = 0; i < customerCount; ++i)\n    {\n        char currentCustomer = customerSequence[i];\n        if (currentCustomer == 'N')\n            openPenalty++;\n        else\n            closedPenalty++;\n    }\n\n    int minimumPenalty = closedPenalty;\n    int currentPenalty = closedPenalty;\n\n    for (int index = 0; index < customerCount; index++)\n    {\n        if (customerSequence[index] == 'N')\n            currentPenalty--;\n        else\n            currentPenalty++;\n\n        minimumPenalty = min(minimumPenalty, currentPenalty);\n    }\n\n    return minimumPenalty;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minPenalty(string customer_sequence)\n{\n    int customer_count= customer_sequence.length();\n    int open_penalty= 0, closed_penalty= 0;\n\n    for(char current_customer : customer_sequence)\n    {\n        if(current_customer == 'N')\n            open_penalty++;\n        else\n            closed_penalty++;\n    }\n\n    int minimum_penalty= closed_penalty;\n    int current_penalty= closed_penalty;\n\n    for(int index= 0; index < customer_count; index++)\n    {\n        if(customer_sequence[index] == 'N')\n            current_penalty--;\n        else\n            current_penalty++;\n\n        minimum_penalty= min(minimum_penalty, current_penalty);\n    }\n\n    return minimum_penalty;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPalindromeSubsequences(string inputString, int modulus)\n{\n    int stringLength= inputString.size();\n    const int modulusValue= 1000000007;\n    vector<vector<int>> dpTable(10, vector<int>(stringLength, 0));\n    for(int i= 0; i < stringLength; ++i)\n        dpTable[inputString[i] - '0'][i]= 1;\n    for(int length= 1; length <= 4; ++length)\n    {\n        for(int digit= 0; digit < 10; ++digit)\n        {\n            for(int i= 0, j= length; j < stringLength; ++i, ++j)\n            {\n                dpTable[digit][j]= (dpTable[digit][j - 1] + (inputString[j] - '0' == digit)) % modulusValue;\n            }\n        }\n    }\n    long long totalCount= 0;\n    for(int firstDigit= 0; firstDigit < 10; ++firstDigit)\n    {\n        for(int secondDigit= 0; secondDigit < 10; ++secondDigit)\n        {\n            totalCount+= (1LL * dpTable[firstDigit][stringLength - 5] * dpTable[secondDigit][stringLength - 1]) % modulusValue;\n        }\n    }\n    return totalCount % modulusValue;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countPalindromeSubsequences(string input_string, int modulus)\n{\n    int string_length= input_string.size();\n    const int modulus_value= 1000000007;\n    vector<vector<int>> dp_table(10, vector<int>(string_length, 0));\n    for(int i= 0; i < string_length; ++i)\n        dp_table[input_string[i] - '0'][i]= 1;\n    for(int length= 1; length <= 4; ++length)\n    {\n        for(int digit= 0; digit < 10; ++digit)\n        {\n            for(int i= 0, j= length; j < string_length; ++i, ++j)\n            {\n                dp_table[digit][j]= (dp_table[digit][j - 1] + (input_string[j] - '0' == digit)) % modulus_value;\n            }\n        }\n    }\n    long long total_count= 0;\n    for(int first_digit= 0; first_digit < 10; ++first_digit)\n    {\n        for(int second_digit= 0; second_digit < 10; ++second_digit)\n        {\n            total_count+= (1LL * dp_table[first_digit][string_length - 5] * dp_table[second_digit][string_length - 1]) % modulus_value;\n        }\n    }\n    return total_count % modulus_value;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint findPivot(int totalNumbers)\n{\n    int totalSum= totalNumbers * (totalNumbers + 1) / 2;\n    int leftSum= 0;\n    for(int currentNumber= 1; currentNumber <= totalNumbers; ++currentNumber)\n    {\n        leftSum+= currentNumber;\n        if(2 * leftSum == totalSum)\n        {\n            return currentNumber;\n        }\n    }\n    return -1;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int findPivot(int total_numbers)\n{\n    int total_sum= total_numbers * (total_numbers + 1) / 2;\n    int left_sum= 0;\n    for(int current_number= 1; current_number <= total_numbers; ++current_number)\n    {\n        left_sum+= current_number;\n        if(2 * left_sum == total_sum)\n        {\n            return current_number;\n        }\n    }\n    return -1;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minAddition(string sourceString, string targetString)\n{\n    int sourceLength = sourceString.length();\n    int targetLength = targetString.length();\n    int sourceIndex = 0, targetIndex = 0;\n    while(sourceIndex < sourceLength && targetIndex < targetLength)\n    {\n        if(sourceString[sourceIndex] == targetString[targetIndex])\n        {\n            targetIndex++;\n        }\n        sourceIndex++;\n    }\n    return targetLength - targetIndex;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minAddition(string source_string, string target_string)\n{\n    int source_length = source_string.length();\n    int target_length = target_string.length();\n    int source_index = 0, target_index = 0;\n    while(source_index < source_length && target_index < target_length)\n    {\n        if(source_string[source_index] == target_string[target_index])\n        {\n            target_index++;\n        }\n        source_index++;\n    }\n    return target_length - target_index;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nclass ListNode\n{\n  public:\n    int value;\n    ListNode *next;\n};\n\nListNode *removeNodes(ListNode *head)\n{\n    if(!head)\n        return NULL;\n    ListNode *maxNode= head;\n    ListNode *currentNode= head;\n    ListNode *previousNode= NULL;\n\n    while(currentNode && currentNode->next)\n    {\n        if(currentNode->next->value > maxNode->value)\n        {\n            if(previousNode)\n                previousNode->next= currentNode->next;\n            else\n                head= currentNode->next;\n            maxNode= currentNode->next;\n        }\n        else\n        {\n            previousNode= currentNode;\n        }\n        currentNode= currentNode->next;\n    }\n    maxNode->next= removeNodes(maxNode->next);\n    return head;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "class ListNode\n{\n  public:\n    int value;\n    ListNode *next;\n};\n\nListNode *removeNodes(ListNode *head)\n{\n    if(!head)\n        return NULL;\n    ListNode *max_node= head;\n    ListNode *current_node= head;\n    ListNode *previous_node= NULL;\n\n    while(current_node && current_node->next)\n    {\n        if(current_node->next->value > max_node->value)\n        {\n            if(previous_node)\n                previous_node->next= current_node->next;\n            else\n                head= current_node->next;\n            max_node= current_node->next;\n        }\n        else\n        {\n            previous_node= current_node;\n        }\n        current_node= current_node->next;\n    }\n    max_node->next= removeNodes(max_node->next);\n    return head;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countSubarraysWithMedian(vector<int> &numbers, int target)\n{\n    int resultCount = 0;\n    for(int startIndex = 0; startIndex < numbers.size(); ++startIndex)\n    {\n        int targetCount = 0;\n        vector<int> subarray;\n        for(int endIndex = startIndex; endIndex < numbers.size(); ++endIndex)\n        {\n            targetCount += (numbers[endIndex] == target);\n            subarray.insert(lower_bound(subarray.begin(), subarray.end(), numbers[endIndex]), numbers[endIndex]);\n            if((subarray.size() % 2 == 1) && (subarray[subarray.size() / 2] == target))\n            {\n                resultCount += targetCount;\n            }\n        }\n    }\n    return resultCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countSubarraysWithMedian(vector<int> &numbers, int target)\n{\n    int result_count = 0;\n    for(int start_index = 0; start_index < numbers.size(); ++start_index)\n    {\n        int target_count = 0;\n        vector<int> subarray;\n        for(int end_index = start_index; end_index < numbers.size(); ++end_index)\n        {\n            target_count += (numbers[end_index] == target);\n            subarray.insert(lower_bound(subarray.begin(), subarray.end(), numbers[end_index]), numbers[end_index]);\n            if((subarray.size() % 2 == 1) && (subarray[subarray.size() / 2] == target))\n            {\n                result_count += target_count;\n            }\n        }\n    }\n    return result_count;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateRatioSubstringCount(string inputString, int firstNum, int secondNum)\n{\n    int zeroCount = 0, oneCount = 0;\n    map<int, int> frequencyMap;\n    int substringCount = 0;\n\n    frequencyMap[0] = 1;\n\n    for (int i = 0; i < inputString.size(); ++i)\n    {\n        char currentChar = inputString[i];\n        if (currentChar == '0')\n            zeroCount++;\n        else\n            oneCount++;\n\n        int currentDifference = zeroCount * secondNum - oneCount * firstNum;\n        substringCount += frequencyMap[currentDifference];\n        frequencyMap[currentDifference]++;\n    }\n    return substringCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateRatioSubstringCount(string input_string, int first_num, int second_num)\n{\n    int zero_count= 0, one_count= 0;\n    map<int, int> frequency_map;\n    int substring_count= 0;\n\n    frequency_map[0]= 1;\n\n    for(char current_char : input_string)\n    {\n        if(current_char == '0')\n            zero_count++;\n        else\n            one_count++;\n\n        int current_difference= zero_count * second_num - one_count * first_num;\n        substring_count+= frequency_map[current_difference];\n        frequency_map[current_difference]++;\n    }\n    return substring_count;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isCircular(string sentence)\n{\n    stringstream stream(sentence);\n    string currentWord, previousWord;\n\n    while(stream >> currentWord)\n    {\n        if(!previousWord.empty() && previousWord.back() != currentWord.front())\n        {\n            return false;\n        }\n        previousWord = currentWord;\n    }\n\n    return currentWord.back() == sentence.front();\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isCircular(string sentence)\n{\n    stringstream stream(sentence);\n    string current_word, previous_word;\n\n    while(stream >> current_word)\n    {\n        if(!previous_word.empty() && previous_word.back() != current_word.front())\n        {\n            return false;\n        }\n        previous_word = current_word;\n    }\n\n    return current_word.back() == sentence.front();\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maximumChemistry(vector<int> &skillLevels)\n{\n    int totalSum = 0;\n    for (int i = 0; i < skillLevels.size(); ++i)\n    {\n        totalSum += skillLevels[i];\n    }\n    int targetSum = totalSum / 2;\n    if (totalSum % 2 == 1)\n        return -1;\n\n    unordered_map<int, int> dynamicProgrammingMap;\n    dynamicProgrammingMap[0] = 1;\n    int maxChemistry = 0;\n\n    for (int i = 0; i < skillLevels.size(); ++i)\n    {\n        int skill = skillLevels[i];\n        for (int j = targetSum - skill; j >= 0; j--)\n        {\n            if (dynamicProgrammingMap[j])\n            {\n                dynamicProgrammingMap[j + skill] += dynamicProgrammingMap[j];\n                if (j + skill == targetSum)\n                {\n                    maxChemistry += dynamicProgrammingMap[j] * skill;\n                }\n            }\n        }\n    }\n\n    return (maxChemistry > 0) ? maxChemistry : -1;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maximumChemistry(vector<int> &skill_levels)\n{\n    int total_sum= 0;\n    for(int skill : skill_levels)\n    {\n        total_sum+= skill;\n    }\n    int target_sum= total_sum / 2;\n    if(total_sum % 2 == 1)\n        return -1;\n\n    unordered_map<int, int> dynamic_programming_map;\n    dynamic_programming_map[0]= 1;\n    int max_chemistry= 0;\n\n    for(int skill : skill_levels)\n    {\n        for(int i= target_sum - skill; i >= 0; i--)\n        {\n            if(dynamic_programming_map[i])\n            {\n                dynamic_programming_map[i + skill]+= dynamic_programming_map[i];\n                if(i + skill == target_sum)\n                {\n                    max_chemistry+= dynamic_programming_map[i] * skill;\n                }\n            }\n        }\n    }\n\n    return (max_chemistry > 0) ? max_chemistry : -1;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumScore(int totalCities, vector<vector<int>> &roads)\n{\n    vector<vector<pair<int, int>>> adjacencyList(totalCities + 1);\n    for (int i = 0; i < roads.size(); ++i)\n    {\n        adjacencyList[roads[i][0]].push_back({roads[i][1], roads[i][2]});\n        adjacencyList[roads[i][1]].push_back({roads[i][0], roads[i][2]});\n    }\n\n    const int infinity = 1e9;\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> priorityQueue;\n    priorityQueue.push({0, 1});\n\n    vector<int> minimumDistance(totalCities + 1, infinity);\n    while (!priorityQueue.empty())\n    {\n        int currentCity = priorityQueue.top().second;\n        int currentDistance = priorityQueue.top().first;\n        priorityQueue.pop();\n\n        if (currentCity == totalCities)\n        {\n            return currentDistance;\n        }\n\n        if (currentDistance < minimumDistance[currentCity])\n        {\n            minimumDistance[currentCity] = currentDistance;\n            for (int j = 0; j < adjacencyList[currentCity].size(); ++j)\n            {\n                const auto &neighbor = adjacencyList[currentCity][j];\n                int nextCity = neighbor.first;\n                int nextDistance = max(currentDistance, neighbor.second);\n                if (nextDistance < minimumDistance[nextCity])\n                {\n                    priorityQueue.push({nextDistance, nextCity});\n                }\n            }\n        }\n    }\n\n    return -1;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumScore(int total_cities, vector<vector<int>> &roads)\n{\n    vector<vector<pair<int, int>>> adjacency_list(total_cities + 1);\n    for(const auto &road : roads)\n    {\n        adjacency_list[road[0]].push_back({road[1], road[2]});\n        adjacency_list[road[1]].push_back({road[0], road[2]});\n    }\n\n    const int infinity= 1e9;\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> priority_queue;\n    priority_queue.push({0, 1});\n\n    vector<int> minimum_distance(total_cities + 1, infinity);\n    while(!priority_queue.empty())\n    {\n        int current_city= priority_queue.top().second;\n        int current_distance= priority_queue.top().first;\n        priority_queue.pop();\n\n        if(current_city == total_cities)\n        {\n            return current_distance;\n        }\n\n        if(current_distance < minimum_distance[current_city])\n        {\n            minimum_distance[current_city]= current_distance;\n            for(const auto &neighbor : adjacency_list[current_city])\n            {\n                int next_city= neighbor.first;\n                int next_distance= max(current_distance, neighbor.second);\n                if(next_distance < minimum_distance[next_city])\n                {\n                    priority_queue.push({next_distance, next_city});\n                }\n            }\n        }\n    }\n\n    return -1;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxGroups(int numberOfNodes, vector<vector<int>> &edges)\n{\n    vector<vector<int>> adjacencyList(numberOfNodes + 1);\n    vector<int> nodeColor(numberOfNodes + 1, 0);\n\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        adjacencyList[edges[i][0]].push_back(edges[i][1]);\n        adjacencyList[edges[i][1]].push_back(edges[i][0]);\n    }\n\n    int maximumGroupSize = 0;\n    for (int nodeIndex = 1; nodeIndex <= numberOfNodes; ++nodeIndex)\n    {\n        if (nodeColor[nodeIndex] == 0)\n        {\n            queue<int> nodeQueue;\n            nodeQueue.push(nodeIndex);\n            nodeColor[nodeIndex] = 1;\n            while (!nodeQueue.empty())\n            {\n                int currentNode = nodeQueue.front();\n                nodeQueue.pop();\n                maximumGroupSize = max(maximumGroupSize, nodeColor[currentNode]);\n                for (int j = 0; j < adjacencyList[currentNode].size(); ++j)\n                {\n                    int neighbor = adjacencyList[currentNode][j];\n                    if (nodeColor[neighbor] == 0)\n                    {\n                        nodeColor[neighbor] = nodeColor[currentNode] + 1;\n                        nodeQueue.push(neighbor);\n                    }\n                    else if (nodeColor[neighbor] == nodeColor[currentNode])\n                    {\n                        return -1;\n                    }\n                }\n            }\n        }\n    }\n    return maximumGroupSize;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxGroups(int number_of_nodes, vector<vector<int>> &edges)\n{\n    vector<vector<int>> adjacency_list(number_of_nodes + 1);\n    vector<int> node_color(number_of_nodes + 1, 0);\n\n    for(auto &edge : edges)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    int maximum_group_size = 0;\n    for(int node_index = 1; node_index <= number_of_nodes; ++node_index)\n    {\n        if(node_color[node_index] == 0)\n        {\n            queue<int> node_queue;\n            node_queue.push(node_index);\n            node_color[node_index] = 1;\n            while(!node_queue.empty())\n            {\n                int current_node = node_queue.front();\n                node_queue.pop();\n                maximum_group_size = max(maximum_group_size, node_color[current_node]);\n                for(int neighbor : adjacency_list[current_node])\n                {\n                    if(node_color[neighbor] == 0)\n                    {\n                        node_color[neighbor] = node_color[current_node] + 1;\n                        node_queue.push(neighbor);\n                    }\n                    else if(node_color[neighbor] == node_color[current_node])\n                    {\n                        return -1;\n                    }\n                }\n            }\n        }\n    }\n    return maximum_group_size;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countOfEvenSubarrays(vector<int> &numberArray)\n{\n    int arraySize = numberArray.size();\n    int evenCount = 0, oddCount = 0, totalCount = 0;\n\n    for (int i = 0; i < arraySize; ++i)\n    {\n        int currentNumber = numberArray[i];\n        if (currentNumber % 2 == 0)\n        {\n            evenCount++;\n            totalCount += evenCount;\n        }\n        else\n        {\n            swap(evenCount, oddCount);\n            oddCount++;\n            totalCount += oddCount;\n        }\n    }\n\n    return totalCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countOfEvenSubarrays(vector<int> &number_array)\n{\n    int array_size= number_array.size();\n    int even_count= 0, odd_count= 0, total_count= 0;\n\n    for(int current_number : number_array)\n    {\n        if(current_number % 2 == 0)\n        {\n            even_count++;\n            total_count+= even_count;\n        }\n        else\n        {\n            swap(even_count, odd_count);\n            odd_count++;\n            total_count+= odd_count;\n        }\n    }\n\n    return total_count;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxValue(vector<string> &stringList)\n{\n    int maxValue = 0;\n    for (int i = 0; i < stringList.size(); ++i)\n    {\n        const string &currentString = stringList[i];\n        int currentValue;\n        if (currentString.find_first_not_of(\"0123456789\") == string::npos)\n        {\n            currentValue = stoi(currentString);\n        }\n        else\n        {\n            currentValue = static_cast<int>(currentString.length());\n        }\n        maxValue = max(maxValue, currentValue);\n    }\n    return maxValue;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxValue(vector<string> &string_list)\n{\n    int max_value = 0;\n    for(const string &current_string : string_list)\n    {\n        int current_value;\n        if(current_string.find_first_not_of(\"0123456789\") == string::npos)\n        {\n            current_value = stoi(current_string);\n        }\n        else\n        {\n            current_value = static_cast<int>(current_string.length());\n        }\n        max_value = max(max_value, current_value);\n    }\n    return max_value;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxStarSum(const vector<int> &nodeValues, const vector<vector<int>> &edges, int k)\n{\n    vector<int> adjacencyList[100000];\n    int maximumSum = -1e9;\n\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        const vector<int> &edge = edges[i];\n        adjacencyList[edge[0]].push_back(nodeValues[edge[1]]);\n        adjacencyList[edge[1]].push_back(nodeValues[edge[0]]);\n    }\n\n    for (int nodeIndex = 0; nodeIndex < nodeValues.size(); nodeIndex++)\n    {\n        sort(adjacencyList[nodeIndex].rbegin(), adjacencyList[nodeIndex].rend());\n        int currentSum = nodeValues[nodeIndex];\n        for (int j = 0; j < k && j < adjacencyList[nodeIndex].size(); j++)\n        {\n            currentSum += adjacencyList[nodeIndex][j];\n        }\n        maximumSum = max(maximumSum, currentSum);\n    }\n\n    return maximumSum;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxStarSum(const vector<int> &node_values, const vector<vector<int>> &edges, int k)\n{\n    vector<int> adjacency_list[100000];\n    int maximum_sum= -1e9;\n\n    for(const vector<int> &edge : edges)\n    {\n        adjacency_list[edge[0]].push_back(node_values[edge[1]]);\n        adjacency_list[edge[1]].push_back(node_values[edge[0]]);\n    }\n\n    for(int node_index= 0; node_index < node_values.size(); node_index++)\n    {\n        sort(adjacency_list[node_index].rbegin(), adjacency_list[node_index].rend());\n        int current_sum= node_values[node_index];\n        for(int j= 0; j < k && j < adjacency_list[node_index].size(); j++)\n        {\n            current_sum+= adjacency_list[node_index][j];\n        }\n        maximum_sum= max(maximum_sum, current_sum);\n    }\n\n    return maximum_sum;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumPathCost(vector<int> &stoneCosts)\n{\n    int numberOfStones= stoneCosts.size();\n    int minimumCost= stoneCosts[numberOfStones - 1];\n    for(int index= 1; index < numberOfStones - 1; ++index)\n    {\n        minimumCost= min(minimumCost, max(stoneCosts[index], stoneCosts[numberOfStones - 1] - stoneCosts[index]));\n    }\n    return minimumCost;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumPathCost(vector<int> &stone_costs)\n{\n    int number_of_stones= stone_costs.size();\n    int minimum_cost= stone_costs[number_of_stones - 1];\n    for(int index= 1; index < number_of_stones - 1; ++index)\n    {\n        minimum_cost= min(minimum_cost, max(stone_costs[index], stone_costs[number_of_stones - 1] - stone_costs[index]));\n    }\n    return minimum_cost;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minCost(vector<int> &firstArray, vector<int> &secondArray)\n{\n    unordered_map<int, vector<int>> valueToIndices;\n    for(int index = 0; index < firstArray.size(); ++index)\n    {\n        valueToIndices[firstArray[index]].push_back(index);\n    }\n\n    int totalCost = 0;\n    for(int i = 0; i < secondArray.size(); ++i)\n    {\n        int value = secondArray[i];\n        if(valueToIndices[value].empty())\n            return -1;\n        totalCost += valueToIndices[value].back();\n        valueToIndices[value].pop_back();\n    }\n\n    return totalCost;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minCost(vector<int> &first_array, vector<int> &second_array)\n{\n    unordered_map<int, vector<int>> value_to_indices;\n    for(int index= 0; index < first_array.size(); ++index)\n    {\n        value_to_indices[first_array[index]].push_back(index);\n    }\n\n    int total_cost= 0;\n    for(int value : second_array)\n    {\n        if(value_to_indices[value].empty())\n            return -1;\n        total_cost+= value_to_indices[value].back();\n        value_to_indices[value].pop_back();\n    }\n\n    return total_cost;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxValueAfterOperations(vector<vector<int>> &grid)\n{\n    int totalMaxValue= 0;\n    while(!grid.empty())\n    {\n        int currentMaxValue= 0, maxRowIndex= -1;\n\n        for(int rowIndex= 0; rowIndex < grid.size(); ++rowIndex)\n        {\n            auto maxElementIterator= max_element(grid[rowIndex].begin(), grid[rowIndex].end());\n            if(*maxElementIterator > currentMaxValue)\n            {\n                currentMaxValue= *maxElementIterator;\n                maxRowIndex= rowIndex;\n            }\n            grid[rowIndex].erase(maxElementIterator);\n        }\n\n        totalMaxValue+= currentMaxValue;\n        if(grid[maxRowIndex].empty())\n        {\n            grid.erase(grid.begin() + maxRowIndex);\n        }\n    }\n\n    return totalMaxValue;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxValueAfterOperations(vector<vector<int>> &grid)\n{\n    int total_max_value= 0;\n    while(!grid.empty())\n    {\n        int current_max_value= 0, max_row_index= -1;\n\n        for(int row_index= 0; row_index < grid.size(); ++row_index)\n        {\n            auto max_element_iterator= max_element(grid[row_index].begin(), grid[row_index].end());\n            if(*max_element_iterator > current_max_value)\n            {\n                current_max_value= *max_element_iterator;\n                max_row_index= row_index;\n            }\n            grid[row_index].erase(max_element_iterator);\n        }\n\n        total_max_value+= current_max_value;\n        if(grid[max_row_index].empty())\n        {\n            grid.erase(grid.begin() + max_row_index);\n        }\n    }\n\n    return total_max_value;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint longestSquareStreak(vector<int> &numberList)\n{\n    unordered_set<int> numberSet(numberList.begin(), numberList.end());\n    int longestStreak = -1;\n\n    for (auto it = numberSet.begin(); it != numberSet.end(); ++it)\n    {\n        int currentNumber = *it;\n        int currentStreak = 1;\n\n        while (numberSet.count(static_cast<int>(pow(currentNumber, 0.5))) > 0)\n        {\n            ++currentStreak;\n            currentNumber = static_cast<int>(pow(currentNumber, 0.5));\n        }\n\n        longestStreak = max(longestStreak, currentStreak);\n    }\n\n    return longestStreak >= 2 ? longestStreak : -1;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint longestSquareStreak(vector<int> &number_list)\n{\n    unordered_set<int> number_set(number_list.begin(), number_list.end());\n    int longest_streak= -1;\n\n    for(int current_number : number_set)\n    {\n        int current_streak= 1;\n\n        while(number_set.count(static_cast<int>(pow(current_number, 0.5))) > 0)\n        {\n            ++current_streak;\n            current_number= static_cast<int>(pow(current_number, 0.5));\n        }\n\n        longest_streak= max(longest_streak, current_streak);\n    }\n\n    return longest_streak >= 2 ? longest_streak : -1;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nclass Allocator\n{\n    vector<int> memory;\n\n  public:\n    Allocator(int size) : memory(size, 0) {}\n\n    int allocate(int blockSize, int memoryId)\n    {\n        int startIndex= -1, freeCount= 0;\n        for(int i= 0; i <= memory.size(); ++i)\n        {\n            if(i < memory.size() && memory[i] == 0)\n            {\n                if(startIndex == -1)\n                    startIndex= i;\n                freeCount++;\n            }\n            else\n            {\n                if(freeCount >= blockSize)\n                {\n                    fill(memory.begin() + startIndex, memory.begin() + startIndex + blockSize, memoryId);\n                    return startIndex;\n                }\n                startIndex= -1;\n                freeCount= 0;\n            }\n        }\n        return -1;\n    }\n\n    int free(int memoryId)\n    {\n        int freedCount= 0;\n        for(int i= 0; i < memory.size(); ++i)\n        {\n            if(memory[i] == memoryId)\n            {\n                freedCount++;\n                memory[i]= 0;\n            }\n        }\n        return freedCount;\n    }\n};### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Allocator\n{\n    vector<int> memory;\n\npublic:\n    Allocator(int size) : memory(size, 0) {}\n\n    int allocate(int block_size, int memory_id)\n    {\n        int start_index= -1, free_count= 0;\n        for(int i= 0; i <= memory.size(); ++i)\n        {\n            if(i < memory.size() && memory[i] == 0)\n            {\n                if(start_index == -1)\n                    start_index= i;\n                free_count++;\n            }\n            else\n            {\n                if(free_count >= block_size)\n                {\n                    fill(memory.begin() + start_index, memory.begin() + start_index + block_size, memory_id);\n                    return start_index;\n                }\n                start_index= -1;\n                free_count= 0;\n            }\n        }\n        return -1;\n    }\n\n    int free(int memory_id)\n    {\n        int freed_count= 0;\n        for(int i= 0; i < memory.size(); ++i)\n        {\n            if(memory[i] == memory_id)\n            {\n                freed_count++;\n                memory[i]= 0;\n            }\n        }\n        return freed_count;\n    }\n};"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> traverseMatrix(vector<vector<int>> &grid, const vector<int> &queries, int rows, int columns)\n{\n    vector<int> directionX= {-1, 0, 1, 0};\n    vector<int> directionY= {0, 1, 0, -1};\n    vector<int> result(queries.size(), 0);\n\n    for(int queryIndex= 0; queryIndex < queries.size(); ++queryIndex)\n    {\n        int queryValue= queries[queryIndex];\n        int pointsCount= 0;\n        set<pair<int, int>> visitedCells;\n\n        function<void(int, int)> depthFirstSearch= [&](int currentX, int currentY)\n        {\n            if(visitedCells.find({currentX, currentY}) == visitedCells.end() && grid[currentX][currentY] < queryValue)\n            {\n                visitedCells.insert({currentX, currentY});\n                pointsCount++;\n                for(int directionIndex= 0; directionIndex < 4; ++directionIndex)\n                {\n                    int nextX= currentX + directionX[directionIndex], nextY= currentY + directionY[directionIndex];\n                    if(nextX >= 0 && nextX < rows && nextY >= 0 && nextY < columns)\n                    {\n                        depthFirstSearch(nextX, nextY);\n                    }\n                }\n            }\n        };\n\n        depthFirstSearch(0, 0);\n        result[queryIndex]= pointsCount;\n    }\n\n    return result;\n}\n\nvector<int> maxPoints(vector<vector<int>> &grid, vector<int> &queries)\n{\n    int rows= grid.size();\n    int columns= grid[0].size();\n    return traverseMatrix(grid, queries, rows, columns);\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> traverseMatrix(vector<vector<int>> &grid, const vector<int> &queries, int rows, int columns)\n{\n    vector<int> direction_x= {-1, 0, 1, 0};\n    vector<int> direction_y= {0, 1, 0, -1};\n    vector<int> result(queries.size(), 0);\n\n    for(int query_index= 0; query_index < queries.size(); ++query_index)\n    {\n        int query_value= queries[query_index];\n        int points_count= 0;\n        set<pair<int, int>> visited_cells;\n\n        function<void(int, int)> depth_first_search= [&](int current_x, int current_y)\n        {\n            if(visited_cells.find({current_x, current_y}) == visited_cells.end() && grid[current_x][current_y] < query_value)\n            {\n                visited_cells.insert({current_x, current_y});\n                points_count++;\n                for(int direction_index= 0; direction_index < 4; ++direction_index)\n                {\n                    int next_x= current_x + direction_x[direction_index], next_y= current_y + direction_y[direction_index];\n                    if(next_x >= 0 && next_x < rows && next_y >= 0 && next_y < columns)\n                    {\n                        depth_first_search(next_x, next_y);\n                    }\n                }\n            }\n        };\n\n        depth_first_search(0, 0);\n        result[query_index]= points_count;\n    }\n\n    return result;\n}\n\nvector<int> maxPoints(vector<vector<int>> &grid, vector<int> &queries)\n{\n    int rows= grid.size();\n    int columns= grid[0].size();\n    return traverseMatrix(grid, queries, rows, columns);\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint subsequenceOrSum(vector<int> &numbers)\n{\n    int orResult = 0;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int currentNumber = numbers[i];\n        orResult |= currentNumber;\n    }\n    return orResult;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint subsequenceOrSum(vector<int> &numbers)\n{\n    int or_result= 0;\n    for(int current_number : numbers)\n    {\n        or_result|= current_number;\n    }\n    return or_result;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countSimilarPairs(vector<string> &wordList)\n{\n    int similarPairCount = 0;\n    for(int firstIndex = 0; firstIndex < wordList.size(); ++firstIndex)\n    {\n        for(int secondIndex = firstIndex + 1; secondIndex < wordList.size(); ++secondIndex)\n        {\n            unordered_set<char> firstWordSet{wordList[firstIndex].begin(), wordList[firstIndex].end()};\n            unordered_set<char> secondWordSet{wordList[secondIndex].begin(), wordList[secondIndex].end()};\n            if(firstWordSet == secondWordSet)\n                similarPairCount++;\n        }\n    }\n    return similarPairCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countSimilarPairs(vector<string> &word_list)\n{\n    int similar_pair_count = 0;\n    for(int first_index = 0; first_index < word_list.size(); ++first_index)\n    {\n        for(int second_index = first_index + 1; second_index < word_list.size(); ++second_index)\n        {\n            unordered_set<char> first_word_set{word_list[first_index].begin(), word_list[first_index].end()};\n            unordered_set<char> second_word_set{word_list[second_index].begin(), word_list[second_index].end()};\n            if(first_word_set == second_word_set)\n                similar_pair_count++;\n        }\n    }\n    return similar_pair_count;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint smallestFactorization(int number)\n{\n    if(number <= 3)\n        return number;\n    int factorizationResult= 0, factorMultiplier= 1;\n    for(int currentFactor= 2; currentFactor <= 5; ++currentFactor)\n    {\n        while(number % currentFactor == 0)\n        {\n            factorizationResult+= factorMultiplier * currentFactor;\n            factorMultiplier*= 10;\n            number/= currentFactor;\n        }\n    }\n    return number == 1 ? factorizationResult : number;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int smallestFactorization(int number)\n{\n    if(number <= 3)\n        return number;\n    int factorization_result= 0, factor_multiplier= 1;\n    for(int current_factor= 2; current_factor <= 5; ++current_factor)\n    {\n        while(number % current_factor == 0)\n        {\n            factorization_result+= factor_multiplier * current_factor;\n            factor_multiplier*= 10;\n            number/= current_factor;\n        }\n    }\n    return number == 1 ? factorization_result : number;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPossibleDegreeEven(int numberOfVertices, vector<vector<int>> &edges)\n{\n    vector<int> vertexDegrees(numberOfVertices + 1, 0);\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        vertexDegrees[edges[i][0]]++;\n        vertexDegrees[edges[i][1]]++;\n    }\n\n    int oddDegreeCount = 0;\n    for (int index = 1; index <= numberOfVertices; index++)\n    {\n        if (vertexDegrees[index] % 2 != 0)\n            oddDegreeCount++;\n    }\n\n    return (oddDegreeCount == 0 || oddDegreeCount == 2);\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPossibleDegreeEven(int number_of_vertices, vector<vector<int>> &edges)\n{\n    vector<int> vertex_degrees(number_of_vertices + 1, 0);\n    for(const auto &edge : edges)\n    {\n        vertex_degrees[edge[0]]++;\n        vertex_degrees[edge[1]]++;\n    }\n\n    int odd_degree_count= 0;\n    for(int index= 1; index <= number_of_vertices; index++)\n    {\n        if(vertex_degrees[index] % 2 != 0)\n            odd_degree_count++;\n    }\n\n    return (odd_degree_count == 0 || odd_degree_count == 2);\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> lengthOfCycle(int numberOfNodes, const vector<vector<int>> &queries)\n{\n    vector<int> cycleLengths;\n    for (int i = 0; i < queries.size(); ++i)\n    {\n        const auto &query = queries[i];\n        int depthA = 0, depthB = 0, nodeA = query[0], nodeB = query[1];\n        while (nodeA != nodeB)\n        {\n            if (nodeA < nodeB)\n                swap(nodeA, nodeB);\n            nodeA >>= 1;\n            depthA++;\n        }\n        cycleLengths.push_back(depthA + depthB);\n    }\n    return cycleLengths;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> lengthOfCycle(int number_of_nodes, const vector<vector<int>> &queries)\n{\n    vector<int> cycle_lengths;\n    for(const auto &query : queries)\n    {\n        int depth_a= 0, depth_b= 0, node_a= query[0], node_b= query[1];\n        while(node_a != node_b)\n        {\n            if(node_a < node_b)\n                swap(node_a, node_b);\n            node_a>>= 1;\n            depth_a++;\n        }\n        cycle_lengths.push_back(depth_a + depth_b);\n    }\n    return cycle_lengths;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isValidPath(vector<vector<int>> &grid, int currentRow, int currentCol, int zeroCount, int oneCount)\n{\n    if(currentRow < 0 || currentCol < 0 || currentRow >= grid.size() || currentCol >= grid[0].size())\n    {\n        return false;\n    }\n    if(grid[currentRow][currentCol] == 1)\n    {\n        oneCount++;\n    }\n    else\n    {\n        zeroCount++;\n    }\n    if(currentRow == grid.size() - 1 && currentCol == grid[0].size() - 1)\n    {\n        return zeroCount == oneCount;\n    }\n    return isValidPath(grid, currentRow + 1, currentCol, zeroCount, oneCount) || isValidPath(grid, currentRow, currentCol + 1, zeroCount, oneCount);\n}\n\nbool equalPath(vector<vector<int>> &grid)\n{\n    return isValidPath(grid, 0, 0, 0, 0);\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isValidPath(vector<vector<int>> &grid, int current_row, int current_col, int zero_count, int one_count)\n{\n    if(current_row < 0 || current_col < 0 || current_row >= grid.size() || current_col >= grid[0].size())\n    {\n        return false;\n    }\n    if(grid[current_row][current_col] == 1)\n    {\n        one_count++;\n    }\n    else\n    {\n        zero_count++;\n    }\n    if(current_row == grid.size() - 1 && current_col == grid[0].size() - 1)\n    {\n        return zero_count == one_count;\n    }\n    return isValidPath(grid, current_row + 1, current_col, zero_count, one_count) || isValidPath(grid, current_row, current_col + 1, zero_count, one_count);\n}\n\nbool equalPath(vector<vector<int>> &grid)\n{\n    return isValidPath(grid, 0, 0, 0, 0);\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxCapturedForts(vector<int> &forts)\n{\n    int totalForts= forts.size();\n    int maxCapture= 0;\n    for(int currentFort= 0; currentFort < totalForts; currentFort++)\n    {\n        if(forts[currentFort] == 1)\n        {\n            for(int nextFort= currentFort + 1; nextFort < totalForts; nextFort++)\n            {\n                if(forts[nextFort] != -1)\n                {\n                    int captureCount= 0;\n                    for(int intermediateFort= currentFort + 1; intermediateFort < nextFort; intermediateFort++)\n                    {\n                        if(forts[intermediateFort] == 0)\n                            captureCount++;\n                    }\n                    if(forts[nextFort] == 1)\n                        maxCapture= max(maxCapture, captureCount);\n                }\n            }\n        }\n    }\n    return maxCapture;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxCapturedForts(vector<int> &forts)\n{\n    int total_forts= forts.size();\n    int max_capture= 0;\n    for(int current_fort= 0; current_fort < total_forts; current_fort++)\n    {\n        if(forts[current_fort] == 1)\n        {\n            for(int next_fort= current_fort + 1; next_fort < total_forts; next_fort++)\n            {\n                if(forts[next_fort] != -1)\n                {\n                    int capture_count= 0;\n                    for(int intermediate_fort= current_fort + 1; intermediate_fort < next_fort; intermediate_fort++)\n                    {\n                        if(forts[intermediate_fort] == 0)\n                            capture_count++;\n                    }\n                    if(forts[next_fort] == 1)\n                        max_capture= max(max_capture, capture_count);\n                }\n            }\n        }\n    }\n    return max_capture;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> topKStudents(const vector<string> &positiveFeedback,\n                          const vector<string> &negativeFeedback,\n                          const vector<string> &reports,\n                          const vector<int> &studentIds,\n                          int k)\n{\n    unordered_map<int, int> studentPoints;\n    for(size_t i = 0; i < reports.size(); ++i)\n    {\n        int positiveCount = 0, negativeCount = 0;\n        for(size_t j = 0; j < positiveFeedback.size(); ++j)\n        {\n            const auto &positive = positiveFeedback[j];\n            size_t positiveIndex = reports[i].find(positive);\n            while(positiveIndex != string::npos)\n            {\n                ++positiveCount;\n                positiveIndex = reports[i].find(positive, positiveIndex + positive.length());\n            }\n        }\n        for(size_t j = 0; j < negativeFeedback.size(); ++j)\n        {\n            const auto &negative = negativeFeedback[j];\n            size_t negativeIndex = reports[i].find(negative);\n            while(negativeIndex != string::npos)\n            {\n                ++negativeCount;\n                negativeIndex = reports[i].find(negative, negativeIndex + negative.length());\n            }\n        }\n        studentPoints[studentIds[i]] += 3 * positiveCount - negativeCount;\n    }\n\n    vector<int> students(studentIds.begin(), studentIds.end());\n    sort(students.begin(), students.end(), [&studentPoints](int a, int b)\n         { return studentPoints[a] != studentPoints[b] ? studentPoints[a] > studentPoints[b] : a < b; });\n\n    return vector<int>(students.begin(), students.begin() + k);\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> topKStudents(const vector<string> &positive_feedback,\n                         const vector<string> &negative_feedback,\n                         const vector<string> &reports,\n                         const vector<int> &student_ids,\n                         int k)\n{\n    unordered_map<int, int> student_points;\n    for(size_t i= 0; i < reports.size(); ++i)\n    {\n        int positive_count= 0, negative_count= 0;\n        for(const auto &positive : positive_feedback)\n        {\n            size_t positive_index= reports[i].find(positive);\n            while(positive_index != string::npos)\n            {\n                ++positive_count;\n                positive_index= reports[i].find(positive, positive_index + positive.length());\n            }\n        }\n        for(const auto &negative : negative_feedback)\n        {\n            size_t negative_index= reports[i].find(negative);\n            while(negative_index != string::npos)\n            {\n                ++negative_count;\n                negative_index= reports[i].find(negative, negative_index + negative.length());\n            }\n        }\n        student_points[student_ids[i]]+= 3 * positive_count - negative_count;\n    }\n\n    vector<int> students(student_ids.begin(), student_ids.end());\n    sort(students.begin(), students.end(), [&student_points](int a, int b)\n         { return student_points[a] != student_points[b] ? student_points[a] > student_points[b] : a < b; });\n\n    return vector<int>(students.begin(), students.begin() + k);\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint calculateMinimumPossibleMax(int divisor1, int divisor2, int uniqueCount1, int uniqueCount2)\n{\n    return (divisor1 - 1) * uniqueCount1 + (divisor2 - 1) * uniqueCount2 + 1;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int calculateMinimumPossibleMax(int divisor_1, int divisor_2, int unique_count_1, int unique_count_2)\n{\n    return (divisor_1 - 1) * unique_count_1 + (divisor_2 - 1) * unique_count_2 + 1;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\n// For std::min\nusing namespace std;\n\nint shortestDistance(vector<string> &words, string target, int startIndex)\n{\n    int totalWords = words.size();\n    int leftDistance = 0, rightDistance = 0, currentIndex = startIndex;\n    while(true)\n    {\n        if(words[currentIndex] == target)\n        {\n            return min(leftDistance, rightDistance);\n        }\n        leftDistance++;\n        rightDistance++;\n        currentIndex = (currentIndex + 1) % totalWords;\n        if(leftDistance == totalWords)\n        {\n            break;\n        }\n    }\n    return -1;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\n// for std::min\nusing namespace std;\n\nint shortestDistance(vector<string> &words, string target, int start_index)\n{\n    int total_words = words.size();\n    int left_distance = 0, right_distance = 0, current_index = start_index;\n    while (true)\n    {\n        if (words[current_index] == target)\n        {\n            return min(left_distance, right_distance);\n        }\n        left_distance++;\n        right_distance++;\n        current_index = (current_index + 1) % total_words;\n        if (left_distance == total_words)\n        {\n            break;\n        }\n    }\n    return -1;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minMinutes(string inputString, int requiredCount)\n{\n    int stringLength = inputString.length();\n    vector<int> leftCharacterCounts(3, 0), rightCharacterCounts(3, 0);\n    for (int i = 0; i < stringLength; ++i)\n        rightCharacterCounts[inputString[i] - 'a']++;\n\n    int minimumMinutes = stringLength, totalCount = 0;\n    while (true)\n    {\n        int leftIndex = 0, rightIndex = stringLength - 1;\n        while (leftIndex < rightIndex && leftCharacterCounts[inputString[leftIndex] - 'a'] < requiredCount && rightCharacterCounts[inputString[rightIndex] - 'a'] < requiredCount)\n        {\n            int neededLeft = max(0, requiredCount - leftCharacterCounts[inputString[leftIndex] - 'a']);\n            int neededRight = max(0, requiredCount - rightCharacterCounts[inputString[rightIndex] - 'a']);\n            if (neededLeft <= neededRight)\n            {\n                totalCount += neededLeft;\n                leftCharacterCounts[inputString[leftIndex] - 'a'] += neededLeft; // Fixed increment\n                rightCharacterCounts[inputString[leftIndex] - 'a'] -= neededLeft; // Fixed decrement\n                leftIndex++;\n            }\n            else\n            {\n                totalCount += neededRight;\n                rightCharacterCounts[inputString[rightIndex] - 'a'] -= neededRight; // Fixed decrement\n                leftCharacterCounts[inputString[rightIndex] - 'a'] += neededRight; // Fixed increment\n                rightIndex--;\n            }\n        }\n        minimumMinutes = min(minimumMinutes, totalCount);\n        if (leftIndex + 1 < inputString.length())\n        {\n            totalCount -= leftCharacterCounts[inputString[leftIndex] - 'a'];\n            leftCharacterCounts[inputString[leftIndex] - 'a']--;\n            rightCharacterCounts[inputString[leftIndex + 1] - 'a']++;\n            leftIndex++;\n        }\n        else\n            break;\n    }\n    if (leftCharacterCounts[0] >= requiredCount && leftCharacterCounts[1] >= requiredCount && leftCharacterCounts[2] >= requiredCount)\n        return minimumMinutes;\n    return -1;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minMinutes(string input_string, int required_count)\n{\n    int string_length= input_string.length();\n    vector<int> left_character_counts(3, 0), right_character_counts(3, 0);\n    for(char character : input_string)\n        right_character_counts[character - 'a']++;\n\n    int minimum_minutes= string_length, total_count= 0;\n    while(true)\n    {\n        int left_index= 0, right_index= string_length - 1;\n        while(left_index < right_index && left_character_counts[input_string[left_index] - 'a'] < required_count && right_character_counts[input_string[right_index] - 'a'] < required_count)\n        {\n            int needed_left= max(0, required_count - left_character_counts[input_string[left_index] - 'a']);\n            int needed_right= max(0, required_count - right_character_counts[input_string[right_index] - 'a']);\n            if(needed_left <= needed_right)\n            {\n                total_count+= needed_left;\n                left_index++;\n                left_character_counts[input_string[left_index] - 'a']++;\n                right_character_counts[input_string[left_index] - 'a']--;\n            }\n            else\n            {\n                total_count+= needed_right;\n                right_index--;\n                right_character_counts[input_string[right_index] - 'a']--;\n                left_character_counts[input_string[right_index] - 'a']++;\n            }\n        }\n        minimum_minutes= min(minimum_minutes, total_count);\n        if(left_index + 1 < input_string.length())\n        {\n            total_count-= left_character_counts[input_string[left_index] - 'a'];\n            left_character_counts[input_string[left_index] - 'a']--;\n            right_character_counts[input_string[left_index + 1] - 'a']++;\n            left_index++;\n        }\n        else\n            break;\n    }\n    if(left_character_counts[0] >= required_count && left_character_counts[1] >= required_count && left_character_counts[2] >= required_count)\n        return minimum_minutes;\n    return -1;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMaxTastiness(vector<int> &prices, int numberOfItems)\n{\n    sort(prices.begin(), prices.end());\n    int maxTastiness= 0;\n    for(int i= 0; i < prices.size() - numberOfItems + 1; i++)\n    {\n        int minDifference= INT_MAX;\n        for(int j= i; j < i + numberOfItems - 1; j++)\n        {\n            minDifference= min(minDifference, prices[j + 1] - prices[j]);\n        }\n        maxTastiness= max(maxTastiness, minDifference);\n    }\n\n    return maxTastiness;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMaxTastiness(vector<int> &prices, int number_of_items)\n{\n    sort(prices.begin(), prices.end());\n    int max_tastiness= 0;\n    for(int i= 0; i < prices.size() - number_of_items + 1; i++)\n    {\n        int min_difference= INT_MAX;\n        for(int j= i; j < i + number_of_items - 1; j++)\n        {\n            min_difference= min(min_difference, prices[j + 1] - prices[j]);\n        }\n        max_tastiness= max(max_tastiness, min_difference);\n    }\n\n    return max_tastiness;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPartitions(vector<int> &numbers, int target)\n{\n    long long totalSum = 0;\n    int size = numbers.size();\n    int modulus = 1000000007;\n\n    for (int i = 0; i < size; ++i)\n    {\n        totalSum += numbers[i];\n    }\n\n    if (totalSum < target * 2)\n    {\n        return 0;\n    }\n\n    vector<long long> dynamicProgramming(size + 1, 1);\n\n    for (int i = 1; i <= target - 1; i++)\n    {\n        for (int j = size - 1; j >= 1; j--)\n        {\n            dynamicProgramming[j] = (dynamicProgramming[j] * j + dynamicProgramming[j - 1]) % modulus;\n        }\n    }\n\n    long long result = 0;\n\n    for (int i = 0; i < size - 1; i++)\n    {\n        totalSum -= numbers[i];\n        if (totalSum >= target)\n        {\n            result = (result + dynamicProgramming[i + 1]) % modulus;\n        }\n    }\n\n    return (int)result;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countPartitions(vector<int> &numbers, int target)\n{\n    long long total_sum= 0;\n    int size= numbers.size();\n    int modulus= 1000000007;\n\n    for(int number : numbers)\n    {\n        total_sum+= number;\n    }\n\n    if(total_sum < target * 2)\n    {\n        return 0;\n    }\n\n    vector<long long> dynamic_programming(size + 1, 1);\n\n    for(int i= 1; i <= target - 1; i++)\n    {\n        for(int j= size - 1; j >= 1; j--)\n        {\n            dynamic_programming[j]= (dynamic_programming[j] * j + dynamic_programming[j - 1]) % modulus;\n        }\n    }\n\n    long long result= 0;\n\n    for(int i= 0; i < size - 1; i++)\n    {\n        total_sum-= numbers[i];\n        if(total_sum >= target)\n        {\n            result= (result + dynamic_programming[i + 1]) % modulus;\n        }\n    }\n\n    return (int)result;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countKBigIndices(vector<int> &numbers, int threshold)\n{\n    int size= numbers.size();\n    vector<int> leftIndices(size, 0), rightIndices(size, 0);\n\n    for(int index= 1; index < size; ++index)\n    {\n        if(numbers[index] > numbers[index - 1])\n            leftIndices[index]= leftIndices[index - 1] + 1;\n\n        int reverseIndex= size - index - 1;\n        if(reverseIndex + 1 < size && numbers[reverseIndex] < numbers[reverseIndex + 1]) // Ensure we don't go out of bounds\n            rightIndices[reverseIndex]= rightIndices[reverseIndex + 1] + 1;\n    }\n\n    int totalCount= 0;\n    for(int index= 0; index < size; ++index)\n        if(leftIndices[index] >= threshold && rightIndices[index] >= threshold)\n            totalCount++;\n\n    return totalCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countKBigIndices(vector<int> &numbers, int threshold)\n{\n    int size= numbers.size();\n    vector<int> left_indices(size, 0), right_indices(size, 0);\n\n    for(int index= 1; index < size; ++index)\n    {\n        if(numbers[index] > numbers[index - 1])\n            left_indices[index]= left_indices[index - 1] + 1;\n\n        int reverse_index= size - index - 1;\n        if(reverse_index + 1 < size && numbers[reverse_index] < numbers[reverse_index + 1])\n            right_indices[reverse_index]= right_indices[reverse_index + 1] + 1;\n    }\n\n    int total_count= 0;\n    for(int index= 0; index < size; ++index)\n        if(left_indices[index] >= threshold && right_indices[index] >= threshold)\n            total_count++;\n\n    return total_count;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint countDigitsDividingNumber(int inputNumber)\n{\n    int divisorCount= 0, tempNumber= inputNumber;\n    while(tempNumber > 0)\n    {\n        int currentDigit= tempNumber % 10;\n        if(inputNumber % currentDigit == 0)\n        {\n            divisorCount++;\n        }\n        tempNumber/= 10;\n    }\n    return divisorCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int countDigitsDividingNumber(int input_number)\n{\n    int divisor_count= 0, temp_number= input_number;\n    while(temp_number > 0)\n    {\n        int current_digit= temp_number % 10;\n        if(input_number % current_digit == 0)\n        {\n            divisor_count++;\n        }\n        temp_number/= 10;\n    }\n    return divisor_count;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countDistinctPrimeFactors(const vector<int> &numbers)\n{\n    set<int> distinctPrimeFactors;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int number = numbers[i];\n        for (int divisor = 2; divisor * divisor <= number; ++divisor)\n        {\n            if (number % divisor == 0)\n            {\n                distinctPrimeFactors.insert(divisor);\n                distinctPrimeFactors.insert(number / divisor);\n            }\n        }\n    }\n    return distinctPrimeFactors.size();\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countDistinctPrimeFactors(const vector<int> &numbers)\n{\n    set<int> distinct_prime_factors;\n    for(const int number : numbers)\n    {\n        for(int divisor= 2; divisor * divisor <= number; ++divisor)\n        {\n            if(number % divisor == 0)\n            {\n                distinct_prime_factors.insert(divisor);\n                distinct_prime_factors.insert(number / divisor);\n            }\n        }\n    }\n    return distinct_prime_factors.size();\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minPartitions(string numberString, int maxValue)\n{\n    int stringLength= numberString.size();\n    int partitionCount= 0, currentIndex= 0;\n\n    while(currentIndex < stringLength)\n    {\n        int currentValue= 0;\n        // Make sure the currentValue is below maxValue\n        while(currentIndex < stringLength && currentValue * 10 + (numberString[currentIndex] - '0') <= maxValue)\n        {\n            currentValue= currentValue * 10 + (numberString[currentIndex] - '0');\n            currentIndex++;\n        }\n\n        if(currentValue == 0)\n            return -1;\n        partitionCount++;\n    }\n\n    return partitionCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minPartitions(string number_string, int max_value)\n{\n    int string_length = number_string.size();\n    int partition_count = 0, current_index = 0;\n\n    while(current_index < string_length)\n    {\n        int current_value = 0;\n        // Make sure the current_value is below max_value\n        while(current_index < string_length && current_value * 10 + (number_string[current_index] - '0') <= max_value)\n        {\n            current_value = current_value * 10 + (number_string[current_index] - '0');\n            current_index++;\n        }\n\n        if(current_value == 0)\n            return -1;\n        partition_count++;\n    }\n\n    return partition_count;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPrime(int number)\n{\n    if(number <= 1)\n        return false;\n    for(int divisor= 2; divisor * divisor <= number; ++divisor)\n    {\n        if(number % divisor == 0)\n            return false;\n    }\n    return true;\n}\n\nvector<int> closestPrimePair(int rangeStart, int rangeEnd)\n{\n    int minimumDistance= rangeEnd - rangeStart + 1;\n    vector<int> result= {-1, -1};\n    for(int currentNumber= rangeStart; currentNumber <= rangeEnd; ++currentNumber)\n    {\n        if(isPrime(currentNumber))\n        {\n            for(int nextNumber= currentNumber + 1; nextNumber <= rangeEnd; ++nextNumber)\n            {\n                if(isPrime(nextNumber) && nextNumber - currentNumber < minimumDistance)\n                {\n                    minimumDistance= nextNumber - currentNumber;\n                    result= {currentNumber, nextNumber};\n                }\n            }\n        }\n    }\n    return result;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPrime(int number)\n{\n    if(number <= 1)\n        return false;\n    for(int divisor= 2; divisor * divisor <= number; ++divisor)\n    {\n        if(number % divisor == 0)\n            return false;\n    }\n    return true;\n}\n\nvector<int> closestPrimePair(int range_start, int range_end)\n{\n    int minimum_distance= range_end - range_start + 1;\n    vector<int> result= {-1, -1};\n    for(int current_number= range_start; current_number <= range_end; ++current_number)\n    {\n        if(isPrime(current_number))\n        {\n            for(int next_number= current_number + 1; next_number <= range_end; ++next_number)\n            {\n                if(isPrime(next_number) && next_number - current_number < minimum_distance)\n                {\n                    minimum_distance= next_number - current_number;\n                    result= {current_number, next_number};\n                }\n            }\n        }\n    }\n    return result;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxFrequencyScore(vector<int> &numbers, int k)\n{\n    int size= numbers.size();\n    int rightIndex= 0, currentCount= 0, maxScore= 0;\n    long long currentScore= 0;\n    unordered_map<int, int> frequencyMap;\n\n    for(int leftIndex= 0; leftIndex < size; ++leftIndex)\n    {\n        while(rightIndex < size && currentCount < k)\n        {\n            currentScore= (currentScore + (long long)numbers[rightIndex] * frequencyMap[numbers[rightIndex]]) % 1000000007;\n            frequencyMap[numbers[rightIndex]]++;\n            currentCount++;\n            rightIndex++;\n        }\n\n        maxScore= max(maxScore, (int)currentScore);\n\n        if(currentCount == k)\n        {\n            currentScore-= numbers[leftIndex] * (frequencyMap[numbers[leftIndex]] - 1);\n            frequencyMap[numbers[leftIndex]]--;\n            currentCount--;\n        }\n    }\n\n    return maxScore;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxFrequencyScore(vector<int> &numbers, int k)\n{\n    int size= numbers.size();\n    int right_index= 0, current_count= 0, max_score= 0;\n    long long current_score= 0;\n    unordered_map<int, int> frequency_map;\n\n    for(int left_index= 0; left_index < size; ++left_index)\n    {\n        while(right_index < size && current_count < k)\n        {\n            current_score= (current_score + (long long)numbers[right_index] * frequency_map[numbers[right_index]]) % 1000000007;\n            frequency_map[numbers[right_index]]++;\n            current_count++;\n            right_index++;\n        }\n\n        max_score= max(max_score, (int)current_score);\n\n        if(current_count == k)\n        {\n            current_score-= numbers[left_index] * (frequency_map[numbers[left_index]] - 1);\n            frequency_map[numbers[left_index]]--;\n            current_count--;\n        }\n    }\n\n    return max_score;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring getBoxCategory(int boxLength, int boxWidth, int boxHeight, int boxMass)\n{\n    bool isBulky= boxLength >= 10000 || boxWidth >= 10000 || boxHeight >= 10000 || (long)boxLength * boxWidth * boxHeight >= 1000000000;\n    bool isHeavy= boxMass >= 100;\n\n    if(isBulky && isHeavy)\n        return \"Both \";\n    if(isBulky)\n        return \"Bulky \";\n    if(isHeavy)\n        return \"Heavy \";\n    return \"Neither \";\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring getBoxCategory(int box_length, int box_width, int box_height, int box_mass)\n{\n    bool is_bulky= box_length >= 10000 || box_width >= 10000 || box_height >= 10000 || (long)box_length * box_width * box_height >= 1000000000;\n    bool is_heavy= box_mass >= 100;\n\n    if(is_bulky && is_heavy)\n        return \"Both \";\n    if(is_bulky)\n        return \"Bulky \";\n    if(is_heavy)\n        return \"Heavy \";\n    return \"Neither \";\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nclass DataStream\n{\n  public:\n    DataStream(int targetValue, int sequenceLength) : targetValue(targetValue), sequenceLength(sequenceLength) {}\n\n    bool consec(int num)\n    {\n        dataStream.push_back(num);\n        if(dataStream.size() > sequenceLength)\n            dataStream.pop_front();\n\n        return dataStream.size() == sequenceLength && count(dataStream.begin(), dataStream.end(), targetValue) == sequenceLength;\n    }\n\n  private:\n    int targetValue;\n    int sequenceLength;\n    deque<int> dataStream;\n};### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\n// Include this for std::count\nusing namespace std;\n\nclass DataStream\n{\n  public:\n    DataStream(int target_value, int sequence_length) : targetValue(target_value), sequenceLength(sequence_length) {}\n\n    bool consec(int num)\n    {\n        dataStream.push_back(num);\n        if(dataStream.size() > sequenceLength)\n            dataStream.pop_front();\n\n        return dataStream.size() == sequenceLength && count(dataStream.begin(), dataStream.end(), targetValue) == sequenceLength;\n    }\n\n  private:\n    int targetValue;\n    int sequenceLength;\n    deque<int> dataStream;\n};"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateXorBeauty(vector<int> &inputNumbers)\n{\n    int numberOfElements = inputNumbers.size();\n    int maximumXorValue = 1024; // Maximum value for bitwise operations\n    vector<int> frequencyCounter(maximumXorValue, 0);\n\n    for (int i = 0; i < numberOfElements; ++i)\n    {\n        frequencyCounter[inputNumbers[i] % maximumXorValue]++;\n    }\n\n    int xorBeautyResult = 0;\n    for (int i = 0; i < maximumXorValue; i++)\n    {\n        for (int j = i; j < maximumXorValue; j++)\n        {\n            int commonBits = (i | j) & (~(i ^ j));\n            if (commonBits < maximumXorValue && commonBits >= j)\n            {\n                int countCombinations = frequencyCounter[i] * frequencyCounter[j] * (i == j ? 1 : 2);\n                if (commonBits != i && commonBits != j)\n                {\n                    countCombinations *= frequencyCounter[commonBits];\n                }\n                xorBeautyResult ^= countCombinations;\n            }\n        }\n    }\n\n    return xorBeautyResult;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateXorBeauty(vector<int> &input_numbers)\n{\n    int number_of_elements= input_numbers.size();\n    int maximum_xor_value= 1024; // Maximum value for bitwise operations\n    vector<int> frequency_counter(maximum_xor_value, 0);\n\n    for(int current_number : input_numbers)\n    {\n        frequency_counter[current_number % maximum_xor_value]++;\n    }\n\n    int xor_beauty_result= 0;\n    for(int i= 0; i < maximum_xor_value; i++)\n    {\n        for(int j= i; j < maximum_xor_value; j++)\n        {\n            int common_bits= (i | j) & (~(i ^ j));\n            if(common_bits < maximum_xor_value && common_bits >= j)\n            {\n                int count_combinations= frequency_counter[i] * frequency_counter[j] * (i == j ? 1 : 2);\n                if(common_bits != i && common_bits != j)\n                {\n                    count_combinations*= frequency_counter[common_bits];\n                }\n                xor_beauty_result^= count_combinations;\n            }\n        }\n    }\n\n    return xor_beauty_result;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMaxMinPower(vector<int> &stationPowers, int range, int additionalPower)\n{\n    int numberOfStations = stationPowers.size();\n    vector<int> totalPower(numberOfStations);\n    for(int currentStation = 0; currentStation < numberOfStations; currentStation++)\n    {\n        for(int nearbyStation = max(0, currentStation - range); nearbyStation <= min(numberOfStations - 1, currentStation + range); nearbyStation++)\n        {\n            totalPower[nearbyStation] += stationPowers[currentStation];\n        }\n    }\n\n    int sumOfK = 0, minimumPower = INT_MAX;\n    for(int currentIndex = range; currentIndex < numberOfStations - range; currentIndex++)\n    {\n        sumOfK += stationPowers[currentIndex];\n        minimumPower = min(minimumPower, totalPower[currentIndex]);\n    }\n\n    for(int j = 0, i = numberOfStations - 2 * range; j < 2 * range; j++, i--)\n    {\n        sumOfK -= stationPowers[i + range + 1];\n        minimumPower -= stationPowers[j];\n        minimumPower += sumOfK;\n        minimumPower += additionalPower;\n        minimumPower = min(minimumPower, totalPower[j]);\n    }\n\n    return minimumPower;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMaxMinPower(vector<int> &station_powers, int range, int additional_power)\n{\n    int number_of_stations= station_powers.size();\n    vector<int> total_power(number_of_stations);\n    for(int current_station= 0; current_station < number_of_stations; current_station++)\n    {\n        for(int nearby_station= max(0, current_station - range); nearby_station <= min(number_of_stations - 1, current_station + range); nearby_station++)\n        {\n            total_power[nearby_station]+= station_powers[current_station];\n        }\n    }\n\n    int sum_of_k= 0, minimum_power= INT_MAX;\n    for(int current_index= range; current_index < number_of_stations - range; current_index++)\n    {\n        sum_of_k+= station_powers[current_index];\n        minimum_power= min(minimum_power, total_power[current_index]);\n    }\n\n    for(int j= 0, i= number_of_stations - 2 * range; j < 2 * range; j++, i--)\n    {\n        sum_of_k-= station_powers[i + range + 1];\n        minimum_power-= station_powers[j];\n        minimum_power+= sum_of_k;\n        minimum_power+= additional_power;\n        minimum_power= min(minimum_power, total_power[j]);\n    }\n\n    return minimum_power;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxPositiveNegativeCount(const vector<int> &numbers)\n{\n    int positiveCount= upper_bound(numbers.begin(), numbers.end(), -1) - numbers.begin();\n    int negativeCount= numbers.size() - positiveCount;\n    return max(positiveCount, negativeCount);\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxPositiveNegativeCount(const vector<int> &numbers)\n{\n    int positive_count= upper_bound(numbers.begin(), numbers.end(), -1) - numbers.begin();\n    int negative_count= numbers.size() - positive_count;\n    return max(positive_count, negative_count);\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxScore(const vector<int> &numbers, int numberOfPicks)\n{\n    priority_queue<int> maxHeap(numbers.begin(), numbers.end());\n    int totalScore= 0;\n\n    for(int i= 0; i < numberOfPicks; i++)\n    {\n        int currentNumber= maxHeap.top();\n        maxHeap.pop();\n        totalScore+= currentNumber;\n        maxHeap.push(currentNumber / 3);\n    }\n\n    return totalScore;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxScore(const vector<int> &numbers, int number_of_picks)\n{\n    priority_queue<int> maxHeap(numbers.begin(), numbers.end());\n    int total_score= 0;\n\n    for(int i= 0; i < number_of_picks; i++)\n    {\n        int current_number= maxHeap.top();\n        maxHeap.pop();\n        total_score+= current_number;\n        maxHeap.push(current_number / 3);\n    }\n\n    return total_score;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool compare(const string &firstWord, const string &secondWord)\n{\n    array<int, 26> letterCountsFirst = {0}, letterCountsSecond = {0};\n    for (int i = 0; i < firstWord.size(); ++i)\n        letterCountsFirst[firstWord[i] - 'a']++;\n    for (int i = 0; i < secondWord.size(); ++i)\n        letterCountsSecond[secondWord[i] - 'a']++;\n    for (int index = 0; index < 26; ++index)\n    {\n        if (letterCountsFirst[index] && letterCountsSecond[index])\n            return true;\n    }\n    return false;\n}\n\nbool swapEqualDistinct(const string &firstWord, const string &secondWord)\n{\n    bool hasCommonLetter = compare(firstWord, secondWord);\n    return hasCommonLetter && firstWord.size() == secondWord.size();\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool compare(const string &first_word, const string &second_word)\n{\n    array<int, 26> letter_counts_first= {0}, letter_counts_second= {0};\n    for(char character : first_word)\n        letter_counts_first[character - 'a']++;\n    for(char character : second_word)\n        letter_counts_second[character - 'a']++;\n    for(int index= 0; index < 26; ++index)\n    {\n        if(letter_counts_first[index] && letter_counts_second[index])\n            return true;\n    }\n    return false;\n}\n\nbool swapEqualDistinct(const string &first_word, const string &second_word)\n{\n    bool has_common_letter= compare(first_word, second_word);\n    return has_common_letter && first_word.size() == second_word.size();\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getLastMoment(int totalMoments, int numElements, vector<vector<int>> &elementTimes)\n{\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> leftQueue, rightQueue;\n    for(int index= 0; index < numElements; index++)\n    {\n        leftQueue.push({elementTimes[index][0] + elementTimes[index][2], index});\n    }\n\n    while(totalMoments)\n    {\n        while(!rightQueue.empty() && rightQueue.top().first <= leftQueue.top().first)\n        {\n            auto rightTopElement= rightQueue.top();\n            rightQueue.pop();\n            leftQueue.push({rightTopElement.first + elementTimes[rightTopElement.second][0] + elementTimes[rightTopElement.second][2], rightTopElement.second});\n        }\n        auto leftTopElement= leftQueue.top();\n        leftQueue.pop();\n        elementTimes[leftTopElement.second][2]+= elementTimes[leftTopElement.second][3] + elementTimes[leftTopElement.second][0] + elementTimes[leftTopElement.second][1];\n        rightQueue.push({leftTopElement.first + elementTimes[leftTopElement.second][1], leftTopElement.second});\n        totalMoments--;\n    }\n\n    int lastMoment= -1;\n    while(!rightQueue.empty())\n    {\n        lastMoment= max(lastMoment, elementTimes[rightQueue.top().second][2]);\n        rightQueue.pop();\n    }\n    return lastMoment;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint getLastMoment(int total_moments, int num_elements, vector<vector<int>> &element_times)\n{\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> left_queue, right_queue;\n    for(int index= 0; index < num_elements; index++)\n    {\n        left_queue.push({element_times[index][0] + element_times[index][2], index});\n    }\n\n    while(total_moments)\n    {\n        while(!right_queue.empty() && right_queue.top().first <= left_queue.top().first)\n        {\n            auto right_top_element= right_queue.top();\n            right_queue.pop();\n            left_queue.push({right_top_element.first + element_times[right_top_element.second][0] + element_times[right_top_element.second][2], right_top_element.second});\n        }\n        auto left_top_element= left_queue.top();\n        left_queue.pop();\n        element_times[left_top_element.second][2]+= element_times[left_top_element.second][3] + element_times[left_top_element.second][0] + element_times[left_top_element.second][1];\n        right_queue.push({left_top_element.first + element_times[left_top_element.second][1], left_top_element.second});\n        total_moments--;\n    }\n\n    int last_moment= -1;\n    while(!right_queue.empty())\n    {\n        last_moment= max(last_moment, element_times[right_queue.top().second][2]);\n        right_queue.pop();\n    }\n    return last_moment;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\n// for std::max\nusing namespace std;\n\nint countGoodStrings(int minLength, int maxLength, int oneGroupSize, int zeroGroupSize, int modulo = 1000000007)\n{\n    int maxCount = maxLength / oneGroupSize + maxLength / zeroGroupSize;\n\n    vector<long long> dynamicProgramming(maxCount + 1);\n    dynamicProgramming[0] = 1;\n\n    for (int index = 1; index <= maxCount; index++)\n        dynamicProgramming[index] = (dynamicProgramming[index - 1] * (index % oneGroupSize == 0 || index % zeroGroupSize == 0)) % modulo;\n\n    long long result = 0;\n    for (int index = 0; index <= maxCount; index++)\n    {\n        result = (result + dynamicProgramming[minLength / oneGroupSize + minLength / zeroGroupSize - index] - \n            (minLength - 1) / oneGroupSize - (minLength - 1) / zeroGroupSize + index < 0 ? 0\n            : dynamicProgramming[(minLength - 1) / oneGroupSize + (minLength - 1) / zeroGroupSize - index]) % modulo;\n    }\n\n    return result;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countGoodStrings(int min_length, int max_length, int one_group_size, int zero_group_size, int modulo= 1000000007)\n{\n    int max_count= max_length / one_group_size + max_length / zero_group_size;\n\n    vector<long long> dynamic_programming(max_count + 1);\n    dynamic_programming[0]= 1;\n\n    for(int index= 1; index <= max_count; index++)\n        dynamic_programming[index]= (dynamic_programming[index - 1] * (index % one_group_size == 0 || index % zero_group_size == 0)) % modulo;\n\n    long long result= 0;\n    for(int index= 0; index <= max_count; index++)\n    {\n        result= (result + dynamic_programming[min_length / one_group_size + min_length / zero_group_size - index] - (min_length - 1) / one_group_size - (min_length - 1) / zero_group_size + index < 0 ? 0\n                                                                                                                                                                                          : dynamic_programming[(min_length - 1) / one_group_size + (min_length - 1) / zero_group_size - index]) %\n                modulo;\n    }\n\n    return result;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> timeCrossingTheDoor(vector<int> &arrivalTimes, vector<int> &personState)\n{\n    int numberOfPersons= arrivalTimes.size();\n    vector<int> crossingTimes(numberOfPersons);\n    vector<int> lastSeenTimeAtDoor(2, -1);\n\n    for(int personIndex= 0, currentTime= 0; personIndex < numberOfPersons; ++personIndex, ++currentTime)\n    {\n        while(currentTime < arrivalTimes[personIndex])\n            currentTime++;\n\n        int direction= (lastSeenTimeAtDoor[1] != currentTime - 1) ? 1 : 0;\n\n        if(personState[personIndex] == direction)\n        {\n            lastSeenTimeAtDoor[personState[personIndex]]= currentTime;\n        }\n        else\n        {\n            while(personIndex + 1 < numberOfPersons && arrivalTimes[personIndex + 1] == currentTime && personState[personIndex + 1] != direction)\n                ++personIndex;\n\n            if(personIndex + 1 < numberOfPersons && arrivalTimes[personIndex + 1] == currentTime && personState[personIndex + 1] == direction)\n            {\n                lastSeenTimeAtDoor[personState[personIndex= personIndex + 1]]= currentTime;\n            }\n            else\n            {\n                currentTime--, personIndex--;\n            }\n        }\n        crossingTimes[personIndex]= lastSeenTimeAtDoor[personState[personIndex]];\n    }\n    return crossingTimes;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> timeCrossingTheDoor(vector<int> &arrival_times, vector<int> &person_state)\n{\n    int number_of_persons= arrival_times.size();\n    vector<int> crossing_times(number_of_persons);\n    vector<int> last_seen_time_at_door(2, -1);\n\n    for(int person_index= 0, current_time= 0; person_index < number_of_persons; ++person_index, ++current_time)\n    {\n        while(current_time < arrival_times[person_index])\n            current_time++;\n\n        int direction= (last_seen_time_at_door[1] != current_time - 1) ? 1 : 0;\n\n        if(person_state[person_index] == direction)\n        {\n            last_seen_time_at_door[person_state[person_index]]= current_time;\n        }\n        else\n        {\n            while(person_index + 1 < number_of_persons && arrival_times[person_index + 1] == current_time && person_state[person_index + 1] != direction)\n                ++person_index;\n\n            if(person_index + 1 < number_of_persons && arrival_times[person_index + 1] == current_time && person_state[person_index + 1] == direction)\n            {\n                last_seen_time_at_door[person_state[person_index= person_index + 1]]= current_time;\n            }\n            else\n            {\n                current_time--, person_index--;\n            }\n        }\n        crossing_times[person_index]= last_seen_time_at_door[person_state[person_index]];\n    }\n    return crossing_times;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\n// For abs function\nusing namespace std;\n\nint differenceBetweenElementAndDigitSum(vector<int> &numbers)\n{\n    int totalElementSum = 0, totalDigitSum = 0;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int currentNumber = numbers[i];\n        totalElementSum += currentNumber;\n        int tempNumber = currentNumber; // Create a temporary variable to hold the current number\n        while (tempNumber > 0)\n        {\n            totalDigitSum += tempNumber % 10;\n            tempNumber /= 10;\n        }\n    }\n    return abs(totalElementSum - totalDigitSum);\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\n// for abs\nusing namespace std;\n\nint differenceBetweenElementAndDigitSum(vector<int> &numbers)\n{\n    int total_element_sum= 0, total_digit_sum= 0;\n    for(int current_number : numbers)\n    {\n        total_element_sum+= current_number;\n        int temp_number= current_number; // Create a temporary variable to hold the current number\n        while(temp_number > 0)\n        {\n            total_digit_sum+= temp_number % 10;\n            temp_number/= 10;\n        }\n    }\n    return abs(total_element_sum - total_digit_sum);\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> applyQueries(int matrixSize, vector<vector<int>> &queryList)\n{\n    vector<vector<int>> matrix(matrixSize, vector<int>(matrixSize, 0));\n\n    for (int i = 0; i < queryList.size(); ++i)\n    {\n        auto &query = queryList[i];\n        for (int row = query[0]; row <= query[2]; ++row)\n        {\n            for (int col = query[1]; col <= query[3]; ++col)\n            {\n                matrix[row][col]++;\n            }\n        }\n    }\n\n    return matrix;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> applyQueries(int matrix_size, vector<vector<int>> &query_list)\n{\n    vector<vector<int>> matrix(matrix_size, vector<int>(matrix_size, 0));\n\n    for(auto &query : query_list)\n    {\n        for(int row= query[0]; row <= query[2]; ++row)\n        {\n            for(int col= query[1]; col <= query[3]; ++col)\n            {\n                matrix[row][col]++;\n            }\n        }\n    }\n\n    return matrix;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countGoodSubarrays(vector<int> &numbers, int targetSum)\n{\n    unordered_map<int, int> prefixSumCount;\n    int totalGoodSubarrays = 0, currentPrefixSum = 0;\n\n    prefixSumCount[0] = 1;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int number = numbers[i];\n        currentPrefixSum += number - 1;\n        totalGoodSubarrays += prefixSumCount[currentPrefixSum - targetSum];\n        prefixSumCount[currentPrefixSum]++;\n    }\n\n    return totalGoodSubarrays;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countGoodSubarrays(vector<int> &numbers, int target_sum)\n{\n    unordered_map<int, int> prefix_sum_count;\n    int total_good_subarrays= 0, current_prefix_sum= 0;\n\n    prefix_sum_count[0]= 1;\n    for(int number : numbers)\n    {\n        current_prefix_sum+= number - 1;\n        total_good_subarrays+= prefix_sum_count[current_prefix_sum - target_sum];\n        prefix_sum_count[current_prefix_sum]++;\n    }\n\n    return total_good_subarrays;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adjacencyList;\nvector<int> nodePrices;\nvector<pair<vector<long long>, vector<long long>>> dynamicProgramming;\n\nvoid depthFirstSearch(int currentNode, int parentNode)\n{\n    dynamicProgramming[currentNode].first[0] = nodePrices[currentNode];\n    dynamicProgramming[currentNode].first[1] = 0;\n    dynamicProgramming[currentNode].second[0] = nodePrices[currentNode];\n    dynamicProgramming[currentNode].second[1] = 0;\n\n    for (int i = 0; i < adjacencyList[currentNode].size(); ++i)\n    {\n        int neighborNode = adjacencyList[currentNode][i];\n        if (neighborNode == parentNode)\n            continue;\n        depthFirstSearch(neighborNode, currentNode);\n        dynamicProgramming[currentNode].first.push_back(dynamicProgramming[neighborNode].first[0] + nodePrices[currentNode] - dynamicProgramming[neighborNode].second[0]);\n        dynamicProgramming[currentNode].first.push_back(dynamicProgramming[neighborNode].first[1]);\n        dynamicProgramming[currentNode].second.push_back(dynamicProgramming[neighborNode].second[0] + nodePrices[currentNode] - dynamicProgramming[neighborNode].first[0]);\n        dynamicProgramming[currentNode].second.push_back(dynamicProgramming[neighborNode].second[1]);\n\n        sort(dynamicProgramming[currentNode].first.begin(), dynamicProgramming[currentNode].first.end());\n        sort(dynamicProgramming[currentNode].second.begin(), dynamicProgramming[currentNode].second.end());\n    }\n}\n\nint getMaxCost(int numberOfNodes, vector<vector<int>> &edges, vector<int> &priceList)\n{\n    adjacencyList.resize(numberOfNodes);\n    nodePrices = priceList;\n    dynamicProgramming.resize(numberOfNodes, pair<vector<long long>, vector<long long>>(vector<long long>(2), vector<long long>(2)));\n\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        vector<int> &edge = edges[i];\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    depthFirstSearch(0, -1);\n\n    long long maximumCost = 0;\n    for (int i = 0; i < numberOfNodes; ++i)\n    {\n        maximumCost = max(maximumCost, dynamicProgramming[i].first.back() - dynamicProgramming[i].second.back());\n    }\n\n    return maximumCost;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adjacency_list;\nvector<int> node_prices;\nvector<pair<vector<long long>, vector<long long>>> dynamic_programming;\n\nvoid depthFirstSearch(int current_node, int parent_node)\n{\n    dynamic_programming[current_node].first[0]= node_prices[current_node];\n    dynamic_programming[current_node].first[1]= 0;\n    dynamic_programming[current_node].second[0]= node_prices[current_node];\n    dynamic_programming[current_node].second[1]= 0;\n\n    for(int neighbor_node : adjacency_list[current_node])\n    {\n        if(neighbor_node == parent_node)\n            continue;\n        depthFirstSearch(neighbor_node, current_node);\n        dynamic_programming[current_node].first.push_back(dynamic_programming[neighbor_node].first[0] + node_prices[current_node] - dynamic_programming[neighbor_node].second[0]);\n        dynamic_programming[current_node].first.push_back(dynamic_programming[neighbor_node].first[1]);\n        dynamic_programming[current_node].second.push_back(dynamic_programming[neighbor_node].second[0] + node_prices[current_node] - dynamic_programming[neighbor_node].first[0]);\n        dynamic_programming[current_node].second.push_back(dynamic_programming[neighbor_node].second[1]);\n\n        sort(dynamic_programming[current_node].first.begin(), dynamic_programming[current_node].first.end());\n        sort(dynamic_programming[current_node].second.begin(), dynamic_programming[current_node].second.end());\n    }\n}\n\nint getMaxCost(int number_of_nodes, vector<vector<int>> &edges, vector<int> &price_list)\n{\n    adjacency_list.resize(number_of_nodes);\n    node_prices= price_list;\n    dynamic_programming.resize(number_of_nodes, pair<vector<long long>, vector<long long>>(vector<long long>(2), vector<long long>(2)));\n\n    for(vector<int> &edge : edges)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    depthFirstSearch(0, -1);\n\n    long long maximum_cost= 0;\n    for(int i= 0; i < number_of_nodes; ++i)\n    {\n        maximum_cost= max(maximum_cost, dynamic_programming[i].first.back() - dynamic_programming[i].second.back());\n    }\n\n    return maximum_cost;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countOfGoodSubsequences(string inputString)\n{\n    vector<int> characterCount(26, 0);\n    long totalCount = 0;\n    const int modulo = 1000000007;\n\n    for (char currentChar : inputString)\n    {\n        characterCount[currentChar - 'a']++;\n    }\n\n    for (int i = 0; i < characterCount.size(); ++i)\n    {\n        int occurrence = characterCount[i];\n        totalCount = (totalCount + (1L << occurrence) - 1) % modulo;\n    }\n\n    return totalCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countOfGoodSubsequences(string input_string)\n{\n    vector<int> character_count(26, 0);\n    long total_count= 0;\n    const int modulo= 1000000007;\n\n    for(char current_char : input_string)\n    {\n        character_count[current_char - 'a']++;\n    }\n\n    for(int occurrence : character_count)\n    {\n        total_count= (total_count + (1L << occurrence) - 1) % modulo;\n    }\n\n    return total_count;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint findMinimumCommonNumber(vector<int> &firstArray, vector<int> &secondArray)\n{\n    int firstIndex= 0, secondIndex= 0;\n    while(firstIndex < firstArray.size() && secondIndex < secondArray.size())\n    {\n        if(firstArray[firstIndex] == secondArray[secondIndex])\n        {\n            return firstArray[firstIndex];\n        }\n        else if(firstArray[firstIndex] < secondArray[secondIndex])\n        {\n            firstIndex++;\n        }\n        else\n        {\n            secondIndex++;\n        }\n    }\n    return -1;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findMinimumCommonNumber(vector<int> &first_array, vector<int> &second_array)\n{\n    int first_index= 0, second_index= 0;\n    while(first_index < first_array.size() && second_index < second_array.size())\n    {\n        if(first_array[first_index] == second_array[second_index])\n        {\n            return first_array[first_index];\n        }\n        else if(first_array[first_index] < second_array[second_index])\n        {\n            first_index++;\n        }\n        else\n        {\n            second_index++;\n        }\n    }\n    return -1;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\n// For abs function\nusing namespace std;\n\nint minChanges(vector<int> &firstArray, vector<int> &secondArray, int differenceFactor)\n{\n    int arraySize= firstArray.size();\n    int totalOperations= 0;\n    for(int index= 0; index < arraySize; ++index)\n    {\n        int difference= abs(firstArray[index] - secondArray[index]);\n        if(difference % differenceFactor != 0)\n            return -1;\n        totalOperations+= difference / differenceFactor;\n    }\n    return totalOperations;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minChanges(vector<int> &first_array, vector<int> &second_array, int difference_factor)\n{\n    int array_size= first_array.size();\n    int total_operations= 0;\n    for(int index= 0; index < array_size; ++index)\n    {\n        int difference= abs(first_array[index] - second_array[index]);\n        if(difference % difference_factor != 0)\n            return -1;\n        total_operations+= difference / difference_factor;\n    }\n    return total_operations;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxScore(vector<int> &firstArray, vector<int> &secondArray, int maxElements)\n{\n    int arraySize = firstArray.size();\n    int maximumResult = 0;\n    int sumFirstArray = 0, minimumSecondArray = secondArray[0];\n    for(int startIndex = 0, endIndex = 0; endIndex < arraySize; ++endIndex)\n    {\n        sumFirstArray += firstArray[endIndex];\n        minimumSecondArray = min(minimumSecondArray, secondArray[endIndex]);\n        if(endIndex - startIndex + 1 > maxElements)\n            sumFirstArray -= firstArray[startIndex++];\n        if(endIndex + 1 >= maxElements)\n            maximumResult = max(maximumResult, sumFirstArray * minimumSecondArray);\n    }\n    return maximumResult;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxScore(vector<int> &first_array, vector<int> &second_array, int max_elements)\n{\n    int array_size= first_array.size();\n    int maximum_result= 0;\n    int sum_first_array= 0, minimum_second_array= second_array[0];\n    for(int start_index= 0, end_index= 0; end_index < array_size; ++end_index)\n    {\n        sum_first_array+= first_array[end_index];\n        minimum_second_array= min(minimum_second_array, second_array[end_index]);\n        if(end_index - start_index + 1 > max_elements)\n            sum_first_array-= first_array[start_index++];\n        if(end_index + 1 >= max_elements)\n            maximum_result= max(maximum_result, sum_first_array * minimum_second_array);\n    }\n    return maximum_result;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nbool canReach(int targetX, int targetY)\n{\n    while(targetX > 1 && targetY > 1)\n    {\n        if(targetX < targetY)\n            swap(targetX, targetY);\n        targetX-= targetY;\n    }\n    return targetX == 1 || targetY == 1;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "bool canReach(int target_x, int target_y)\n{\n    while(target_x > 1 && target_y > 1)\n    {\n        if(target_x < target_y)\n            swap(target_x, target_y);\n        target_x-= target_y;\n    }\n    return target_x == 1 || target_y == 1;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint sumOfDigits(int inputNumber)\n{\n    int digitSum= 0;\n    bool isPositive= true;\n\n    while(inputNumber > 0)\n    {\n        int currentDigit= inputNumber % 10;\n        inputNumber/= 10;\n\n        if(isPositive)\n        {\n            digitSum+= currentDigit;\n        }\n        else\n        {\n            digitSum-= currentDigit;\n        }\n\n        isPositive= !isPositive;\n    }\n\n    return digitSum;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int sumOfDigits(int input_number)\n{\n    int digit_sum= 0;\n    bool is_positive= true;\n\n    while(input_number > 0)\n    {\n        int current_digit= input_number % 10;\n        input_number/= 10;\n\n        if(is_positive)\n        {\n            digit_sum+= current_digit;\n        }\n        else\n        {\n            digit_sum-= current_digit;\n        }\n\n        is_positive= !is_positive;\n    }\n\n    return digit_sum;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> sortStudents(vector<vector<int>> &studentScores, int scoreIndex)\n{\n    sort(studentScores.begin(), studentScores.end(), [scoreIndex](const vector<int> &firstStudent, const vector<int> &secondStudent)\n         { return firstStudent[scoreIndex] > secondStudent[scoreIndex]; });\n    return studentScores;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> sortStudents(vector<vector<int>> &student_scores, int score_index)\n{\n    sort(student_scores.begin(), student_scores.end(), [score_index](const vector<int> &first_student, const vector<int> &second_student)\n         { return first_student[score_index] > second_student[score_index]; });\n    return student_scores;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool canMakeEqual(string sourceString, string targetString)\n{\n    int sourceCountOnes= count(sourceString.begin(), sourceString.end(), '1');\n    int targetCountOnes= count(targetString.begin(), targetString.end(), '1');\n    return sourceCountOnes >= targetCountOnes;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canMakeEqual(string source_string, string target_string)\n{\n    int source_count_ones= count(source_string.begin(), source_string.end(), '1');\n    int target_count_ones= count(target_string.begin(), target_string.end(), '1');\n    return source_count_ones >= target_count_ones;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\n// For std::min\nusing namespace std;\n\nint getCost(int endIndex, vector<int> &frequencyCount, vector<int> &numberList)\n{\n    return frequencyCount[numberList[endIndex]] == 1 ? 1 : 0;\n}\n\nint minCost(vector<int> &numberList, int cost)\n{\n    int listSize= numberList.size(), infinity= 1e9 + 7;\n    vector<int> frequencyCount(1001, 0), dynamicProgramming(listSize + 1, 0); // frequencyCount for frequency, dynamicProgramming for dynamic programming\n\n    for(int startIndex= 0, endIndex= 0; endIndex < listSize; ++endIndex)\n    {\n        ++frequencyCount[numberList[endIndex]];\n\n        if(frequencyCount[numberList[endIndex]] == 2) // if occurrence is 2, change dynamicProgramming\n            dynamicProgramming[endIndex + 1]= dynamicProgramming[startIndex] + cost + (endIndex - startIndex + 1);\n        else if(frequencyCount[numberList[endIndex]] > 2) // if occurrence is more than 2\n            dynamicProgramming[endIndex + 1]= min(dynamicProgramming[endIndex], dynamicProgramming[endIndex - 1] - (frequencyCount[numberList[endIndex]] - 2));\n        else\n            dynamicProgramming[endIndex + 1]= dynamicProgramming[endIndex] + getCost(endIndex, frequencyCount, numberList) + cost;\n\n        while(startIndex < endIndex + 1 && frequencyCount[numberList[startIndex]] >= 2)\n        {\n            --frequencyCount[numberList[startIndex]];\n            ++startIndex; // update first pointer startIndex when numberList[startIndex] has occurred more than once\n        }\n    }\n\n    return dynamicProgramming[listSize];\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint getCost(int end_index, vector<int> &frequency_count, vector<int> &number_list)\n{\n    return frequency_count[number_list[end_index]] == 1 ? 1 : 0;\n}\n\nint minCost(vector<int> &number_list, int cost)\n{\n    int list_size= number_list.size(), infinity= 1e9 + 7;\n    vector<int> frequency_count(1001, 0), dynamic_programming(list_size + 1, 0); // frequency_count for frequency, dynamic_programming for dynamic programming\n\n    for(int start_index= 0, end_index= 0; end_index < list_size; ++end_index)\n    {\n        ++frequency_count[number_list[end_index]];\n\n        if(frequency_count[number_list[end_index]] == 2) // if occurrence is 2, change dynamic_programming\n            dynamic_programming[end_index + 1]= dynamic_programming[start_index] + cost + (end_index - start_index + 1);\n        else if(frequency_count[number_list[end_index]] > 2) // if occurrence is more than 2\n            dynamic_programming[end_index + 1]= min(dynamic_programming[end_index], dynamic_programming[end_index - 1] - (frequency_count[number_list[end_index]] - 2));\n        else\n            dynamic_programming[end_index + 1]= dynamic_programming[end_index] + getCost(end_index, frequency_count, number_list) + cost;\n\n        while(start_index < end_index + 1 && frequency_count[number_list[start_index]] >= 2)\n        {\n            --frequency_count[number_list[start_index]];\n            ++start_index; // update first pointer start_index when number_list[start_index] has occurred more than once\n        }\n    }\n\n    return dynamic_programming[list_size];\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble maxValue(vector<vector<int>> &items, int capacity)\n{\n    sort(items.begin(), items.end(), [](const vector<int> &a, const vector<int> &b)\n         { return (double)a[0] / a[1] > (double)b[0] / b[1]; });\n\n    double maxTotalPrice = 0;\n    for (int i = 0; i < items.size(); ++i)\n    {\n        const auto &item = items[i];\n        if (capacity >= item[1])\n        {\n            capacity -= item[1];\n            maxTotalPrice += item[0];\n        }\n        else\n        {\n            maxTotalPrice += (double)item[0] * capacity / item[1];\n            break;\n        }\n    }\n\n    return maxTotalPrice;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble maxValue(vector<vector<int>> &items, int capacity)\n{\n    sort(items.begin(), items.end(), [](const vector<int> &a, const vector<int> &b)\n         { return (double)a[0] / a[1] > (double)b[0] / b[1]; });\n\n    double max_total_price= 0;\n    for(const auto &item : items)\n    {\n        if(capacity >= item[1])\n        {\n            capacity-= item[1];\n            max_total_price+= item[0];\n        }\n        else\n        {\n            max_total_price+= (double)item[0] * capacity / item[1];\n            break;\n        }\n    }\n\n    return max_total_price;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint distinctCount(int totalNumbers)\n{\n    return totalNumbers - 1;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int distinctCount(int total_numbers)\n{\n    return total_numbers - 1;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod= 1e9 + 7;\n\nint waysToCollide(int numberOfObjects)\n{\n    int powerOfTwo= 1;\n    for(int index= 0; index < numberOfObjects; index++)\n    {\n        powerOfTwo= (2LL * powerOfTwo) % mod;\n    }\n    return (powerOfTwo - numberOfObjects - 1 + mod) % mod;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod= 1e9 + 7;\n\nint waysToCollide(int number_of_objects)\n{\n    int power_of_two= 1;\n    for(int index= 0; index < number_of_objects; index++)\n    {\n        power_of_two= (2LL * power_of_two) % mod;\n    }\n    return (power_of_two - number_of_objects - 1 + mod) % mod;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maximizeScore(vector<int> &weightValues, int numberOfGroups)\n{\n    int totalWeights= weightValues.size();\n    vector<int> prefixSum(totalWeights + 1);\n    partial_sum(weightValues.begin(), weightValues.end(), prefixSum.begin() + 1);\n    vector<vector<int>> dynamicProgramming(totalWeights, vector<int>(numberOfGroups + 1));\n\n    for(int currentIndex= 0; currentIndex < totalWeights; currentIndex++)\n    {\n        for(int groupIndex= 1; groupIndex <= numberOfGroups; groupIndex++)\n        {\n            dynamicProgramming[currentIndex][groupIndex]= -1e9;\n        }\n    }\n\n    for(int currentIndex= 0; currentIndex < totalWeights; currentIndex++)\n    {\n        dynamicProgramming[currentIndex][1]= prefixSum[currentIndex + 1];\n        if(currentIndex > 0)\n        {\n            dynamicProgramming[currentIndex][currentIndex + 1]= prefixSum[currentIndex + 1] - prefixSum[1];\n        }\n        for(int groupIndex= 2; groupIndex <= min<int>(currentIndex + 1, numberOfGroups); groupIndex++)\n        {\n            for(int previousGroupSize= 1; previousGroupSize <= currentIndex - groupIndex + 2; previousGroupSize++)\n            {\n                dynamicProgramming[currentIndex][groupIndex]= max(dynamicProgramming[currentIndex][groupIndex],\n                                                                   dynamicProgramming[currentIndex - previousGroupSize][groupIndex - 1] + weightValues[currentIndex] + weightValues[currentIndex - previousGroupSize]);\n            }\n        }\n    }\n\n    return dynamicProgramming[totalWeights - 1][numberOfGroups] - dynamicProgramming[totalWeights - 1][1];\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maximizeScore(vector<int> &weight_values, int number_of_groups)\n{\n    int total_weights = weight_values.size();\n    vector<int> prefix_sum(total_weights + 1);\n    partial_sum(weight_values.begin(), weight_values.end(), prefix_sum.begin() + 1);\n    vector<vector<int>> dynamic_programming(total_weights, vector<int>(number_of_groups + 1));\n\n    for(int current_index = 0; current_index < total_weights; current_index++)\n    {\n        for(int group_index = 1; group_index <= number_of_groups; group_index++)\n        {\n            dynamic_programming[current_index][group_index] = -1e9;\n        }\n    }\n\n    for(int current_index = 0; current_index < total_weights; current_index++)\n    {\n        dynamic_programming[current_index][1] = prefix_sum[current_index + 1];\n        if(current_index > 0)\n        {\n            dynamic_programming[current_index][current_index + 1] = prefix_sum[current_index + 1] - prefix_sum[1];\n        }\n        for(int group_index = 2; group_index <= min<int>(current_index + 1, number_of_groups); group_index++)\n        {\n            for(int previous_group_size = 1; previous_group_size <= current_index - group_index + 2; previous_group_size++)\n            {\n                dynamic_programming[current_index][group_index] = max(dynamic_programming[current_index][group_index],\n                                                                       dynamic_programming[current_index - previous_group_size][group_index - 1] + weight_values[current_index] + weight_values[current_index - previous_group_size]);\n            }\n        }\n    }\n\n    return dynamic_programming[total_weights - 1][number_of_groups] - dynamic_programming[total_weights - 1][1];\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countIncreasingQuadruplets(vector<int> &numberList)\n{\n    int listSize= numberList.size(), quadrupletCount= 0;\n    for(int firstIndex= 0; firstIndex < listSize - 3; firstIndex++)\n    {\n        for(int secondIndex= firstIndex + 1; secondIndex < listSize - 2; secondIndex++)\n        {\n            for(int thirdIndex= secondIndex + 1; thirdIndex < listSize - 1; thirdIndex++)\n            {\n                if(numberList[firstIndex] < numberList[thirdIndex] && numberList[thirdIndex] < numberList[secondIndex])\n                {\n                    for(int fourthIndex= thirdIndex + 1; fourthIndex < listSize; fourthIndex++)\n                    {\n                        if(numberList[secondIndex] < numberList[fourthIndex])\n                        {\n                            quadrupletCount++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return quadrupletCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countIncreasingQuadruplets(vector<int> &number_list)\n{\n    int list_size= number_list.size(), quadruplet_count= 0;\n    for(int first_index= 0; first_index < list_size - 3; first_index++)\n    {\n        for(int second_index= first_index + 1; second_index < list_size - 2; second_index++)\n        {\n            for(int third_index= second_index + 1; third_index < list_size - 1; third_index++)\n            {\n                if(number_list[first_index] < number_list[third_index] && number_list[third_index] < number_list[second_index])\n                {\n                    for(int fourth_index= third_index + 1; fourth_index < list_size; fourth_index++)\n                    {\n                        if(number_list[second_index] < number_list[fourth_index])\n                        {\n                            quadruplet_count++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return quadruplet_count;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> separateDigits(const vector<int> &inputNumbers)\n{\n    vector<int> resultDigits;\n    for (int i = 0; i < inputNumbers.size(); ++i)\n    {\n        int currentNumber = inputNumbers[i];\n        vector<int> extractedDigits;\n        while (currentNumber)\n        {\n            extractedDigits.insert(extractedDigits.begin(), currentNumber % 10);\n            currentNumber /= 10;\n        }\n        resultDigits.insert(resultDigits.end(), extractedDigits.begin(), extractedDigits.end());\n    }\n    return resultDigits;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> separateDigits(const vector<int> &input_numbers)\n{\n    vector<int> result_digits;\n    for(auto current_number : input_numbers)\n    {\n        vector<int> extracted_digits;\n        while(current_number)\n        {\n            extracted_digits.insert(extracted_digits.begin(), current_number % 10);\n            current_number /= 10;\n        }\n        result_digits.insert(result_digits.end(), extracted_digits.begin(), extracted_digits.end());\n    }\n    return result_digits;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxChosenIntegers(vector<int> &bannedIntegers, int totalIntegers, int maxSum)\n{\n    unordered_set<int> bannedSet(bannedIntegers.begin(), bannedIntegers.end());\n    int chosenCount= 0, currentSum= 0;\n    for(int integer= totalIntegers; integer >= 1 && maxSum - currentSum >= integer; --integer)\n    {\n        if(bannedSet.find(integer) == bannedSet.end())\n        {\n            currentSum+= integer;\n            ++chosenCount;\n        }\n    }\n    return chosenCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxChosenIntegers(vector<int> &banned_integers, int total_integers, int max_sum)\n{\n    unordered_set<int> banned_set(banned_integers.begin(), banned_integers.end());\n    int chosen_count= 0, current_sum= 0;\n    for(int integer= total_integers; integer >= 1 && max_sum - current_sum >= integer; --integer)\n    {\n        if(banned_set.find(integer) == banned_set.end())\n        {\n            current_sum+= integer;\n            ++chosen_count;\n        }\n    }\n    return chosen_count;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxPrizes(vector<int> &prizePositions, int maxDistance)\n{\n    int totalPositions= prizePositions.size();\n    int maximumPrizes= 0;\n    for(int currentIndex= 0; currentIndex < totalPositions; ++currentIndex)\n    {\n        int leftSegmentEnd= prizePositions[currentIndex] + maxDistance;\n        int rightSegmentStart= upper_bound(prizePositions.begin(), prizePositions.end(), leftSegmentEnd) - prizePositions.begin();\n        int rightSegmentEnd= prizePositions[rightSegmentStart] + maxDistance;\n        maximumPrizes= max(maximumPrizes, int(upper_bound(prizePositions.begin(), prizePositions.end(), rightSegmentEnd) - lower_bound(prizePositions.begin(), prizePositions.end(), prizePositions[currentIndex])));\n    }\n    return maximumPrizes;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxPrizes(vector<int> &prize_positions, int max_distance)\n{\n    int total_positions= prize_positions.size();\n    int maximum_prizes= 0;\n    for(int current_index= 0; current_index < total_positions; ++current_index)\n    {\n        int left_segment_end= prize_positions[current_index] + max_distance;\n        int right_segment_start= upper_bound(prize_positions.begin(), prize_positions.end(), left_segment_end) - prize_positions.begin();\n        int right_segment_end= prize_positions[right_segment_start] + max_distance;\n        maximum_prizes= max(maximum_prizes, int(upper_bound(prize_positions.begin(), prize_positions.end(), right_segment_end) - lower_bound(prize_positions.begin(), prize_positions.end(), prize_positions[current_index])));\n    }\n    return maximum_prizes;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool canReach(vector<vector<int>> &grid, int currentRow, int currentCol)\n{\n    if(currentRow < 0 || currentCol < 0 || currentRow >= grid.size() || currentCol >= grid[0].size() || grid[currentRow][currentCol] == 0)\n        return false;\n\n    if(currentRow == grid.size() - 1 && currentCol == grid[0].size() - 1)\n        return true;\n\n    grid[currentRow][currentCol]= 0;\n\n    return canReach(grid, currentRow + 1, currentCol) || canReach(grid, currentRow, currentCol + 1);\n}\n\nbool canDisconnect(vector<vector<int>> &grid)\n{\n    int reachableCount= 0;\n\n    for(int currentRow= 1; currentRow < grid.size(); currentRow++)\n    {\n        for(int currentCol= 1; currentCol < grid[0].size(); currentCol++)\n        {\n            if(grid[currentRow][currentCol] == 1 && (canReach(grid, currentRow - 1, currentCol) || canReach(grid, currentRow, currentCol - 1)))\n            {\n                reachableCount++;\n                if(reachableCount > 1)\n                    return true;\n            }\n        }\n    }\n\n    return reachableCount <= 1;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canReach(vector<vector<int>> &grid, int current_row, int current_col)\n{\n    if(current_row < 0 || current_col < 0 || current_row >= grid.size() || current_col >= grid[0].size() || grid[current_row][current_col] == 0)\n        return false;\n\n    if(current_row == grid.size() - 1 && current_col == grid[0].size() - 1)\n        return true;\n\n    grid[current_row][current_col] = 0;\n\n    return canReach(grid, current_row + 1, current_col) || canReach(grid, current_row, current_col + 1);\n}\n\nbool canDisconnect(vector<vector<int>> &grid)\n{\n    int reachable_count = 0;\n\n    for(int current_row = 1; current_row < grid.size(); current_row++)\n    {\n        for(int current_col = 1; current_col < grid[0].size(); current_col++)\n        {\n            if(grid[current_row][current_col] == 1 && (canReach(grid, current_row - 1, current_col) || canReach(grid, current_row, current_col - 1)))\n            {\n                reachable_count++;\n                if(reachable_count > 1)\n                    return true;\n            }\n        }\n    }\n\n    return reachable_count <= 1;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxChosenIntegers(vector<int> &bannedIntegers, int totalIntegers, long long maxAllowedSum)\n{\n    unordered_set<int> bannedSet(bannedIntegers.begin(), bannedIntegers.end());\n    int countChosenIntegers= 0;\n    long long currentChosenSum= 0;\n\n    for(int i= totalIntegers; i > 0 && currentChosenSum < maxAllowedSum; --i)\n    {\n        if(bannedSet.find(i) == bannedSet.end())\n        {\n            if(currentChosenSum + i <= maxAllowedSum)\n            {\n                currentChosenSum+= i;\n                countChosenIntegers++;\n            }\n            else\n            {\n                break;\n            }\n        }\n    }\n\n    return countChosenIntegers;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxChosenIntegers(vector<int> &banned_integers, int total_integers, long long max_allowed_sum)\n{\n    unordered_set<int> banned_set(banned_integers.begin(), banned_integers.end());\n    int count_chosen_integers= 0;\n    long long current_chosen_sum= 0;\n\n    for(int i= total_integers; i > 0 && current_chosen_sum < max_allowed_sum; --i)\n    {\n        if(banned_set.find(i) == banned_set.end())\n        {\n            if(current_chosen_sum + i <= max_allowed_sum)\n            {\n                current_chosen_sum+= i;\n                count_chosen_integers++;\n            }\n            else\n            {\n                break;\n            }\n        }\n    }\n\n    return count_chosen_integers;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint giftsRemaining(vector<int> &giftValues, int numberOfIterations)\n{\n    for(int iteration = 0; iteration < numberOfIterations; iteration++)\n    {\n        sort(giftValues.begin(), giftValues.end());\n        int maxIndex = giftValues.size() - 1;\n        giftValues[maxIndex] -= static_cast<int>(sqrt(giftValues[maxIndex]));\n    }\n    int totalRemainingGifts = 0;\n    for(int j = 0; j < giftValues.size(); j++)\n        totalRemainingGifts += giftValues[j];\n    return totalRemainingGifts;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint giftsRemaining(vector<int> &gift_values, int number_of_iterations)\n{\n    for(int iteration= 0; iteration < number_of_iterations; iteration++)\n    {\n        sort(gift_values.begin(), gift_values.end());\n        int max_index= gift_values.size() - 1;\n        gift_values[max_index]-= static_cast<int>(sqrt(gift_values[max_index]));\n    }\n    int total_remaining_gifts= 0;\n    for(int gift : gift_values)\n        total_remaining_gifts+= gift;\n    return total_remaining_gifts;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isVowel(char character)\n{\n    return character == 'a' || character == 'e' || character == 'i' || character == 'o' || character == 'u';\n}\n\nvector<int> countVowelStrings(vector<string> &wordList, vector<vector<int>> &queryRanges)\n{\n    vector<int> result;\n    for (int i = 0; i < queryRanges.size(); ++i)\n    {\n        auto &query = queryRanges[i];\n        int vowelStringCount = 0;\n        for (int index = query[0]; index <= query[1]; index++)\n        {\n            if (isVowel(wordList[index].front()) && isVowel(wordList[index].back()))\n            {\n                vowelStringCount++;\n            }\n        }\n        result.push_back(vowelStringCount);\n    }\n    return result;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isVowel(char character)\n{\n    return character == 'a' || character == 'e' || character == 'i' || character == 'o' || character == 'u';\n}\n\nvector<int> countVowelStrings(vector<string> &word_list, vector<vector<int>> &query_ranges)\n{\n    vector<int> result;\n    for(auto &query : query_ranges)\n    {\n        int vowel_string_count= 0;\n        for(int index= query[0]; index <= query[1]; index++)\n        {\n            if(isVowel(word_list[index].front()) && isVowel(word_list[index].back()))\n            {\n                vowel_string_count++;\n            }\n        }\n        result.push_back(vowel_string_count);\n    }\n    return result;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint findMinimumCapability(vector<int> &numberList, int requiredCount)\n{\n    int size= numberList.size(), left= 1, right= 1e9;\n    while(left < right)\n    {\n        int mid= left + (right - left) / 2, index= 0, count= 0;\n        for(int j= 0; j < size; ++j)\n        {\n            if(numberList[j] <= mid)\n            {\n                ++count;\n                index= j + 2;\n                while(index + 1 < size && (index == j + 1 || numberList[index] > mid))\n                    ++index;\n            }\n        }\n        if(count < requiredCount)\n            left= mid + 1;\n        else\n            right= mid;\n    }\n    return left;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findMinimumCapability(vector<int> &number_list, int required_count)\n{\n    int size= number_list.size(), left= 1, right= 1e9;\n    while(left < right)\n    {\n        int mid= left + (right - left) / 2, index= 0, count= 0;\n        for(int j= 0; j < size; ++j)\n        {\n            if(number_list[j] <= mid)\n            {\n                ++count;\n                index= j + 2;\n                while(index + 1 < size && (index == j + 1 || number_list[index] > mid))\n                    ++index;\n            }\n        }\n        if(count < required_count)\n            left= mid + 1;\n        else\n            right= mid;\n    }\n    return left;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minCostToEqualBaskets(vector<int> &basket1, vector<int> &basket2)\n{\n    unordered_map<int, int> differenceCount;\n    for (int index = 0; index < basket1.size(); index++)\n    {\n        differenceCount[basket1[index] - basket2[index]]++;\n    }\n\n    int minimumCost = INT_MAX, currentCost = 0;\n    for (auto it = differenceCount.begin(); it != differenceCount.end(); ++it) // traditional for loop\n    {\n        const auto &entry = *it;\n        if (entry.second == differenceCount[-entry.first])\n        {\n            currentCost = 0;\n            for (int index = 0; index < basket1.size(); index++)\n            {\n                if (basket1[index] - basket2[index] == entry.first)\n                {\n                    currentCost += min(basket1[index], basket2[index]);\n                }\n            }\n            minimumCost = min(minimumCost, currentCost);\n        }\n    }\n\n    return minimumCost == INT_MAX ? -1 : minimumCost / 2;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minCostToEqualBaskets(vector<int> &basket1, vector<int> &basket2)\n{\n    unordered_map<int, int> difference_count;\n    for(int index= 0; index < basket1.size(); index++)\n    {\n        difference_count[basket1[index] - basket2[index]]++;\n    }\n\n    int minimum_cost= INT_MAX, current_cost= 0;\n    for(const auto &entry : difference_count)\n    {\n        if(entry.second == difference_count[-entry.first])\n        {\n            current_cost= 0;\n            for(int index= 0; index < basket1.size(); index++)\n            {\n                if(basket1[index] - basket2[index] == entry.first)\n                {\n                    current_cost+= min(basket1[index], basket2[index]);\n                }\n            }\n            minimum_cost= min(minimum_cost, current_cost);\n        }\n    }\n\n    return minimum_cost == INT_MAX ? -1 : minimum_cost / 2;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint concatenationValue(vector<int> &numberList)\n{\n    int concatenatedValue= 0;\n    while(!numberList.empty())\n    {\n        int size= numberList.size();\n        if(size == 1)\n        {\n            concatenatedValue+= numberList[0];\n            numberList.pop_back();\n        }\n        else\n        {\n            concatenatedValue+= stoi(to_string(numberList[0]) + to_string(numberList[size - 1]));\n            numberList.erase(numberList.begin());\n            numberList.pop_back();\n        }\n    }\n    return concatenatedValue;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint concatenationValue(vector<int> &number_list)\n{\n    int concatenated_value= 0;\n    while(!number_list.empty())\n    {\n        int size= number_list.size();\n        if(size == 1)\n        {\n            concatenated_value+= number_list[0];\n            number_list.pop_back();\n        }\n        else\n        {\n            concatenated_value+= stoi(to_string(number_list[0]) + to_string(number_list[size - 1]));\n            number_list.erase(number_list.begin());\n            number_list.pop_back();\n        }\n    }\n    return concatenated_value;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countFairPairs(vector<int> &numbers, int lowerBound, int upperBound)\n{\n    int size= numbers.size();\n    int fairPairCount= 0;\n    for(int indexI= 0; indexI < size; ++indexI)\n    {\n        for(int indexJ= indexI + 1; indexJ < size; ++indexJ)\n        {\n            if((lowerBound <= numbers[indexI] + numbers[indexJ]) && (numbers[indexI] + numbers[indexJ] <= upperBound))\n            {\n                fairPairCount++;\n            }\n        }\n    }\n    return fairPairCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countFairPairs(vector<int> &numbers, int lower_bound, int upper_bound)\n{\n    int size= numbers.size();\n    int fair_pair_count= 0;\n    for(int index_i= 0; index_i < size; ++index_i)\n    {\n        for(int index_j= index_i + 1; index_j < size; ++index_j)\n        {\n            if((lower_bound <= numbers[index_i] + numbers[index_j]) && (numbers[index_i] + numbers[index_j] <= upper_bound))\n            {\n                fair_pair_count++;\n            }\n        }\n    }\n    return fair_pair_count;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\n// Include this for log2 function\n\nusing namespace std;\n\nvector<vector<int>> shortestSubstringQueries(const string &inputString, const vector<vector<int>> &queryPairs)\n{\n    int stringLength = inputString.length();\n    unordered_map<int, int> indexMap;\n\n    for(int currentIndex = 0, currentValue = 0, bitMask = 0; currentIndex < stringLength; currentIndex++)\n    {\n        bitMask |= 1 << (inputString[currentIndex] - '0');\n        currentValue = (currentValue << 1) | (inputString[currentIndex] - '0');\n\n        for(int bitPosition = 0; bitPosition <= 9 && currentIndex + 1 - (1 << bitPosition) >= 0; bitPosition++)\n        {\n            int newValue = currentValue & ((1 << (bitPosition + 1)) - 1);\n            if(indexMap.count(newValue) == 0)\n                indexMap[newValue] = currentIndex + 1 - (1 << bitPosition);\n        }\n    }\n\n    vector<vector<int>> result;\n    for(int i = 0; i < queryPairs.size(); ++i)\n    {\n        const auto &query = queryPairs[i];\n        int targetValue = query[0] ^ query[1];\n        if(indexMap.count(targetValue))\n            result.push_back({indexMap[targetValue], indexMap[targetValue] + static_cast<int>(log2(targetValue))});\n        else\n            result.push_back({-1, -1});\n    }\n\n    return result;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\n// for log2\n\nusing namespace std;\n\nvector<vector<int>> shortestSubstringQueries(const string &input_string, const vector<vector<int>> &query_pairs)\n{\n    int string_length = input_string.length();\n    unordered_map<int, int> index_map;\n\n    for(int current_index = 0, current_value = 0, bit_mask = 0; current_index < string_length; current_index++)\n    {\n        bit_mask |= 1 << (input_string[current_index] - '0');\n        current_value = (current_value << 1) | (input_string[current_index] - '0');\n\n        for(int bit_position = 0; bit_position <= 9 && current_index + 1 - (1 << bit_position) >= 0; bit_position++)\n        {\n            int new_value = current_value & ((1 << (bit_position + 1)) - 1);\n            if(index_map.count(new_value) == 0)\n                index_map[new_value] = current_index + 1 - (1 << bit_position);\n        }\n    }\n\n    vector<vector<int>> result;\n    for(const auto &query : query_pairs)\n    {\n        int target_value = query[0] ^ query[1];\n        if(index_map.count(target_value))\n            result.push_back({index_map[target_value], index_map[target_value] + static_cast<int>(log2(target_value))});\n        else\n            result.push_back({-1, -1});\n    }\n\n    return result;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMinimumScore(string sourceString, string targetString)\n{\n    int sourceLength= sourceString.size(), targetLength= targetString.size();\n    vector<vector<int>> dynamicProgrammingTable(sourceLength + 1, vector<int>(targetLength + 1, 1e6));\n    dynamicProgrammingTable[0][0]= 0;\n    for(int sourceIndex= 0; sourceIndex < sourceLength; ++sourceIndex)\n        for(int targetIndex= 0; targetIndex < targetLength; ++targetIndex)\n            if(sourceString[sourceIndex] == targetString[targetIndex])\n                dynamicProgrammingTable[sourceIndex + 1][targetIndex + 1]= min(dynamicProgrammingTable[sourceIndex + 1][targetIndex + 1], dynamicProgrammingTable[sourceIndex][targetIndex]);\n            else\n                dynamicProgrammingTable[sourceIndex + 1][targetIndex]= min(dynamicProgrammingTable[sourceIndex + 1][targetIndex], dynamicProgrammingTable[sourceIndex][targetIndex] + 1);\n    int minimumScore= 1e6;\n    for(int sourceIndex= 0; sourceIndex < sourceLength; ++sourceIndex)\n        minimumScore= min(minimumScore, dynamicProgrammingTable[sourceIndex + 1][targetLength]);\n    return minimumScore;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMinimumScore(string source_string, string target_string)\n{\n    int source_length = source_string.size(), target_length = target_string.size();\n    vector<vector<int>> dynamic_programming_table(source_length + 1, vector<int>(target_length + 1, 1e6));\n    dynamic_programming_table[0][0] = 0;\n    \n    for(int source_index = 0; source_index < source_length; ++source_index)\n        for(int target_index = 0; target_index < target_length; ++target_index)\n            if(source_string[source_index] == target_string[target_index])\n                dynamic_programming_table[source_index + 1][target_index + 1] = min(dynamic_programming_table[source_index + 1][target_index + 1], dynamic_programming_table[source_index][target_index]);\n            else\n                dynamic_programming_table[source_index + 1][target_index] = min(dynamic_programming_table[source_index + 1][target_index], dynamic_programming_table[source_index][target_index] + 1);\n    \n    int minimum_score = 1e6;\n    for(int source_index = 0; source_index < source_length; ++source_index)\n        minimum_score = min(minimum_score, dynamic_programming_table[source_index + 1][target_length]);\n    \n    return minimum_score;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateDifferenceMaxMin(int inputNumber)\n{\n    int maxRemapValue = 1, minRemapValue = 9;\n    string numberString = to_string(inputNumber);\n    for (int i = 0; i < numberString.size(); ++i)\n    {\n        char digitChar = numberString[i];\n        int digitValue = digitChar - '0';\n        maxRemapValue = max(maxRemapValue, 9 - digitValue);\n        if (digitValue != 0)\n        {\n            minRemapValue = min(minRemapValue, digitValue);\n        }\n    }\n    int maxCalculatedValue = inputNumber + maxRemapValue * (numberString.length() - count(numberString.begin(), numberString.end(), '9' - maxRemapValue));\n    int minCalculatedValue = inputNumber - minRemapValue * count(numberString.begin(), numberString.end(), minRemapValue + '0');\n    return maxCalculatedValue - minCalculatedValue;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateDifferenceMaxMin(int input_number)\n{\n    int max_remap_value= 1, min_remap_value= 9;\n    string number_string= to_string(input_number);\n    for(char digit_char : number_string)\n    {\n        int digit_value= digit_char - '0';\n        max_remap_value= max(max_remap_value, 9 - digit_value);\n        if(digit_value != 0)\n        {\n            min_remap_value= min(min_remap_value, digit_value);\n        }\n    }\n    int max_calculated_value= input_number + max_remap_value * (number_string.length() - count(number_string.begin(), number_string.end(), '9' - max_remap_value));\n    int min_calculated_value= input_number - min_remap_value * count(number_string.begin(), number_string.end(), min_remap_value + '0');\n    return max_calculated_value - min_calculated_value;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minScoreAfterChange(vector<int> &numbers)\n{\n    int size = numbers.size();\n    int firstMin = numbers[0], secondMin = numbers[1], lastMax = numbers[size - 1], secondLastMax = numbers[size - 2];\n\n    for(int index = 1; index < size - 1; index++)\n    {\n        firstMin = min(firstMin, numbers[index]);\n        secondMin = min(secondMin, numbers[index + 1]);\n        lastMax = max(lastMax, numbers[index]);\n        secondLastMax = max(secondLastMax, numbers[index - 1]);\n    }\n\n    int low = min(min(firstMin, lastMax), min(secondMin, secondLastMax));\n    int high = max(max(firstMin, lastMax), max(secondMin, secondLastMax));\n\n    return high - low;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minScoreAfterChange(vector<int> &numbers)\n{\n    int size = numbers.size();\n    int first_min = numbers[0], second_min = numbers[1], last_max = numbers[size - 1], second_last_max = numbers[size - 2];\n\n    for(int index = 1; index < size - 1; index++)\n    {\n        first_min = min(first_min, numbers[index]);\n        second_min = min(second_min, numbers[index + 1]);\n        last_max = max(last_max, numbers[index]);\n        second_last_max = max(second_last_max, numbers[index - 1]);\n    }\n\n    int low = min(min(first_min, last_max), min(second_min, second_last_max));\n    int high = max(max(first_min, last_max), max(second_min, second_last_max));\n\n    return high - low;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint findMinNonExpressibleInteger(vector<int> &sortedNumbers)\n{\n    int minimumNonExpressibleInteger = 1;\n    sort(sortedNumbers.begin(), sortedNumbers.end());\n    for (int i = 0; i < sortedNumbers.size(); ++i)\n    {\n        int currentNumber = sortedNumbers[i];\n        if (currentNumber > minimumNonExpressibleInteger)\n            break;\n        minimumNonExpressibleInteger += currentNumber;\n    }\n    return minimumNonExpressibleInteger;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findMinNonExpressibleInteger(vector<int> &sorted_numbers)\n{\n    int minimum_non_expressible_integer= 1;\n    sort(sorted_numbers.begin(), sorted_numbers.end());\n    for(int current_number : sorted_numbers)\n    {\n        if(current_number > minimum_non_expressible_integer)\n            break;\n        minimum_non_expressible_integer+= current_number;\n    }\n    return minimum_non_expressible_integer;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> solve(vector<int> &sourceArray, vector<int> &targetArray, vector<vector<int>> &queries)\n{\n    vector<int> result;\n    for (int i = 0; i < queries.size(); ++i)\n    {\n        auto &query = queries[i];\n        if (query[0] == 1)\n        {\n            for (int index = query[1]; index <= query[2]; index++)\n            {\n                sourceArray[index] ^= 1;\n            }\n        }\n        else if (query[0] == 2)\n        {\n            for (int index = 0; index < sourceArray.size(); index++)\n            {\n                targetArray[index] += sourceArray[index] * query[1];\n            }\n        }\n        else if (query[0] == 3)\n        {\n            int totalSum = 0;\n            for (int j = 0; j < targetArray.size(); ++j)\n            {\n                totalSum += targetArray[j];\n            }\n            result.push_back(totalSum);\n        }\n    }\n    return result;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> solve(vector<int> &source_array, vector<int> &target_array, vector<vector<int>> &queries)\n{\n    vector<int> result;\n    for(auto &query : queries)\n    {\n        if(query[0] == 1)\n        {\n            for(int index= query[1]; index <= query[2]; index++)\n            {\n                source_array[index]^= 1;\n            }\n        }\n        else if(query[0] == 2)\n        {\n            for(int index= 0; index < source_array.size(); index++)\n            {\n                target_array[index]+= source_array[index] * query[1];\n            }\n        }\n        else if(query[0] == 3)\n        {\n            int total_sum= 0;\n            for(auto number : target_array)\n            {\n                total_sum+= number;\n            }\n            result.push_back(total_sum);\n        }\n    }\n    return result;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> mergeNumbers(vector<vector<int>> &numberList1, vector<vector<int>> &numberList2)\n{\n    map<int, int> mergedMap;\n    vector<vector<int>> mergedResult;\n\n    for (int i = 0; i < numberList1.size(); ++i)\n    {\n        const auto &currentPair = numberList1[i];\n        mergedMap[currentPair[0]] += currentPair[1];\n    }\n\n    for (int i = 0; i < numberList2.size(); ++i)\n    {\n        const auto &currentPair = numberList2[i];\n        mergedMap[currentPair[0]] += currentPair[1];\n    }\n\n    for (const auto &currentPair : mergedMap)\n    {\n        mergedResult.push_back({currentPair.first, currentPair.second});\n    }\n\n    return mergedResult;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> mergeNumbers(vector<vector<int>> &number_list_1, vector<vector<int>> &number_list_2)\n{\n    map<int, int> merged_map;\n    vector<vector<int>> merged_result;\n\n    for(const auto &current_pair : number_list_1)\n    {\n        merged_map[current_pair[0]]+= current_pair[1];\n    }\n\n    for(const auto &current_pair : number_list_2)\n    {\n        merged_map[current_pair[0]]+= current_pair[1];\n    }\n\n    for(const auto &current_pair : merged_map)\n    {\n        merged_result.push_back({current_pair.first, current_pair.second});\n    }\n\n    return merged_result;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint minOperations(int inputNumber)\n{\n    int totalOperations= 0;\n    while(inputNumber)\n    {\n        totalOperations+= inputNumber % 2;\n        inputNumber/= 2;\n    }\n    return totalOperations;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int minOperations(int input_number)\n{\n    int total_operations= 0;\n    while(input_number)\n    {\n        total_operations+= input_number % 2;\n        input_number/= 2;\n    }\n    return total_operations;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int modulo = 1e9 + 7;\n\nint countSquareFreeSubsets(vector<int> &inputNumbers)\n{\n    unordered_map<int, int> frequencyCounter;\n    for (int number : inputNumbers)\n    {\n        frequencyCounter[number]++;\n    }\n\n    vector<vector<long long>> dynamicProgramming(61, vector<long long>(1001));\n    dynamicProgramming[0][0] = 1;\n    int currentIndex = 0;\n    for (auto it = frequencyCounter.begin(); it != frequencyCounter.end(); ++it)\n    {\n        const int number = it->first;\n        const int frequency = it->second;\n        currentIndex++;\n        for (int squareCount = 0; squareCount <= 60; squareCount++)\n        {\n            for (int nonSquareCount = 0; nonSquareCount + frequency <= 1000; nonSquareCount++)\n            {\n                dynamicProgramming[currentIndex][nonSquareCount + frequency] += dynamicProgramming[currentIndex - 1][nonSquareCount] * ((1LL << frequency) - 1) % modulo;\n                dynamicProgramming[currentIndex][nonSquareCount + frequency] %= modulo;\n                dynamicProgramming[currentIndex][nonSquareCount] += dynamicProgramming[currentIndex - 1][nonSquareCount];\n                dynamicProgramming[currentIndex][nonSquareCount] %= modulo;\n\n                if ((squareCount / number) % 2 == 1)\n                {\n                    dynamicProgramming[currentIndex][nonSquareCount + frequency] -= dynamicProgramming[currentIndex - 1][nonSquareCount] * ((1LL << (frequency - 1)) - 1) % modulo;\n                    if (dynamicProgramming[currentIndex][nonSquareCount + frequency] < 0)\n                        dynamicProgramming[currentIndex][nonSquareCount + frequency] += modulo;\n                }\n            }\n        }\n    }\n    return dynamicProgramming[currentIndex][0];\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int modulo= 1e9 + 7;\n\nint countSquareFreeSubsets(vector<int> &input_numbers)\n{\n    unordered_map<int, int> frequency_counter;\n    for(int number : input_numbers)\n    {\n        frequency_counter[number]++;\n    }\n\n    vector<vector<long long>> dynamic_programming(61, vector<long long>(1001));\n    dynamic_programming[0][0]= 1;\n    int current_index= 0;\n    for(const auto &[number, frequency] : frequency_counter)\n    {\n        current_index++;\n        for(int square_count= 0; square_count <= 60; square_count++)\n        {\n            for(int non_square_count= 0; non_square_count + frequency <= 1000; non_square_count++)\n            {\n                dynamic_programming[current_index][non_square_count + frequency]+= dynamic_programming[current_index - 1][non_square_count] * ((1LL << frequency) - 1) % modulo;\n                dynamic_programming[current_index][non_square_count + frequency]%= modulo;\n                dynamic_programming[current_index][non_square_count]+= dynamic_programming[current_index - 1][non_square_count];\n                dynamic_programming[current_index][non_square_count]%= modulo;\n\n                if((square_count / number) % 2 == 1)\n                {\n                    dynamic_programming[current_index][non_square_count + frequency]-= dynamic_programming[current_index - 1][non_square_count] * ((1LL << (frequency - 1)) - 1) % modulo;\n                    if(dynamic_programming[current_index][non_square_count + frequency] < 0)\n                        dynamic_programming[current_index][non_square_count + frequency]+= modulo;\n                }\n            }\n        }\n    }\n    return dynamic_programming[current_index][0];\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring smallestWordForLCP(vector<vector<int>> &longestCommonPrefix)\n{\n    int matrixSize = longestCommonPrefix.size();\n    string resultWord(matrixSize, 'a');\n    for(int rowIndex = 1; rowIndex < matrixSize; ++rowIndex)\n        for(int colIndex = 1; colIndex < matrixSize; ++colIndex)\n        {\n            if(longestCommonPrefix[rowIndex][colIndex] > min(longestCommonPrefix[rowIndex - 1][colIndex], longestCommonPrefix[rowIndex][colIndex - 1]))\n            {\n                resultWord[rowIndex + longestCommonPrefix[rowIndex][colIndex] - 1] = max(resultWord[rowIndex + longestCommonPrefix[rowIndex][colIndex] - 1], (char)(resultWord[rowIndex - 1] + 1));\n            }\n            else if(longestCommonPrefix[rowIndex][colIndex] < min(longestCommonPrefix[rowIndex - 1][colIndex], longestCommonPrefix[rowIndex][colIndex - 1]))\n            {\n                return \"\";\n            }\n        }\n    return resultWord;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring smallestWordForLCP(vector<vector<int>> &longest_common_prefix)\n{\n    int matrix_size = longest_common_prefix.size();\n    string result_word(matrix_size, 'a');\n    for(int row_index = 1; row_index < matrix_size; ++row_index)\n        for(int col_index = 1; col_index < matrix_size; ++col_index)\n        {\n            if(longest_common_prefix[row_index][col_index] > min(longest_common_prefix[row_index - 1][col_index], longest_common_prefix[row_index][col_index - 1]))\n            {\n                result_word[row_index + longest_common_prefix[row_index][col_index] - 1] = max(result_word[row_index + longest_common_prefix[row_index][col_index] - 1], (char)(result_word[row_index - 1] + 1));\n            }\n            else if(longest_common_prefix[row_index][col_index] < min(longest_common_prefix[row_index - 1][col_index], longest_common_prefix[row_index][col_index - 1]))\n            {\n                return \"\";\n            }\n        }\n    return result_word;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> getAnswer(vector<int> &inputNumbers)\n{\n    int size= inputNumbers.size();\n    vector<int> leftSum(size, 0), rightSum(size, 0), result(size, 0);\n\n    for(int index= 1; index < size; index++)\n    {\n        leftSum[index]= leftSum[index - 1] + inputNumbers[index - 1];\n    }\n\n    for(int index= size - 2; index >= 0; index--)\n    {\n        rightSum[index]= rightSum[index + 1] + inputNumbers[index + 1];\n    }\n\n    for(int index= 0; index < size; index++)\n    {\n        result[index]= abs(leftSum[index] - rightSum[index]);\n    }\n\n    return result;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> getAnswer(vector<int> &input_numbers)\n{\n    int size= input_numbers.size();\n    vector<int> left_sum(size, 0), right_sum(size, 0), result(size, 0);\n\n    for(int index= 1; index < size; index++)\n    {\n        left_sum[index]= left_sum[index - 1] + input_numbers[index - 1];\n    }\n\n    for(int index= size - 2; index >= 0; index--)\n    {\n        right_sum[index]= right_sum[index + 1] + input_numbers[index + 1];\n    }\n\n    for(int index= 0; index < size; index++)\n    {\n        result[index]= abs(left_sum[index] - right_sum[index]);\n    }\n\n    return result;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> divisibilityArray(string numberString, int divisor)\n{\n    vector<int> divisibilityResults(numberString.size());\n    int currentValue= 0;\n    for(size_t index= 0; index < numberString.length(); ++index)\n    {\n        currentValue= (currentValue * 10 + (numberString[index] - '0')) % divisor;\n        divisibilityResults[index]= (currentValue == 0) ? 1 : 0;\n    }\n    return divisibilityResults;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> divisibilityArray(string number_string, int divisor)\n{\n    vector<int> divisibility_results(number_string.size());\n    int current_value= 0;\n    for(size_t index= 0; index < number_string.length(); ++index)\n    {\n        current_value= (current_value * 10 + (number_string[index] - '0')) % divisor;\n        divisibility_results[index]= (current_value == 0) ? 1 : 0;\n    }\n    return divisibility_results;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minTime(vector<vector<int>> &grid)\n{\n    int rows= grid.size(), columns= grid[0].size();\n    vector<vector<int>> visited(rows, vector<int>(columns, 1000000));\n\n    const int directionX[]= {-1, 0, 1, 0};\n    const int directionY[]= {0, 1, 0, -1};\n\n    visited[0][0]= 0;\n\n    queue<pair<int, int>> positionQueue;\n    positionQueue.push({0, 0});\n\n    while(!positionQueue.empty())\n    {\n        auto [currentX, currentY]= positionQueue.front();\n        positionQueue.pop();\n\n        for(int i= 0; i < 4; i++)\n        {\n            int nextX= currentX + directionX[i];\n            int nextY= currentY + directionY[i];\n\n            if(nextX >= 0 && nextX < rows && nextY >= 0 && nextY < columns)\n            {\n                int time= max(grid[nextX][nextY], visited[currentX][currentY] + 1);\n                if(visited[nextX][nextY] > time)\n                {\n                    visited[nextX][nextY]= time;\n                    positionQueue.push({nextX, nextY});\n                }\n            }\n        }\n    }\n\n    return visited[rows - 1][columns - 1] == 1000000 ? -1 : visited[rows - 1][columns - 1];\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minTime(vector<vector<int>> &grid)\n{\n    int rows= grid.size(), columns= grid[0].size();\n    vector<vector<int>> visited(rows, vector<int>(columns, 1000000));\n\n    const int direction_x[]= {-1, 0, 1, 0};\n    const int direction_y[]= {0, 1, 0, -1};\n\n    visited[0][0]= 0;\n\n    queue<pair<int, int>> position_queue;\n    position_queue.push({0, 0});\n\n    while(!position_queue.empty())\n    {\n        auto [current_x, current_y]= position_queue.front();\n        position_queue.pop();\n\n        for(int i= 0; i < 4; i++)\n        {\n            int next_x= current_x + direction_x[i];\n            int next_y= current_y + direction_y[i];\n\n            if(next_x >= 0 && next_x < rows && next_y >= 0 && next_y < columns)\n            {\n                int time= max(grid[next_x][next_y], visited[current_x][current_y] + 1);\n                if(visited[next_x][next_y] > time)\n                {\n                    visited[next_x][next_y]= time;\n                    position_queue.push({next_x, next_y});\n                }\n            }\n        }\n    }\n\n    return visited[rows - 1][columns - 1] == 1000000 ? -1 : visited[rows - 1][columns - 1];\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMinSumOfTwoNumbers(string inputNumber)\n{\n    vector<int> digitCount(10, 0);\n    for (char digit : inputNumber)\n        digitCount[digit - '0']++;\n\n    int firstNumber = 0, secondNumber = 0;\n    for (int i = 1; i <= 9; i += 2)\n    {\n        int count = digitCount[i];\n        while (count--)\n            firstNumber = firstNumber * 10 + i;\n    }\n    for (int i = 0; i <= 9; i += 2)\n    {\n        int count = digitCount[i];\n        while (count--)\n            secondNumber = secondNumber * 10 + i;\n    }\n    return firstNumber + secondNumber;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMinSumOfTwoNumbers(string input_number)\n{\n    vector<int> digit_count(10, 0);\n    for(char digit : input_number)\n        digit_count[digit - '0']++;\n\n    int first_number= 0, second_number= 0;\n    for(int i= 1; i <= 9; i+= 2)\n    {\n        int count= digit_count[i];\n        while(count--)\n            first_number= first_number * 10 + i;\n    }\n    for(int i= 0; i <= 9; i+= 2)\n    {\n        int count= digit_count[i];\n        while(count--)\n            second_number= second_number * 10 + i;\n    }\n    return first_number + second_number;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint calculateColoredCells(int gridSize)\n{\n    return gridSize * gridSize + (gridSize - 1) * (gridSize - 1);\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int calculateColoredCells(int grid_size)\n{\n    return grid_size * grid_size + (grid_size - 1) * (grid_size - 1);\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int modulo = 1e9 + 7;\n\nint totalWaysToSplitRanges(vector<vector<int>> &ranges)\n{\n    sort(ranges.begin(), ranges.end(), [](const vector<int> &firstRange, const vector<int> &secondRange)\n         { return firstRange[1] < secondRange[1]; });\n    int overlappingCount = 0, nonOverlappingCount = 1, previousEnd = -1;\n    for (int i = 0; i < ranges.size(); ++i)\n    {\n        const auto &currentRange = ranges[i];\n        if (currentRange[0] <= previousEnd)\n        {\n            overlappingCount++;\n        }\n        else\n        {\n            nonOverlappingCount++;\n        }\n        previousEnd = max(previousEnd, currentRange[1]);\n    }\n    long result = 1;\n    for (int i = 1; i <= overlappingCount; ++i)\n    {\n        result = (result * 2) % modulo;\n    }\n    return result;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int modulo = 1e9 + 7;\n\nint totalWaysToSplitRanges(vector<vector<int>> &ranges)\n{\n    sort(ranges.begin(), ranges.end(), [](const vector<int> &first_range, const vector<int> &second_range)\n         { return first_range[1] < second_range[1]; });\n    int overlapping_count = 0, non_overlapping_count = 1, previous_end = -1;\n    for (const auto &current_range : ranges)\n    {\n        if (current_range[0] <= previous_end)\n        {\n            overlapping_count++;\n        }\n        else\n        {\n            non_overlapping_count++;\n        }\n        previous_end = max(previous_end, current_range[1]);\n    }\n    long result = 1;\n    for (int i = 1; i <= overlapping_count; ++i)\n    {\n        result = (result * 2) % modulo;\n    }\n    return result;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint possibleRoots(const vector<vector<int>> &edges, const vector<vector<int>> &guesses, int k)\n{\n    int nodeCount = edges.size() + 1;\n    vector<int> inDegree(nodeCount, 0);\n    unordered_set<int> guessParents;\n\n    for (int i = 0; i < guesses.size(); ++i)\n    {\n        guessParents.insert(guesses[i][0]);\n    }\n\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        inDegree[edges[i][1]]++;\n    }\n\n    int possibleRootsCount = 0;\n    for (int i = 0; i < nodeCount; ++i)\n    {\n        if (inDegree[i] == 0)\n        {\n            if (k == 0 || guessParents.find(i) != guessParents.end())\n            {\n                possibleRootsCount++;\n            }\n        }\n        else if (inDegree[i] == 1 && guesses.size() - k < inDegree[i])\n        {\n            possibleRootsCount++;\n        }\n    }\n    return possibleRootsCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint possibleRoots(const vector<vector<int>> &edges, const vector<vector<int>> &guesses, int k)\n{\n    int node_count= edges.size() + 1;\n    vector<int> in_degree(node_count, 0);\n    unordered_set<int> guess_parents;\n\n    for(const auto &guess : guesses)\n    {\n        guess_parents.insert(guess[0]);\n    }\n\n    for(const auto &edge : edges)\n    {\n        in_degree[edge[1]]++;\n    }\n\n    int possible_roots_count= 0;\n    for(int i= 0; i < node_count; ++i)\n    {\n        if(in_degree[i] == 0)\n        {\n            if(k == 0 || guess_parents.find(i) != guess_parents.end())\n            {\n                possible_roots_count++;\n            }\n        }\n        else if(in_degree[i] == 1 && guesses.size() - k < in_degree[i])\n        {\n            possible_roots_count++;\n        }\n    }\n    return possible_roots_count;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint calculatePillowPosition(int numberOfPillows, int time)\n{\n    time%= (2 * numberOfPillows - 2);\n    if(time <= numberOfPillows - 1)\n        return time + 1;\n    else\n        return 2 * numberOfPillows - time - 1;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int calculatePillowPosition(int number_of_pillows, int time)\n{\n    time%= (2 * number_of_pillows - 2);\n    if(time <= number_of_pillows - 1)\n        return time + 1;\n    else\n        return 2 * number_of_pillows - time - 1;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nint kthLargestLevelSum(TreeNode *rootNode, int k)\n{\n    vector<int> levelSums;\n    queue<TreeNode *> nodeQueue;\n    nodeQueue.push(rootNode);\n\n    while(!nodeQueue.empty())\n    {\n        int levelSum= 0;\n        int levelSize= nodeQueue.size();\n        for(int i= 0; i < levelSize; ++i)\n        {\n            TreeNode *currentNode= nodeQueue.front();\n            nodeQueue.pop();\n            levelSum+= currentNode->value;\n\n            if(currentNode->leftChild)\n                nodeQueue.push(currentNode->leftChild);\n            if(currentNode->rightChild)\n                nodeQueue.push(currentNode->rightChild);\n        }\n\n        levelSums.push_back(levelSum);\n    }\n\n    sort(levelSums.begin(), levelSums.end(), greater<int>());\n    return (k > levelSums.size() ? -1 : levelSums[k - 1]);\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n};\n\nint kthLargestLevelSum(TreeNode *root_node, int k)\n{\n    vector<int> level_sums;\n    queue<TreeNode *> node_queue;\n    node_queue.push(root_node);\n\n    while(!node_queue.empty())\n    {\n        int level_sum= 0;\n        int level_size= node_queue.size();\n        for(int i= 0; i < level_size; ++i)\n        {\n            TreeNode *current_node= node_queue.front();\n            node_queue.pop();\n            level_sum+= current_node->value;\n\n            if(current_node->left_child)\n                node_queue.push(current_node->left_child);\n            if(current_node->right_child)\n                node_queue.push(current_node->right_child);\n        }\n\n        level_sums.push_back(level_sum);\n    }\n\n    sort(level_sums.begin(), level_sums.end(), greater<int>());\n    return (k > level_sums.size() ? -1 : level_sums[k - 1]);\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint gcd(int firstNumber, int secondNumber)\n{\n    return secondNumber == 0 ? firstNumber : gcd(secondNumber, firstNumber % secondNumber);\n}\n\nint findValidSplit(const vector<int> &numberList)\n{\n    int length= numberList.size();\n    vector<int> prefixProduct(length);\n    vector<int> suffixProduct(length);\n\n    prefixProduct[0]= numberList[0];\n    suffixProduct[length - 1]= numberList[length - 1];\n\n    for(int index= 1; index < length; ++index)\n        prefixProduct[index]= prefixProduct[index - 1] * numberList[index];\n\n    for(int index= length - 2; index >= 0; --index)\n        suffixProduct[index]= suffixProduct[index + 1] * numberList[index];\n\n    for(int index= 0; index < length - 1; ++index)\n    {\n        if(gcd(prefixProduct[index], suffixProduct[index + 1]) == 1)\n            return index;\n    }\n\n    return -1;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint gcd(int first_number, int second_number)\n{\n    return second_number == 0 ? first_number : gcd(second_number, first_number % second_number);\n}\n\nint findValidSplit(const vector<int> &number_list)\n{\n    int length= number_list.size();\n    vector<int> prefix_product(length);\n    vector<int> suffix_product(length);\n\n    prefix_product[0]= number_list[0];\n    suffix_product[length - 1]= number_list[length - 1];\n\n    for(int index= 1; index < length; ++index)\n        prefix_product[index]= prefix_product[index - 1] * number_list[index];\n\n    for(int index= length - 2; index >= 0; --index)\n        suffix_product[index]= suffix_product[index + 1] * number_list[index];\n\n    for(int index= 0; index < length - 1; ++index)\n    {\n        if(gcd(prefix_product[index], suffix_product[index + 1]) == 1)\n            return index;\n    }\n\n    return -1;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int modulo = 1e9 + 7;\n\nint numberOfWays(int target, vector<vector<int>> &itemTypes)\n{\n    vector<int> dynamicProgramming(target + 1, 0);\n    dynamicProgramming[0] = 1;\n    for (int i = 0; i < itemTypes.size(); ++i)\n    {\n        auto &itemType = itemTypes[i];\n        int itemCount = itemType[0], itemMarks = itemType[1];\n        vector<int> tempDynamicProgramming(target + 1, 0);\n        for (int currentScore = 0; currentScore <= target; ++currentScore)\n        {\n            for (int itemUsed = 0; itemUsed <= itemCount && itemUsed * itemMarks + currentScore <= target; ++itemUsed)\n            {\n                tempDynamicProgramming[currentScore + itemUsed * itemMarks] = (tempDynamicProgramming[currentScore + itemUsed * itemMarks] + dynamicProgramming[currentScore]) % modulo;\n            }\n        }\n        dynamicProgramming = tempDynamicProgramming;\n    }\n    return dynamicProgramming[target];\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int modulo= 1e9 + 7;\n\nint numberOfWays(int target, vector<vector<int>> &item_types)\n{\n    vector<int> dynamic_programming(target + 1, 0);\n    dynamic_programming[0]= 1;\n    for(auto &item_type : item_types)\n    {\n        int item_count= item_type[0], item_marks= item_type[1];\n        vector<int> temp_dynamic_programming(target + 1, 0);\n        for(int current_score= 0; current_score <= target; ++current_score)\n        {\n            for(int item_used= 0; item_used <= item_count && item_used * item_marks + current_score <= target; ++item_used)\n            {\n                temp_dynamic_programming[current_score + item_used * item_marks]= (temp_dynamic_programming[current_score + item_used * item_marks] + dynamic_programming[current_score]) % modulo;\n            }\n        }\n        dynamic_programming= temp_dynamic_programming;\n    }\n    return dynamic_programming[target];\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isVowel(char character)\n{\n    return character == 'a' || character == 'e' || character == 'i' || character == 'o' || character == 'u';\n}\n\nint countVowelStrings(vector<string> &words, int leftIndex, int rightIndex)\n{\n    int vowelCount= 0;\n    for(int index= leftIndex; index <= rightIndex; index++)\n    {\n        if(isVowel(words[index][0]) && isVowel(words[index][words[index].length() - 1]))\n        {\n            vowelCount++;\n        }\n    }\n    return vowelCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isVowel(char character)\n{\n    return character == 'a' || character == 'e' || character == 'i' || character == 'o' || character == 'u';\n}\n\nint countVowelStrings(vector<string> &words, int left_index, int right_index)\n{\n    int vowel_count= 0;\n    for(int index= left_index; index <= right_index; index++)\n    {\n        if(isVowel(words[index][0]) && isVowel(words[index][words[index].length() - 1]))\n        {\n            vowel_count++;\n        }\n    }\n    return vowel_count;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxScore(vector<int> &scores)\n{\n    sort(scores.begin(), scores.end());\n    int count= 0, totalPrefixSum= 0;\n    for(int index= 0; index < scores.size(); ++index)\n    {\n        if(totalPrefixSum + scores[index] > 0)\n        {\n            ++count;\n            totalPrefixSum+= scores[index];\n        }\n    }\n    return count;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxScore(vector<int> &scores)\n{\n    sort(scores.begin(), scores.end());\n    int count= 0, total_prefix_sum= 0;\n    for(int index= 0; index < scores.size(); ++index)\n    {\n        if(total_prefix_sum + scores[index] > 0)\n        {\n            ++count;\n            total_prefix_sum+= scores[index];\n        }\n    }\n    return count;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countBeautifulSubarrays(vector<int> &inputNumbers)\n{\n    vector<int> oddCount(20, 0);\n    vector<int> evenCount(20, 0);\n    evenCount[0] = 1;\n\n    for (int i = 0; i < inputNumbers.size(); ++i)\n    {\n        int currentNumber = inputNumbers[i];\n        bool isOdd = __builtin_parity(currentNumber);\n        for (int j = 19; j >= 0; j--)\n        {\n            int bitMask = 1 << j;\n            if (currentNumber & bitMask)\n            {\n                if (isOdd)\n                    swap(oddCount[j], evenCount[j]);\n                oddCount[j]++;\n            }\n            else\n            {\n                if (!isOdd)\n                    swap(oddCount[j], evenCount[j]);\n                evenCount[j]++;\n            }\n            currentNumber -= (currentNumber & bitMask);\n        }\n    }\n\n    long long result = 0;\n    for (int i = 0; i < 20; i++)\n        result += (long long)evenCount[i] * (evenCount[i] - 1) / 2;\n    return result;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countBeautifulSubarrays(vector<int> &input_numbers)\n{\n    vector<int> odd_count(20, 0);\n    vector<int> even_count(20, 0);\n    even_count[0]= 1;\n\n    for(int current_number : input_numbers)\n    {\n        bool is_odd= __builtin_parity(current_number);\n        for(int i= 19; i >= 0; i--)\n        {\n            int bit_mask= 1 << i;\n            if(current_number & bit_mask)\n            {\n                if(is_odd)\n                    swap(odd_count[i], even_count[i]);\n                odd_count[i]++;\n            }\n            else\n            {\n                if(!is_odd)\n                    swap(odd_count[i], even_count[i]);\n                even_count[i]++;\n            }\n            current_number-= (current_number & bit_mask);\n        }\n    }\n\n    long long result= 0;\n    for(int i= 0; i < 20; i++)\n        result+= (long long)even_count[i] * (even_count[i] - 1) / 2;\n    return result;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minTimeOn(vector<vector<int>> &taskList)\n{\n    vector<vector<int>> timeIntervals;\n    for (int i = 0; i < taskList.size(); ++i)\n    {\n        const auto &task = taskList[i];\n        timeIntervals.push_back({task[1] + 1, task[2]});\n    }\n    sort(timeIntervals.begin(), timeIntervals.end());\n\n    vector<int> dynamicProgramming(2001, 0);\n    for (int i = 0; i < timeIntervals.size(); ++i)\n    {\n        const auto &interval = timeIntervals[i];\n        for (int time = 2000; time >= interval[0]; --time)\n        {\n            dynamicProgramming[time] = max(dynamicProgramming[time], dynamicProgramming[time - interval[1]] + interval[1]);\n        }\n    }\n    return dynamicProgramming.back();\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minTimeOn(vector<vector<int>> &task_list)\n{\n    vector<vector<int>> time_intervals;\n    for(const auto &task : task_list)\n    {\n        time_intervals.push_back({task[1] + 1, task[2]});\n    }\n    sort(time_intervals.begin(), time_intervals.end());\n\n    vector<int> dynamic_programming(2001, 0);\n    for(const auto &interval : time_intervals)\n    {\n        for(int time= 2000; time >= interval[0]; --time)\n        {\n            dynamic_programming[time]= max(dynamic_programming[time], dynamic_programming[time - interval[1]] + interval[1]);\n        }\n    }\n    return dynamic_programming.back();\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nclass TodoList\n{\n  public:\n    struct Task\n    {\n        int id;\n        string description;\n        int dueDate;\n        vector<string> tags;\n        bool isCompleted;\n\n        Task(int taskId, const string &taskDesc, int taskDueDate, const vector<string> &taskTags)\n            : id(taskId), description(taskDesc), dueDate(taskDueDate), tags(taskTags), isCompleted(false) {}\n    };\n\n    TodoList() : taskId(1) {}\n\n    int addTask(int userId, string taskDescription, int dueDate, vector<string> tags)\n    {\n        tasks[userId].emplace_back(taskId, taskDescription, dueDate, tags);\n        return taskId++;\n    }\n\n    vector<string> getAllTasks(int userId)\n    {\n        vector<string> result;\n        vector<Task> &userTasks = tasks[userId];\n\n        sort(userTasks.begin(), userTasks.end(), [](const Task &a, const Task &b)\n             { return a.dueDate < b.dueDate; });\n\n        for (size_t i = 0; i < userTasks.size(); ++i)\n        {\n            const auto &task = userTasks[i];\n            if (!task.isCompleted)\n            {\n                result.push_back(task.description);\n            }\n        }\n\n        return result;\n    }\n\n    vector<string> getTasksForTag(int userId, string tag)\n    {\n        vector<string> result;\n        vector<Task> &userTasks = tasks[userId];\n\n        sort(userTasks.begin(), userTasks.end(), [](const Task &a, const Task &b)\n             { return a.dueDate < b.dueDate; });\n\n        for (size_t i = 0; i < userTasks.size(); ++i)\n        {\n            const auto &task = userTasks[i];\n            if (!task.isCompleted && find(task.tags.begin(), task.tags.end(), tag) != task.tags.end())\n            {\n                result.push_back(task.description);\n            }\n        }\n\n        return result;\n    }\n\n    void completeTask(int userId, int taskId)\n    {\n        vector<Task> &userTasks = tasks[userId];\n        for (size_t i = 0; i < userTasks.size(); ++i)\n        {\n            auto &task = userTasks[i];\n            if (task.id == taskId)\n            {\n                task.isCompleted = true;\n                break;\n            }\n        }\n    }\n\n  private:\n    int taskId;\n    map<int, vector<Task>> tasks;\n};### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass TodoList\n{\n  public:\n    struct Task\n    {\n        int id;\n        string description;\n        int due_date;\n        vector<string> tags;\n        bool is_completed;\n\n        Task(int task_id, const string &task_desc, int task_due_date, const vector<string> &task_tags)\n            : id(task_id), description(task_desc), due_date(task_due_date), tags(task_tags), is_completed(false) {}\n    };\n\n    TodoList() : task_id(1) {}\n\n    int addTask(int user_id, string task_description, int due_date, vector<string> tags)\n    {\n        tasks[user_id].emplace_back(task_id, task_description, due_date, tags);\n        return task_id++;\n    }\n\n    vector<string> getAllTasks(int user_id)\n    {\n\n        vector<string> result;\n        vector<Task> &user_tasks= tasks[user_id];\n\n        sort(user_tasks.begin(), user_tasks.end(), [](const Task &a, const Task &b)\n             { return a.due_date < b.due_date; });\n\n        for(const auto &task : user_tasks)\n        {\n            if(!task.is_completed)\n            {\n                result.push_back(task.description);\n            }\n        }\n\n        return result;\n    }\n\n    vector<string> getTasksForTag(int user_id, string tag)\n    {\n        vector<string> result;\n        vector<Task> &user_tasks= tasks[user_id];\n\n        sort(user_tasks.begin(), user_tasks.end(), [](const Task &a, const Task &b)\n             { return a.due_date < b.due_date; });\n\n        for(const auto &task : user_tasks)\n        {\n            if(!task.is_completed && find(task.tags.begin(), task.tags.end(), tag) != task.tags.end())\n            {\n                result.push_back(task.description);\n            }\n        }\n\n        return result;\n    }\n\n    void completeTask(int user_id, int task_id)\n    {\n        vector<Task> &user_tasks= tasks[user_id];\n        for(auto &task : user_tasks)\n        {\n            if(task.id == task_id)\n            {\n                task.is_completed= true;\n                break;\n            }\n        }\n    }\n\n  private:\n    int task_id;\n    map<int, vector<Task>> tasks;\n};"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint maximumChildrenWithEightDollars(int totalMoney, int totalChildren)\n{\n    if(totalMoney < totalChildren * 1 || totalMoney > totalChildren * 8)\n        return -1;\n    int maxEights= (totalMoney - totalChildren) / 7;\n    return maxEights >= totalChildren ? totalChildren : maxEights;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int maximumChildrenWithEightDollars(int total_money, int total_children)\n{\n    if(total_money < total_children * 1 || total_money > total_children * 8)\n        return -1;\n    int max_eights= (total_money - total_children) / 7;\n    return max_eights >= total_children ? total_children : max_eights;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMaxGreatness(vector<int> &numberList)\n{\n    sort(numberList.begin(), numberList.end());\n    int totalGreatness= 0;\n    for(int index= 1; index < numberList.size(); ++index)\n    {\n        if(numberList[index - 1] < numberList[index])\n        {\n            swap(numberList[index - 1], numberList[index]);\n            ++totalGreatness;\n        }\n    }\n    return totalGreatness;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMaxGreatness(vector<int> &number_list)\n{\n    sort(number_list.begin(), number_list.end());\n    int total_greatness= 0;\n    for(int index= 1; index < number_list.size(); ++index)\n    {\n        if(number_list[index - 1] < number_list[index])\n        {\n            swap(number_list[index - 1], number_list[index]);\n            ++total_greatness;\n        }\n    }\n    return total_greatness;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateScore(vector<int> &scoreList)\n{\n    int scoreCount= scoreList.size();\n    vector<int> dp(scoreCount + 2, 0);\n\n    for(int index= 0; index < scoreCount; ++index)\n    {\n        dp[index + 2]= max(dp[index + 1], dp[index] + scoreList[index]);\n    }\n\n    return dp[scoreCount + 1];\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateScore(vector<int> &score_list)\n{\n    int score_count= score_list.size();\n    vector<int> dp(score_count + 2, 0);\n\n    for(int index= 0; index < score_count; ++index)\n    {\n        dp[index + 2]= max(dp[index + 1], dp[index] + score_list[index]);\n    }\n\n    return dp[score_count + 1];\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minTimeToRepair(vector<int> &repairRanks, int totalCars)\n{\n    sort(repairRanks.begin(), repairRanks.end());\n    int lowerBound = 0, upperBound = 100 * totalCars * totalCars;\n    while (lowerBound < upperBound)\n    {\n        int midPoint = lowerBound + (upperBound - lowerBound) / 2;\n        int totalCarsRepaired = 0;\n        for (int i = 0; i < repairRanks.size(); ++i)\n        {\n            int rank = repairRanks[i];\n            int carsRepaired = min(totalCars, midPoint / (rank * rank));\n            totalCarsRepaired += carsRepaired;\n            if (totalCarsRepaired >= totalCars)\n                break;\n        }\n        if (totalCarsRepaired >= totalCars)\n            upperBound = midPoint;\n        else\n            lowerBound = midPoint + 1;\n    }\n    return lowerBound;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minTimeToRepair(vector<int> &repair_ranks, int total_cars)\n{\n    sort(repair_ranks.begin(), repair_ranks.end());\n    int lower_bound= 0, upper_bound= 100 * total_cars * total_cars;\n    while(lower_bound < upper_bound)\n    {\n        int mid_point= lower_bound + (upper_bound - lower_bound) / 2;\n        int total_cars_repaired= 0;\n        for(int rank : repair_ranks)\n        {\n            int cars_repaired= min(total_cars, mid_point / (rank * rank));\n            total_cars_repaired+= cars_repaired;\n            if(total_cars_repaired >= total_cars)\n                break;\n        }\n        if(total_cars_repaired >= total_cars)\n            upper_bound= mid_point;\n        else\n            lower_bound= mid_point + 1;\n    }\n    return lower_bound;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countEvenOddIndices(int inputNumber)\n{\n    vector<int> count(2, 0);\n    int currentIndex= 0;\n    while(inputNumber > 0)\n    {\n        if(inputNumber % 2)\n            count[currentIndex % 2]+= 1;\n        inputNumber/= 2;\n        currentIndex+= 1;\n    }\n    return count;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countEvenOddIndices(int input_number)\n{\n    vector<int> count(2, 0);\n    int current_index = 0;\n    while(input_number > 0)\n    {\n        if(input_number % 2)\n            count[current_index % 2] += 1;\n        input_number /= 2;\n        current_index += 1;\n    }\n    return count;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isValidMove(int currentRow, int currentCol, int nextValue, int gridSize)\n{\n    return (currentRow + 1 < gridSize && currentCol + 2 < gridSize && nextValue == gridSize * (currentRow + 1) + (currentCol + 2)) ||\n           (currentRow + 1 < gridSize && currentCol - 2 >= 0 && nextValue == gridSize * (currentRow + 1) + (currentCol - 2)) ||\n           (currentRow + 2 < gridSize && currentCol + 1 < gridSize && nextValue == gridSize * (currentRow + 2) + (currentCol + 1)) ||\n           (currentRow + 2 < gridSize && currentCol - 1 >= 0 && nextValue == gridSize * (currentRow + 2) + (currentCol - 1));\n}\n\nbool validPath(vector<vector<int>> &grid)\n{\n    int gridSize= grid.size();\n    for(int rowIndex= 0; rowIndex < gridSize; rowIndex++)\n    {\n        for(int colIndex= 0; colIndex < gridSize; colIndex++)\n        {\n            int currentValue= grid[rowIndex][colIndex];\n            if(currentValue != gridSize * gridSize - 1 && !isValidMove(rowIndex, colIndex, currentValue + 1, gridSize))\n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isValidMove(int current_row, int current_col, int next_value, int grid_size)\n{\n    return (current_row + 1 < grid_size && current_col + 2 < grid_size && next_value == grid_size * (current_row + 1) + (current_col + 2)) ||\n           (current_row + 1 < grid_size && current_col - 2 >= 0 && next_value == grid_size * (current_row + 1) + (current_col - 2)) ||\n           (current_row + 2 < grid_size && current_col + 1 < grid_size && next_value == grid_size * (current_row + 2) + (current_col + 1)) ||\n           (current_row + 2 < grid_size && current_col - 1 >= 0 && next_value == grid_size * (current_row + 2) + (current_col - 1));\n}\n\nbool validPath(vector<vector<int>> &grid)\n{\n    int grid_size= grid.size();\n    for(int row_index= 0; row_index < grid_size; row_index++)\n    {\n        for(int col_index= 0; col_index < grid_size; col_index++)\n        {\n            int current_value= grid[row_index][col_index];\n            if(current_value != grid_size * grid_size - 1 && !isValidMove(row_index, col_index, current_value + 1, grid_size))\n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countBeautifulSubsets(vector<int> &numberList, int differenceThreshold)\n{\n    sort(numberList.begin(), numberList.end());\n    int totalCount= 0;\n    vector<int> dynamicProgramming(numberList.size(), 1);\n    for(int currentIndex= 0; currentIndex < numberList.size(); currentIndex++)\n    {\n        for(int previousIndex= 0, leftPointer= 0, rightPointer= -1; previousIndex < currentIndex; previousIndex++)\n        {\n            while(leftPointer < previousIndex && numberList[previousIndex] - numberList[leftPointer] >= differenceThreshold)\n                leftPointer++;\n            while(rightPointer + 1 < previousIndex && numberList[rightPointer + 1] - numberList[previousIndex] < differenceThreshold)\n                rightPointer++;\n            if(leftPointer <= rightPointer)\n                dynamicProgramming[previousIndex]-= dynamicProgramming[leftPointer - 1];\n            dynamicProgramming[previousIndex]+= dynamicProgramming[previousIndex - 1] + 1;\n            totalCount+= dynamicProgramming[previousIndex];\n        }\n    }\n    return totalCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countBeautifulSubsets(vector<int> &number_list, int difference_threshold)\n{\n    sort(number_list.begin(), number_list.end());\n    int total_count= 0;\n    vector<int> dynamic_programming(number_list.size(), 1);\n    for(int current_index= 0; current_index < number_list.size(); current_index++)\n    {\n        for(int previous_index= 0, left_pointer= 0, right_pointer= -1; previous_index < current_index; previous_index++)\n        {\n            while(left_pointer < previous_index && number_list[previous_index] - number_list[left_pointer] >= difference_threshold)\n                left_pointer++;\n            while(right_pointer + 1 < previous_index && number_list[right_pointer + 1] - number_list[previous_index] < difference_threshold)\n                right_pointer++;\n            if(left_pointer <= right_pointer)\n                dynamic_programming[previous_index]-= dynamic_programming[left_pointer - 1];\n            dynamic_programming[previous_index]+= dynamic_programming[previous_index - 1] + 1;\n            total_count+= dynamic_programming[previous_index];\n        }\n    }\n    return total_count;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMaximumMex(vector<int> &numbers, int incrementValue)\n{\n    unordered_set<int> numberSet(numbers.begin(), numbers.end());\n\n    for(int i= 0; i <= 100000; i++)\n    {\n        if(!numberSet.count(i))\n            numberSet.insert(i + incrementValue);\n    }\n\n    int minimumExcludedValue= 0;\n    while(numberSet.count(minimumExcludedValue))\n        minimumExcludedValue++;\n\n    return minimumExcludedValue;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMaximumMex(vector<int> &numbers, int increment_value)\n{\n    unordered_set<int> number_set(numbers.begin(), numbers.end());\n\n    for(int i= 0; i <= 100000; i++)\n    {\n        if(!number_set.count(i))\n            number_set.insert(i + increment_value);\n    }\n\n    int minimum_excluded_value= 0;\n    while(number_set.count(minimum_excluded_value))\n        minimum_excluded_value++;\n\n    return minimum_excluded_value;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &nums)\n{\n    int minimumPrefixSum = 0;\n    int currentPrefixSum = 0;\n    for (int i = 0; i < nums.size(); ++i)\n    {\n        int currentNumber = nums[i];\n        currentPrefixSum += currentNumber;\n        minimumPrefixSum = min(minimumPrefixSum, currentPrefixSum);\n    }\n    return minimumPrefixSum < 0 ? -minimumPrefixSum : 0;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &nums)\n{\n    int minimum_prefix_sum= 0;\n    int current_prefix_sum= 0;\n    for(int current_number : nums)\n    {\n        current_prefix_sum+= current_number;\n        minimum_prefix_sum= min(minimum_prefix_sum, current_prefix_sum);\n    }\n    return minimum_prefix_sum < 0 ? -minimum_prefix_sum : 0;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\nint maxSum(int numberOfOnes, int numberOfZeros, int numberOfNegativeOnes, int limit)\n{\n    int maximumSum= 0;\n    for(int i= 0; i <= limit; ++i)\n    {\n        int onesCount= min(i, numberOfOnes);\n        int negativeOnesCount= min(limit - i, numberOfNegativeOnes);\n        maximumSum= max(maximumSum, onesCount - negativeOnesCount);\n    }\n    return maximumSum;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "int maxSum(int number_of_ones, int number_of_zeros, int number_of_negative_ones, int limit)\n{\n    int maximum_sum= 0;\n    for(int i= 0; i <= limit; ++i)\n    {\n        int ones_count= min(i, number_of_ones);\n        int negative_ones_count= min(limit - i, number_of_negative_ones);\n        maximum_sum= max(maximum_sum, ones_count - negative_ones_count);\n    }\n    return maximum_sum;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool strictlyIncreasingArray(vector<int> &numberArray)\n{\n    for(int currentIndex= 0; currentIndex < numberArray.size() - 1; ++currentIndex)\n    {\n        numberArray[currentIndex]-= currentIndex;\n        if(numberArray[currentIndex] >= numberArray[currentIndex + 1])\n        {\n            return false;\n        }\n    }\n    return true;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool strictlyIncreasingArray(vector<int> &number_array)\n{\n    for(int current_index= 0; current_index < number_array.size() - 1; ++current_index)\n    {\n        number_array[current_index]-= current_index;\n        if(number_array[current_index] >= number_array[current_index + 1])\n        {\n            return false;\n        }\n    }\n    return true;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> minOperations(vector<int> &numbers, vector<int> &queries)\n{\n    vector<int> operationsCount;\n    for (int i = 0; i < queries.size(); ++i)\n    {\n        int query = queries[i];\n        int totalOperations = 0;\n        for (int j = 0; j < numbers.size(); ++j)\n        {\n            int number = numbers[j];\n            totalOperations += abs(number - query);\n        }\n        operationsCount.push_back(totalOperations);\n    }\n    return operationsCount;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> minOperations(vector<int> &numbers, vector<int> &queries)\n{\n    vector<int> operations_count;\n    for(int query : queries)\n    {\n        int total_operations= 0;\n        for(int number : numbers)\n        {\n            total_operations+= abs(number - query);\n        }\n        operations_count.push_back(total_operations);\n    }\n    return operations_count;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\npair<int, int> depthFirstSearch(const vector<vector<int>> &adjacencyList, const vector<int> &coinValues, int currentNode, int parentNode)\n{\n    int totalCoins = coinValues[currentNode], totalDistance = 0;\n    for (int i = 0; i < adjacencyList[currentNode].size(); ++i)\n    {\n        int neighborNode = adjacencyList[currentNode][i];\n        if (neighborNode != parentNode)\n        {\n            auto result = depthFirstSearch(adjacencyList, coinValues, neighborNode, currentNode);\n            totalCoins += result.first;\n            totalDistance += 2 * result.first + result.second;\n        }\n    }\n    return {totalCoins, totalDistance};\n}\n\nint minEdgesToCollectCoins(const vector<int> &coinValues, const vector<vector<int>> &edges)\n{\n    int numberOfNodes = coinValues.size();\n    vector<vector<int>> adjacencyList(numberOfNodes);\n    for (const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n    return depthFirstSearch(adjacencyList, coinValues, 0, -1).second / 2;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\npair<int, int> depthFirstSearch(const vector<vector<int>> &adjacency_list, const vector<int> &coin_values, int current_node, int parent_node)\n{\n    int total_coins= coin_values[current_node], total_distance= 0;\n    for(int neighbor_node : adjacency_list[current_node])\n    {\n        if(neighbor_node != parent_node)\n        {\n            auto result= depthFirstSearch(adjacency_list, coin_values, neighbor_node, current_node);\n            total_coins+= result.first;\n            total_distance+= 2 * result.first + result.second;\n        }\n    }\n    return {total_coins, total_distance};\n}\n\nint minEdgesToCollectCoins(const vector<int> &coin_values, const vector<vector<int>> &edges)\n{\n    int number_of_nodes= coin_values.size();\n    vector<vector<int>> adjacency_list(number_of_nodes);\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n    return depthFirstSearch(adjacency_list, coin_values, 0, -1).second / 2;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minTimeToEatGrains(vector<int> &hens, vector<int> &grains)\n{\n    sort(hens.begin(), hens.end());\n    sort(grains.begin(), grains.end());\n    int minTime = 0, maxTime = 1e9;\n\n    while (minTime < maxTime)\n    {\n        int midTime = minTime + (maxTime - minTime) / 2;\n        bool canEat = true;\n        int henIndex = 0;\n\n        for (int j = 0; j < grains.size(); ++j)\n        {\n            int grain = grains[j];\n\n            if (henIndex >= hens.size())\n            {\n                canEat = false;\n                break;\n            }\n\n            while (henIndex < hens.size() && hens[henIndex] < grain - midTime)\n            {\n                ++henIndex;\n            }\n\n            if (henIndex >= hens.size() || hens[henIndex] > grain + midTime)\n            {\n                canEat = false;\n                break;\n            }\n\n            ++henIndex;\n        }\n\n        if (canEat)\n        {\n            maxTime = midTime;\n        }\n        else\n        {\n            minTime = midTime + 1;\n        }\n    }\n\n    return minTime;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minTimeToEatGrains(vector<int> &hens, vector<int> &grains)\n{\n    sort(hens.begin(), hens.end());\n    sort(grains.begin(), grains.end());\n    int min_time= 0, max_time= 1e9;\n\n    while(min_time < max_time)\n    {\n        int mid_time= min_time + (max_time - min_time) / 2;\n        bool can_eat= true;\n        int hen_index= 0;\n\n        for(int grain : grains)\n        {\n            if(hen_index >= hens.size())\n            {\n                can_eat= false;\n                break;\n            }\n\n            while(hen_index < hens.size() && hens[hen_index] < grain - mid_time)\n            {\n                ++hen_index;\n            }\n\n            if(hen_index >= hens.size() || hens[hen_index] > grain + mid_time)\n            {\n                can_eat= false;\n                break;\n            }\n\n            ++hen_index;\n        }\n\n        if(can_eat)\n        {\n            max_time= mid_time;\n        }\n        else\n        {\n            min_time= mid_time + 1;\n        }\n    }\n\n    return min_time;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint findSmallestNumberWithAtLeastOneDigitFromEachArray(vector<int> &firstArray, vector<int> &secondArray)\n{\n    int minFirstArray = *min_element(firstArray.begin(), firstArray.end());\n    int minSecondArray = *min_element(secondArray.begin(), secondArray.end());\n    for (int i = 0; i < firstArray.size(); ++i)\n    {\n        int numberFromFirstArray = firstArray[i];\n        for (int j = 0; j < secondArray.size(); ++j)\n        {\n            int numberFromSecondArray = secondArray[j];\n            if (numberFromFirstArray == numberFromSecondArray)\n            {\n                return numberFromFirstArray;\n            }\n        }\n    }\n    return minFirstArray * 10 + minSecondArray;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findSmallestNumberWithAtLeastOneDigitFromEachArray(vector<int> &first_array, vector<int> &second_array)\n{\n    int min_first_array= *min_element(first_array.begin(), first_array.end());\n    int min_second_array= *min_element(second_array.begin(), second_array.end());\n    for(int number_from_first_array : first_array)\n    {\n        for(int number_from_second_array : second_array)\n        {\n            if(number_from_first_array == number_from_second_array)\n            {\n                return number_from_first_array;\n            }\n        }\n    }\n    return min_first_array * 10 + min_second_array;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxValueSubstring(string inputString, string charList, vector<int> values)\n{\n    unordered_map<char, int> charValues;\n\n    for(int index = 0; index < charList.length(); index++)\n    {\n        charValues[charList[index]] = values[index];\n    }\n\n    int maxCost = 0;\n    int currentCost = 0;\n\n    for (int i = 0; i < inputString.length(); ++i)\n    {\n        char currentChar = inputString[i];\n        int charValue = charValues.count(currentChar) ? charValues[currentChar] : static_cast<int>(currentChar - 'a' + 1);\n\n        currentCost = max(0, currentCost + charValue);\n        maxCost = max(maxCost, currentCost);\n    }\n\n    return maxCost;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxValueSubstring(string input_string, string char_list, vector<int> values)\n{\n    unordered_map<char, int> char_values;\n\n    for(int index= 0; index < char_list.length(); index++)\n    {\n        char_values[char_list[index]] = values[index];\n    }\n\n    int max_cost = 0;\n    int current_cost = 0;\n\n    for(char current_char : input_string)\n    {\n        int char_value = char_values.count(current_char) ? char_values[current_char] : static_cast<int>(current_char - 'a' + 1);\n\n        current_cost = max(0, current_cost + char_value);\n        max_cost = max(max_cost, current_cost);\n    }\n\n    return max_cost;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &array, int subarraySize)\n{\n    int arraySize= array.size(), minimumCost= INT_MAX;\n    vector<int> prefixSum(arraySize + 1);\n\n    for(int index= 1; index <= arraySize; index++)\n    {\n        prefixSum[index]= prefixSum[index - 1] + array[index - 1];\n    }\n\n    for(int startIndex= 1; startIndex <= arraySize - subarraySize + 1; startIndex++)\n    {\n        int targetValue= (prefixSum[startIndex - 1] + prefixSum[arraySize] - prefixSum[startIndex + subarraySize - 1] + arraySize / subarraySize - 1) / (arraySize / subarraySize);\n        int currentCost= 0;\n        for(int elementIndex= startIndex; elementIndex < startIndex + subarraySize; elementIndex++)\n        {\n            currentCost+= abs(array[elementIndex - 1] - targetValue);\n        }\n        minimumCost= min(minimumCost, currentCost);\n    }\n    return minimumCost;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &array, int subarray_size)\n{\n    int array_size= array.size(), minimum_cost= INT_MAX;\n    vector<int> prefix_sum(array_size + 1);\n\n    for(int index= 1; index <= array_size; index++)\n    {\n        prefix_sum[index]= prefix_sum[index - 1] + array[index - 1];\n    }\n\n    for(int start_index= 1; start_index <= array_size - subarray_size + 1; start_index++)\n    {\n        int target_value= (prefix_sum[start_index - 1] + prefix_sum[array_size] - prefix_sum[start_index + subarray_size - 1] + array_size / subarray_size - 1) / (array_size / subarray_size);\n        int current_cost= 0;\n        for(int element_index= start_index; element_index < start_index + subarray_size; element_index++)\n        {\n            current_cost+= abs(array[element_index - 1] - target_value);\n        }\n        minimum_cost= min(minimum_cost, current_cost);\n    }\n    return minimum_cost;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestCycleLength(int nodeCount, vector<vector<int>> &edges)\n{\n    vector<vector<int>> adjacencyList(nodeCount);\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        const vector<int> &edge = edges[i];\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    int minimumCycleLength = nodeCount + 1;\n    for (int startNode = 0; startNode < nodeCount; ++startNode)\n    {\n        vector<int> distance(nodeCount, nodeCount + 1);\n        distance[startNode] = 0;\n        queue<int> nodeQueue;\n        nodeQueue.push(startNode);\n\n        while (!nodeQueue.empty())\n        {\n            int currentNode = nodeQueue.front();\n            nodeQueue.pop();\n            for (int j = 0; j < adjacencyList[currentNode].size(); ++j)\n            {\n                int neighbor = adjacencyList[currentNode][j];\n                if (distance[neighbor] == nodeCount + 1)\n                {\n                    distance[neighbor] = distance[currentNode] + 1;\n                    nodeQueue.push(neighbor);\n                }\n                else if (distance[neighbor] >= distance[currentNode] - 1)\n                {\n                    minimumCycleLength = min(minimumCycleLength, distance[currentNode] + distance[neighbor] + 1);\n                }\n            }\n        }\n    }\n\n    return minimumCycleLength == nodeCount + 1 ? -1 : minimumCycleLength;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestCycleLength(int node_count, vector<vector<int>> &edges)\n{\n    vector<vector<int>> adjacency_list(node_count);\n    for(const vector<int> &edge : edges)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    int minimum_cycle_length= node_count + 1;\n    for(int start_node= 0; start_node < node_count; ++start_node)\n    {\n        vector<int> distance(node_count, node_count + 1);\n        distance[start_node]= 0;\n        queue<int> node_queue;\n        node_queue.push(start_node);\n\n        while(!node_queue.empty())\n        {\n            int current_node= node_queue.front();\n            node_queue.pop();\n            for(int neighbor : adjacency_list[current_node])\n            {\n                if(distance[neighbor] == node_count + 1)\n                {\n                    distance[neighbor]= distance[current_node] + 1;\n                    node_queue.push(neighbor);\n                }\n                else if(distance[neighbor] >= distance[current_node] - 1)\n                {\n                    minimum_cycle_length= min(minimum_cycle_length, distance[current_node] + distance[neighbor] + 1);\n                }\n            }\n        }\n    }\n\n    return minimum_cycle_length == node_count + 1 ? -1 : minimum_cycle_length;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint longestBalancedSubstring(string binaryString)\n{\n    int maxLength= 0;\n    int zeroCount= 0;\n    int oneCount= 0;\n\n    for(int index= 0; index < binaryString.size(); ++index)\n    {\n        if(binaryString[index] == '0')\n        {\n            zeroCount++;\n        }\n        else\n        {\n            oneCount++;\n        }\n        if(zeroCount == oneCount)\n        {\n            maxLength= max(maxLength, zeroCount * 2);\n        }\n        else if(zeroCount > oneCount)\n        {\n            zeroCount= oneCount= 0;\n        }\n    }\n\n    zeroCount= oneCount= 0;\n    for(int index= binaryString.size() - 1; index >= 0; --index)\n    {\n        if(binaryString[index] == '0')\n        {\n            zeroCount++;\n        }\n        else\n        {\n            oneCount++;\n        }\n        if(zeroCount == oneCount)\n        {\n            maxLength= max(maxLength, zeroCount * 2);\n        }\n        else if(zeroCount < oneCount)\n        {\n            zeroCount= oneCount= 0;\n        }\n    }\n\n    return maxLength;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint longestBalancedSubstring(string binary_string)\n{\n    int max_length= 0;\n    int zero_count= 0;\n    int one_count= 0;\n\n    for(int index= 0; index < binary_string.size(); ++index)\n    {\n        if(binary_string[index] == '0')\n        {\n            zero_count++;\n        }\n        else\n        {\n            one_count++;\n        }\n        if(zero_count == one_count)\n        {\n            max_length= max(max_length, zero_count * 2);\n        }\n        else if(zero_count > one_count)\n        {\n            zero_count= one_count= 0;\n        }\n    }\n\n    zero_count= one_count= 0;\n    for(int index= binary_string.size() - 1; index >= 0; --index)\n    {\n        if(binary_string[index] == '0')\n        {\n            zero_count++;\n        }\n        else\n        {\n            one_count++;\n        }\n        if(zero_count == one_count)\n        {\n            max_length= max(max_length, zero_count * 2);\n        }\n        else if(zero_count < one_count)\n        {\n            zero_count= one_count= 0;\n        }\n    }\n\n    return max_length;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> distinctRowsFrom(vector<int> &inputNumbers)\n{\n    vector<unordered_set<int>> uniqueRows;\n\n    for (int i = 0; i < inputNumbers.size(); ++i)\n    {\n        int currentNumber = inputNumbers[i];\n        bool isInserted = false;\n        for (int j = 0; j < uniqueRows.size(); ++j)\n        {\n            auto &row = uniqueRows[j];\n            if (row.find(currentNumber) == row.end())\n            {\n                row.insert(currentNumber);\n                isInserted = true;\n                break;\n            }\n        }\n\n        if (!isInserted)\n            uniqueRows.push_back({currentNumber});\n    }\n\n    vector<vector<int>> result;\n    for (int k = 0; k < uniqueRows.size(); ++k)\n    {\n        auto &row = uniqueRows[k];\n        result.emplace_back(row.begin(), row.end());\n    }\n\n    return result;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> distinctRowsFrom(vector<int> &input_numbers)\n{\n    vector<unordered_set<int>> unique_rows;\n\n    for(int current_number : input_numbers)\n    {\n        bool is_inserted= false;\n        for(auto &row : unique_rows)\n        {\n            if(row.find(current_number) == row.end())\n            {\n                row.insert(current_number);\n                is_inserted= true;\n                break;\n            }\n        }\n\n        if(!is_inserted)\n            unique_rows.push_back({current_number});\n    }\n\n    vector<vector<int>> result;\n    for(auto &row : unique_rows)\n    {\n        result.emplace_back(row.begin(), row.end());\n    }\n\n    return result;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxPoints(const vector<int> &firstMouseRewards, const vector<int> &secondMouseRewards, int k)\n{\n    vector<pair<int, int>> rewardGap(firstMouseRewards.size());\n    for(size_t index= 0; index < firstMouseRewards.size(); ++index)\n    {\n        rewardGap[index]= {secondMouseRewards[index] - firstMouseRewards[index], index};\n    }\n    sort(rewardGap.rbegin(), rewardGap.rend());\n    int totalFirstMousePoints= 0;\n    int totalSecondMousePoints= 0;\n    for(int i= 0; i < k; ++i)\n    {\n        totalFirstMousePoints+= firstMouseRewards[rewardGap[i].second];\n    }\n    for(int i= k; i < firstMouseRewards.size(); ++i)\n    {\n        totalSecondMousePoints+= secondMouseRewards[rewardGap[i].second];\n    }\n    return totalFirstMousePoints + totalSecondMousePoints;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxPoints(const vector<int> &first_mouse_rewards, const vector<int> &second_mouse_rewards, int k)\n{\n    vector<pair<int, int>> reward_gap(first_mouse_rewards.size());\n    for(size_t index= 0; index < first_mouse_rewards.size(); ++index)\n    {\n        reward_gap[index]= {second_mouse_rewards[index] - first_mouse_rewards[index], index};\n    }\n    sort(reward_gap.rbegin(), reward_gap.rend());\n    int total_first_mouse_points= 0;\n    int total_second_mouse_points= 0;\n    for(int i= 0; i < k; ++i)\n    {\n        total_first_mouse_points+= first_mouse_rewards[reward_gap[i].second];\n    }\n    for(int i= k; i < first_mouse_rewards.size(); ++i)\n    {\n        total_second_mouse_points+= second_mouse_rewards[reward_gap[i].second];\n    }\n    return total_first_mouse_points + total_second_mouse_points;\n}"
  },
  {
    "input": "### Instruction ###\nConvert the given Source Code into the Target Style based on the provided Code Examples in Target Style. The resulting code should follow the conventions, formatting, and structure demonstrated in the Target Style examples. Please ensure the functionality of the Source Code remains unchanged.\n### Source Code ###\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> reachPosition(int totalPositions, int targetPosition, vector<int> &bannedPositions, int stepSize)\n{\n    set<int> bannedSet(bannedPositions.begin(), bannedPositions.end());\n    vector<int> result(totalPositions, 0);\n\n    for(int currentPosition= 0; currentPosition < totalPositions; ++currentPosition)\n    {\n        if(bannedSet.find(currentPosition) != bannedSet.end() || currentPosition == targetPosition)\n        {\n            result[currentPosition]= -1;\n            continue;\n        }\n\n        int stepsRequired= 0;\n        int distance= abs(targetPosition - currentPosition) / stepSize;\n        if((abs(targetPosition - currentPosition) % stepSize == 0) && ((distance & 1) == (((totalPositions - 1) & 1) ^ (stepSize & 1))))\n        {\n            stepsRequired= distance;\n        }\n        else\n        {\n            stepsRequired= -1;\n        }\n\n        result[currentPosition]= stepsRequired;\n    }\n\n    result[targetPosition]= 0;\n    return result;\n}### Code Examples in Target Style ###\n## Code Example 1\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxNumberOfCopies(string source_string, string target_string)\n{\n    vector<int> source_counts(26, 0);\n    vector<int> target_counts(26, 0);\n\n    for(char character : source_string)\n        source_counts[character - 'a']++;\n\n    for(char character : target_string)\n        target_counts[character - 'a']++;\n\n    int max_copies = INT32_MAX;\n    for(int index = 0; index < 26; index++)\n    {\n        if(target_counts[index] > 0)\n            max_copies = min(max_copies, source_counts[index] / target_counts[index]);\n    }\n    return max_copies;\n}\n## Code Example 2\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minNumberOfBeansToRemove(const vector<int> &bean_counts)\n{\n    unordered_map<int, int> bean_frequency;\n    for(int bean : bean_counts)\n    {\n        bean_frequency[bean]++;\n    }\n\n    int min_beans_to_remove= bean_counts.size();\n    for(const auto &current_bean : bean_frequency)\n    {\n        int beans_to_remove= 0;\n        for(const auto &other_bean : bean_frequency)\n        {\n            if(other_bean.first != current_bean.first)\n            {\n                beans_to_remove+= other_bean.second * max(0, other_bean.first - current_bean.first);\n            }\n        }\n        min_beans_to_remove= min(min_beans_to_remove, beans_to_remove);\n    }\n\n    return min_beans_to_remove;\n}\n## Code Example 3\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxAndSum(vector<int> &numbers, int num_slots)\n{\n    vector<int> slot(num_slots + 1, 0);\n    for(int number : numbers)\n    {\n        for(int slot_index= num_slots; slot_index > 0; slot_index--)\n        {\n            int new_value= number & slot_index;\n            if(new_value > slot[slot_index])\n                slot[slot_index]= new_value;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n## Code Example 4\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minSteps(string source_string, string target_string)\n{\n    unordered_map<char, int> character_count;\n    for(char current_character : source_string)\n        character_count[current_character]++;\n    for(char current_character : target_string)\n        character_count[current_character]--;\n\n    int total_steps= 0;\n    for(auto &character_pair : character_count)\n    {\n        total_steps+= abs(character_pair.second);\n    }\n\n    return total_steps / 2;\n}\n## Code Example 5\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumTimeForTrips(vector<int> &travel_times, int total_trips)\n{\n    sort(travel_times.begin(), travel_times.end());\n\n    int lower_bound = 0, upper_bound = travel_times.back() * total_trips;\n    while(lower_bound < upper_bound)\n    {\n        int mid_time = lower_bound + (upper_bound - lower_bound) / 2;\n        int completed_trips = 0;\n        for(int travel_time : travel_times)\n        {\n            completed_trips += mid_time / travel_time;\n        }\n        if(completed_trips < total_trips)\n        {\n            lower_bound = mid_time + 1;\n        }\n        else\n        {\n            upper_bound = mid_time;\n        }\n    }\n\n    return lower_bound;\n}\n## Code Example 6\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring repeatLimitedString(string input_string, int repeat_limit)\n{\n    string output_string = \"\";\n    sort(input_string.begin(), input_string.end(), greater<char>());\n\n    for(char current_char : input_string)\n    {\n        size_t char_position = output_string.find(current_char);\n\n        if(char_position == string::npos)\n        {\n            output_string.push_back(current_char);\n        }\n        else\n        {\n            int char_count = 1;\n\n            while(char_position + char_count < output_string.size() && output_string[char_position + char_count] == current_char)\n            {\n                char_count++;\n            }\n\n            if(char_count < repeat_limit)\n            {\n                output_string.insert(char_position + char_count, 1, current_char);\n            }\n        }\n    }\n\n    return output_string;\n}\n## Code Example 7\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countPairs(vector<int> &number_list, int divisor)\n{\n    vector<int> remainder_count(divisor, 0);\n    int pair_count= 0;\n\n    for(int number : number_list)\n    {\n        remainder_count[number % divisor]++;\n    }\n\n    pair_count+= remainder_count[0] * (remainder_count[0] - 1) / 2;\n\n    for(int i= 1; i <= divisor / 2; i++)\n    {\n        if(i != divisor - i)\n        {\n            pair_count+= remainder_count[i] * remainder_count[divisor - i];\n        }\n        else\n        {\n            pair_count+= remainder_count[i] * (remainder_count[i] - 1) / 2;\n        }\n    }\n    return pair_count;\n}\n## Code Example 8\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble calculateTaxAmount(vector<vector<int>> &tax_brackets, int total_income)\n{\n    double total_tax= 0;\n    int previous_upper_limit= 0;\n    for(vector<int> &tax_bracket : tax_brackets)\n    {\n        int upper_limit= tax_bracket[0];\n        double tax_rate= tax_bracket[1] / 100.0;\n        total_tax+= (min(upper_limit, total_income) - previous_upper_limit) * tax_rate;\n        previous_upper_limit= upper_limit;\n        if(total_income <= upper_limit)\n            break;\n    }\n    return total_tax;\n}\n## Code Example 9\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *left_child;\n    TreeNode *right_child;\n    TreeNode() : value(0), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x) : value(x), left_child(NULL), right_child(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), left_child(left), right_child(right) {}\n};\n\nTreeNode *constructTree(vector<vector<int>> &descriptions)\n{\n    unordered_map<int, TreeNode *> node_map;\n    for(const auto &description : descriptions)\n    {\n        node_map[description[0]] = new TreeNode(description[0]);\n        node_map[description[1]] = new TreeNode(description[1]);\n    }\n\n    for(const auto &description : descriptions)\n    {\n        if(description[2])\n            node_map[description[0]]->left_child = node_map[description[1]];\n        else\n            node_map[description[0]]->right_child = node_map[description[1]];\n    }\n\n    return node_map[descriptions.front()[0]];\n}\n## Code Example 10\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getMaxOccurrences(const string &input_text, const string &pattern)\n{\n    int occurrence_count[2]= {0, 0};\n    for(char current_char : input_text)\n    {\n        if(current_char == pattern[1])\n        {\n            occurrence_count[1]+= occurrence_count[0];\n        }\n        else if(current_char == pattern[0])\n        {\n            occurrence_count[0]+= 1;\n        }\n    }\n    return occurrence_count[1];\n}\n## Code Example 11\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numbers)\n{\n    sort(numbers.begin(), numbers.end(), greater<int>());\n    int total_sum= 0, half_sum= 0, operation_count= 0;\n    for(int number : numbers)\n        total_sum+= number;\n    for(int number : numbers)\n    {\n        half_sum+= number;\n        operation_count++;\n        if(half_sum >= (total_sum + 1) / 2)\n            break;\n    }\n    return operation_count;\n}\n## Code Example 12\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countStarsExceptBetweenPipePairs(const string &input_string)\n{\n    int star_count = 0;\n    int pipe_count = 0;\n\n    for(char character : input_string)\n    {\n        if(character == '|')\n        {\n            pipe_count++;\n        }\n        else if(character == '*' && pipe_count % 2 == 0)\n        {\n            star_count++;\n        }\n    }\n\n    return star_count;\n}\n## Code Example 13\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countCollisions(string directions)\n{\n    int collision_count= 0, left_count= 0;\n\n    for(char direction : directions)\n    {\n        if(direction == 'L')\n        {\n            left_count++;\n        }\n        else if(direction == 'R')\n        {\n            collision_count+= left_count;\n        }\n    }\n\n    return collision_count;\n}\n## Code Example 14\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findDistantIndices(vector<int> &numbers, int key_value, int distance)\n{\n    vector<int> distant_indices;\n    for(int current_index= 0; current_index < numbers.size(); ++current_index)\n    {\n        for(int start_index= max(0, current_index - distance); start_index <= min(current_index + distance, static_cast<int>(numbers.size()) - 1); ++start_index)\n        {\n            if(numbers[start_index] == key_value)\n            {\n                distant_indices.push_back(current_index);\n                break;\n            }\n        }\n    }\n    return distant_indices;\n}\n## Code Example 15\n#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestPath(int num_nodes, vector<vector<int>> &edges, int source_1, int source_2, int destination)\n{\n    vector<vector<pair<int, int>>> adjacency_list(num_nodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacency_list[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra= [&](int source)\n    {\n        vector<int> distances(num_nodes, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> priority_queue;\n\n        distances[source]= 0;\n        priority_queue.emplace(0, source);\n\n        while(!priority_queue.empty())\n        {\n            int current_node= priority_queue.top().second;\n            int current_distance= priority_queue.top().first;\n            priority_queue.pop();\n\n            if(current_distance != distances[current_node])\n                continue;\n\n            for(const auto &edge : adjacency_list[current_node])\n            {\n                int neighbor= edge.first;\n                int weight= edge.second;\n\n                if(distances[current_node] + weight < distances[neighbor])\n                {\n                    distances[neighbor]= distances[current_node] + weight;\n                    priority_queue.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    vector<int> source_1_to_all_distances= dijkstra(source_1);\n    vector<int> source_2_to_all_distances= dijkstra(source_2);\n\n    int minimum_weight= INT_MAX;\n    for(const auto &edge : edges)\n    {\n        int u= edge[0];\n        int v= edge[1];\n        int w= edge[2];\n        minimum_weight= min(minimum_weight, source_1_to_all_distances[u] + w + source_2_to_all_distances[v]);\n    }\n\n    return minimum_weight == INT_MAX ? -1 : minimum_weight;\n}\n## Code Example 16\n#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int current_node, int parent_node, vector<int> &node_xor_values, vector<vector<int>> &adjacency_list)\n{\n    int current_xor_value= node_xor_values[current_node];\n    for(int child_node : adjacency_list[current_node])\n    {\n        if(child_node != parent_node)\n        {\n            current_xor_value^= depthFirstSearch(child_node, current_node, node_xor_values, adjacency_list);\n        }\n    }\n    return current_xor_value;\n}\n\nint minimumScore(vector<int> &node_values, vector<vector<int>> &edge_list)\n{\n    int node_count= node_values.size();\n    vector<vector<int>> adjacency_list(node_count);\n\n    for(vector<int> &edge : edge_list)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> node_xor_values(node_count);\n    for(int i= 0; i < node_count; ++i)\n    {\n        node_xor_values[i]= depthFirstSearch(i, -1, node_values, adjacency_list);\n    }\n\n    int minimum_difference= INT_MAX;\n    for(int i= 0; i < node_count; ++i)\n    {\n        for(int j= i + 1; j < node_count; ++j)\n        {\n            int xor_value1= node_xor_values[i];\n            int xor_value2= node_xor_values[j] ^ node_values[i];\n            int xor_value3= node_values[i] ^ node_values[j];\n            int max_xor_value= max({xor_value1, xor_value2, xor_value3});\n            int min_xor_value= min({xor_value1, xor_value2, xor_value3});\n            minimum_difference= min(minimum_difference, max_xor_value - min_xor_value);\n        }\n    }\n\n    return minimum_difference;\n}\n## Code Example 17\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring largestSwap(string number)\n{\n    string even_digits= \"\";\n    string odd_digits= \"\";\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            even_digits.push_back(digit);\n        }\n        else\n        {\n            odd_digits.push_back(digit);\n        }\n    }\n\n    sort(even_digits.rbegin(), even_digits.rend());\n    sort(odd_digits.rbegin(), odd_digits.rend());\n\n    string result= \"\";\n    size_t even_index= 0, odd_index= 0;\n\n    for(char digit : number)\n    {\n        if((digit - '0') % 2 == 0)\n        {\n            result.push_back(even_digits[even_index++]);\n        }\n        else\n        {\n            result.push_back(odd_digits[odd_index++]);\n        }\n    }\n\n    return result;\n}\n\nint largestSwapPermutations(int input_number)\n{\n    string number_string= to_string(input_number);\n    return stoi(largestSwap(number_string));\n}\n## Code Example 18\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxBeauty(vector<int> &flower_counts, int available_new_flowers, int beauty_target, int full_beauty, int partial_beauty)\n{\n    int total_beauty= 0;\n    for(int flower_count : flower_counts)\n        total_beauty+= (flower_count >= beauty_target) ? full_beauty : partial_beauty * flower_count;\n\n    sort(flower_counts.begin(), flower_counts.end());\n\n    for(int i= 0; i < flower_counts.size() && available_new_flowers > 0; ++i)\n    {\n        int flowers_needed= beauty_target - flower_counts[i];\n        if(flowers_needed <= available_new_flowers)\n        {\n            total_beauty+= full_beauty - partial_beauty * flower_counts[i];\n            flower_counts[i]= beauty_target;\n            available_new_flowers-= flowers_needed;\n        }\n    }\n\n    return total_beauty;\n}\n## Code Example 19\n#include <bits/stdc++.h>\nusing namespace std;\n\nint lastPassengerTime(vector<int> &bus_times, vector<int> &passenger_times, int bus_capacity)\n{\n    sort(bus_times.begin(), bus_times.end());\n    sort(passenger_times.begin(), passenger_times.end());\n\n    int last_passenger_index= 0;\n    for(int bus_time : bus_times)\n    {\n        int count= 0;\n        while(last_passenger_index < passenger_times.size() && passenger_times[last_passenger_index] <= bus_time && count < bus_capacity)\n        {\n            count++;\n            last_passenger_index++;\n        }\n    }\n\n    return last_passenger_index == 0 ? bus_times[0] - 1 : passenger_times[last_passenger_index - 1] - 1;\n}\n## Code Example 20\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countPairsLeftovers(vector<int> &number_list)\n{\n    vector<int> count_array(101, 0);\n    int total_pairs= 0, total_leftovers= 0;\n\n    for(int current_number : number_list)\n    {\n        count_array[current_number]++;\n    }\n\n    for(int count : count_array)\n    {\n        total_pairs+= count / 2;\n        total_leftovers+= count % 2;\n    }\n\n    return {total_pairs, total_leftovers};\n}\n## Code Example 21\n#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSumNumbersWithEqualSumOfDigits(vector<int> &numbers)\n{\n    unordered_map<int, int> digit_sum_to_max;\n    int result= -1;\n\n    for(int current_number : numbers)\n    {\n        int sum_of_digits= 0;\n        for(int temp_number= current_number; temp_number; temp_number/= 10)\n        {\n            sum_of_digits+= temp_number % 10;\n        }\n\n        int previous_max= digit_sum_to_max[sum_of_digits];\n        if(previous_max)\n        {\n            result= max(result, current_number + previous_max);\n        }\n        digit_sum_to_max[sum_of_digits]= max(current_number, previous_max);\n    }\n\n    return result;\n}\n### Converted cpp code ###\n",
    "output": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> reachPosition(int total_positions, int target_position, vector<int> &banned_positions, int step_size)\n{\n    set<int> banned_set(banned_positions.begin(), banned_positions.end());\n    vector<int> result(total_positions, 0);\n\n    for(int current_position= 0; current_position < total_positions; ++current_position)\n    {\n        if(banned_set.find(current_position) != banned_set.end() || current_position == target_position)\n        {\n            result[current_position]= -1;\n            continue;\n        }\n\n        int steps_required= 0;\n        int distance= abs(target_position - current_position) / step_size;\n        if((abs(target_position - current_position) % step_size == 0) && ((distance & 1) == (((total_positions - 1) & 1) ^ (step_size & 1))))\n        {\n            steps_required= distance;\n        }\n        else\n        {\n            steps_required= -1;\n        }\n\n        result[current_position]= steps_required;\n    }\n\n    result[target_position]= 0;\n    return result;\n}"
  }
]