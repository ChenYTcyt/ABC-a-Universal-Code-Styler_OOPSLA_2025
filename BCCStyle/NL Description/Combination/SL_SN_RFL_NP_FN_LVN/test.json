[
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring findOddWord(vector<string> &wordList)\n{\n    auto calculateDifferenceArray = [](const string &currentWord)\n    {\n        vector<int> differenceArray;\n        for(size_t index = 1; index < currentWord.size(); index++)\n        {\n            differenceArray.push_back(currentWord[index] - currentWord[index - 1]);\n        }\n        return differenceArray;\n    };\n\n    vector<vector<int>> differenceArrays;\n    for (int i = 0; i < wordList.size(); ++i)\n    {\n        const auto &currentWord = wordList[i];\n        differenceArrays.push_back(calculateDifferenceArray(currentWord));\n    }\n\n    int oddArrayIndex = -1;\n    for (int index = 1; index < differenceArrays.size(); index++)\n    {\n        int matchCount = 0;\n        for (int j = 0; j < differenceArrays[index].size(); j++)\n        {\n            if (differenceArrays[0][j] == differenceArrays[index][j])\n            {\n                matchCount++;\n            }\n        }\n\n        if (matchCount == 0)\n        {\n            oddArrayIndex = index;\n            break;\n        }\n    }\n\n    return wordList[oddArrayIndex];\n}",
    "output": "#include <string>\n#include <vector>\n\nstd::string FindOddWord(std::vector<std::string> &wordList)\n{\n    auto CalculateDifferenceArray= [](const std::string &currentWord)\n    {\n        std::vector<int> difference_array;\n        for(size_t index= 1; index < currentWord.size(); index++)\n        {\n            difference_array.push_back(currentWord[index] - currentWord[index - 1]);\n        }\n        return difference_array;\n    };\n\n    std::vector<std::vector<int>> difference_arrays;\n    for(const auto &currentWord : wordList)\n    {\n        difference_arrays.push_back(CalculateDifferenceArray(currentWord));\n    }\n\n    int odd_array_index= -1;\n    for(int index= 1; index < difference_arrays.size(); index++)\n    {\n        int match_count= 0;\n        for(int j= 0; j < difference_arrays[index].size(); j++)\n        {\n            if(difference_arrays[0][j] == difference_arrays[index][j])\n            {\n                match_count++;\n            }\n        }\n\n        if(match_count == 0)\n        {\n            odd_array_index= index;\n            break;\n        }\n    }\n\n    return wordList[odd_array_index];\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countDifferences(const string &sourceWord, const string &targetWord)\n{\n    int differenceCount = 0;\n    for(int index = 0; index < sourceWord.size(); ++index)\n    {\n        if(sourceWord[index] != targetWord[index])\n        {\n            ++differenceCount;\n        }\n    }\n    return differenceCount;\n}\n\nvector<string> findMatchingWords(const vector<string> &queryWords, const vector<string> &dictionaryWords)\n{\n    vector<string> matchedWords;\n    for (int i = 0; i < queryWords.size(); ++i)\n    {\n        const string &query = queryWords[i];\n        for (int j = 0; j < dictionaryWords.size(); ++j)\n        {\n            const string &dictionaryWord = dictionaryWords[j];\n            if (countDifferences(query, dictionaryWord) <= 2)\n            {\n                matchedWords.push_back(query);\n                break;\n            }\n        }\n    }\n    return matchedWords;\n}",
    "output": "#include <string>\n#include <vector>\n\nint CountDifferences(const std::string &sourceWord, const std::string &targetWord)\n{\n    int difference_count= 0;\n    for(int index= 0; index < sourceWord.size(); ++index)\n    {\n        if(sourceWord[index] != targetWord[index])\n        {\n            ++difference_count;\n        }\n    }\n    return difference_count;\n}\n\nstd::vector<std::string> FindMatchingWords(const std::vector<std::string> &queryWords, const std::vector<std::string> &dictionaryWords)\n{\n    std::vector<std::string> matched_words;\n    for(const std::string &query : queryWords)\n    {\n        for(const std::string &dictionary_word : dictionaryWords)\n        {\n            if(CountDifferences(query, dictionary_word) <= 2)\n            {\n                matched_words.push_back(query);\n                break;\n            }\n        }\n    }\n    return matched_words;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findMinSeededValue(vector<int> &numbers, int space)\n{\n    unordered_map<int, int> remainderCount;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int number = numbers[i];\n        remainderCount[number % space]++;\n    }\n    return max_element(remainderCount.begin(), remainderCount.end(), [](const auto &a, const auto &b)\n                       { return a.second < b.second || (a.second == b.second && a.first > b.first); })\n        ->first;\n}",
    "output": "#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint FindMinSeededValue(std::vector<int> &numbers, int space)\n{\n    std::unordered_map<int, int> remainder_count;\n    for(int number : numbers)\n    {\n        remainder_count[number % space]++;\n    }\n    return std::max_element(remainder_count.begin(), remainder_count.end(), [](const auto &a, const auto &b)\n                       { return a.second < b.second || (a.second == b.second && a.first > b.first); })\n        ->first;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findSecondGreater(const vector<int> &inputNumbers)\n{\n    int totalNumbers= inputNumbers.size();\n    vector<int> result(totalNumbers, -1);\n    for(int currentIndex= 0; currentIndex < totalNumbers; currentIndex++)\n    {\n        for(int nextIndex= currentIndex + 1, secondGreaterIndex= -1; nextIndex < totalNumbers; nextIndex++)\n        {\n            if(inputNumbers[nextIndex] > inputNumbers[currentIndex])\n            {\n                if(secondGreaterIndex == -1)\n                {\n                    secondGreaterIndex= nextIndex;\n                }\n                else\n                {\n                    result[currentIndex]= inputNumbers[nextIndex];\n                    break;\n                }\n            }\n        }\n    }\n    return result;\n}",
    "output": "#include <vector>\n\nstd::vector<int> FindSecondGreater(const std::vector<int> &inputNumbers)\n{\n    int total_numbers = inputNumbers.size();\n    std::vector<int> result(total_numbers, -1);\n    for(int current_index = 0; current_index < total_numbers; current_index++)\n    {\n        for(int next_index = current_index + 1, second_greater_index = -1; next_index < total_numbers; next_index++)\n        {\n            if(inputNumbers[next_index] > inputNumbers[current_index])\n            {\n                if(second_greater_index == -1)\n                {\n                    second_greater_index = next_index;\n                }\n                else\n                {\n                    result[current_index] = inputNumbers[next_index];\n                    break;\n                }\n            }\n        }\n    }\n    return result;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint averageEvenDivisibleByThree(const vector<int> &numbers)\n{\n    int totalSum = 0;\n    int count = 0;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int number = numbers[i];\n        if (number % 2 == 0 && number % 3 == 0)\n        {\n            totalSum += number;\n            count++;\n        }\n    }\n    return count == 0 ? 0 : totalSum / count;\n}",
    "output": "int AverageEvenDivisibleByThree(const std::vector<int> &numbers)\n{\n    int total_sum= 0;\n    int count= 0;\n    for(int number : numbers)\n    {\n        if(number % 2 == 0 && number % 3 == 0)\n        {\n            total_sum+= number;\n            count++;\n        }\n    }\n    return count == 0 ? 0 : total_sum / count;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<string>> getHighestPopularity(vector<string> &creatorNames, vector<string> &videoIds, vector<int> &viewCounts)\n{\n    unordered_map<string, int> creatorPopularity;\n    unordered_map<string, pair<string, int>> mostViewedVideos;\n    for(int index = 0; index < creatorNames.size(); index++)\n    {\n        creatorPopularity[creatorNames[index]] += viewCounts[index];\n        if(!mostViewedVideos.count(creatorNames[index]) || viewCounts[index] > mostViewedVideos[creatorNames[index]].second || (viewCounts[index] == mostViewedVideos[creatorNames[index]].second && videoIds[index] < mostViewedVideos[creatorNames[index]].first))\n        {\n            mostViewedVideos[creatorNames[index]] = {videoIds[index], viewCounts[index]};\n        }\n    }\n\n    int maxPopularity = 0;\n    for(auto it = creatorPopularity.begin(); it != creatorPopularity.end(); ++it)\n    {\n        maxPopularity = max(maxPopularity, it->second);\n    }\n\n    vector<vector<string>> result;\n    for(auto it = creatorPopularity.begin(); it != creatorPopularity.end(); ++it)\n    {\n        if(it->second == maxPopularity)\n        {\n            result.push_back({it->first, mostViewedVideos[it->first].first});\n        }\n    }\n    return result;\n}",
    "output": "#include <string>\n#include <unordered_map>\n#include <vector>\n\nstd::vector<std::vector<std::string>> GetHighestPopularity(std::vector<std::string> &creatorNames, std::vector<std::string> &videoIds, std::vector<int> &viewCounts)\n{\n    std::unordered_map<std::string, int> creator_popularity;\n    std::unordered_map<std::string, std::pair<std::string, int>> most_viewed_videos;\n    for(int index= 0; index < creatorNames.size(); index++)\n    {\n        creator_popularity[creatorNames[index]]+= viewCounts[index];\n        if(!most_viewed_videos.count(creatorNames[index]) || viewCounts[index] > most_viewed_videos[creatorNames[index]].second || (viewCounts[index] == most_viewed_videos[creatorNames[index]].second && videoIds[index] < most_viewed_videos[creatorNames[index]].first))\n        {\n            most_viewed_videos[creatorNames[index]]= {videoIds[index], viewCounts[index]};\n        }\n    }\n\n    int max_popularity= 0;\n    for(auto &[creator, popularity] : creator_popularity)\n    {\n        max_popularity= std::max(max_popularity, popularity);\n    }\n\n    std::vector<std::vector<std::string>> result;\n    for(auto &[creator, popularity] : creator_popularity)\n    {\n        if(popularity == max_popularity)\n        {\n            result.push_back({creator, most_viewed_videos[creator].first});\n        }\n    }\n    return result;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "int digitSum(int number)\n{\n    int totalSum= 0;\n    while(number)\n    {\n        totalSum+= number % 10;\n        number/= 10;\n    }\n    return totalSum;\n}\n\nint minimumBeautiful(int baseNumber, int targetSum)\n{\n    int increment= 0;\n    while(digitSum(baseNumber + increment) > targetSum)\n    {\n        ++increment;\n    }\n    return increment;\n}",
    "output": "int DigitSum(int number)\n{\n    int total_sum= 0;\n    while(number)\n    {\n        total_sum+= number % 10;\n        number/= 10;\n    }\n    return total_sum;\n}\n\nint MinimumBeautiful(int baseNumber, int targetSum)\n{\n    int increment= 0;\n    while(DigitSum(baseNumber + increment) > targetSum)\n    {\n        ++increment;\n    }\n    return increment;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nclass Solution\n{\n  public:\n    vector<int> removeSubtrees(TreeNode *rootNode, vector<int> &queries)\n    {\n        vector<int> answer(queries.size());\n\n        for(int i= 0; i < queries.size(); ++i)\n        {\n            removeSubtree(rootNode, queries[i]);\n            answer[i]= findHeight(rootNode);\n        }\n\n        return answer;\n    }\n\n    void removeSubtree(TreeNode *currentNode, int value)\n    {\n        if(currentNode == NULL)\n            return;\n\n        if(currentNode->leftChild && currentNode->leftChild->value == value)\n            currentNode->leftChild= NULL;\n        else\n            removeSubtree(currentNode->leftChild, value);\n\n        if(currentNode->rightChild && currentNode->rightChild->value == value)\n            currentNode->rightChild= NULL;\n        else\n            removeSubtree(currentNode->rightChild, value);\n    }\n\n    int findHeight(TreeNode *currentNode)\n    {\n        if(currentNode == NULL)\n            return -1;\n\n        return 1 + max(findHeight(currentNode->leftChild), findHeight(currentNode->rightChild));\n    }\n};",
    "output": "#include <vector>\n#include <algorithm>\n\n// Definition for a binary tree node.\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nclass Solution\n{\n  public:\n    std::vector<int> RemoveSubtrees(TreeNode *rootNode, std::vector<int> &queries)\n    {\n        std::vector<int> answer(queries.size());\n\n        for(int i= 0; i < queries.size(); ++i)\n        {\n            RemoveSubtree(rootNode, queries[i]);\n            answer[i]= FindHeight(rootNode);\n        }\n\n        return answer;\n    }\n\n    void RemoveSubtree(TreeNode *currentNode, int value)\n    {\n        if(currentNode == nullptr)\n            return;\n\n        if(currentNode->leftChild && currentNode->leftChild->value == value)\n            currentNode->leftChild= nullptr;\n        else\n            RemoveSubtree(currentNode->leftChild, value);\n\n        if(currentNode->rightChild && currentNode->rightChild->value == value)\n            currentNode->rightChild= nullptr;\n        else\n            RemoveSubtree(currentNode->rightChild, value);\n    }\n\n    int FindHeight(TreeNode *currentNode)\n    {\n        if(currentNode == nullptr)\n            return -1;\n\n        return 1 + std::max(FindHeight(currentNode->leftChild), FindHeight(currentNode->rightChild));\n    }\n};"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numberList)\n{\n    int size= numberList.size();\n    int indexOfZero= -1;\n\n    for(int index= 0; index < size; index++)\n    {\n        if(numberList[index] == 0)\n        {\n            indexOfZero= index;\n            break;\n        }\n    }\n\n    int countIncrements= 0, countDecrements= 0;\n\n    for(int index= 1; index < size; index++)\n    {\n        if(abs(numberList[index] - numberList[index - 1]) != 1)\n        {\n            countIncrements+= abs(numberList[index] - numberList[index - 1]) - 1;\n        }\n    }\n\n    for(int index= indexOfZero + 1; index < size; index++)\n    {\n        if(numberList[index] < numberList[index - 1])\n        {\n            countDecrements++;\n        }\n    }\n\n    return min(countIncrements, countDecrements);\n}",
    "output": "#include <vector>\n#include <cmath> // for abs\n#include <algorithm> // for min\n\nint MinOperations(std::vector<int> &numberList)\n{\n    int size= numberList.size();\n    int index_of_zero= -1;\n\n    for(int index= 0; index < size; index++)\n    {\n        if(numberList[index] == 0)\n        {\n            index_of_zero= index;\n            break;\n        }\n    }\n\n    int count_increments= 0, count_decrements= 0;\n\n    for(int index= 1; index < size; index++)\n    {\n        if(std::abs(numberList[index] - numberList[index - 1]) != 1)\n        {\n            count_increments+= std::abs(numberList[index] - numberList[index - 1]) - 1;\n        }\n    }\n\n    for(int index= index_of_zero + 1; index < size; index++)\n    {\n        if(numberList[index] < numberList[index - 1])\n        {\n            count_decrements++;\n        }\n    }\n\n    return std::min(count_increments, count_decrements);\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> performOps(vector<int> &numberList)\n{\n    int listSize= numberList.size();\n    for(int currentIndex= 0; currentIndex < listSize - 1; ++currentIndex)\n    {\n        if(numberList[currentIndex] == numberList[currentIndex + 1])\n        {\n            numberList[currentIndex]*= 2;\n            numberList[currentIndex + 1]= 0;\n        }\n    }\n    int nonZeroCount= 0;\n    for(int currentIndex= 0; currentIndex < listSize; ++currentIndex)\n    {\n        if(numberList[currentIndex] != 0)\n        {\n            numberList[nonZeroCount++]= numberList[currentIndex];\n        }\n    }\n    while(nonZeroCount < listSize)\n    {\n        numberList[nonZeroCount++]= 0;\n    }\n    return numberList;\n}",
    "output": "#include <vector>\n\nstd::vector<int> PerformOps(std::vector<int> &numberList)\n{\n    int list_size= numberList.size();\n    for(int current_index= 0; current_index < list_size - 1; ++current_index)\n    {\n        if(numberList[current_index] == numberList[current_index + 1])\n        {\n            numberList[current_index]*= 2;\n            numberList[current_index + 1]= 0;\n        }\n    }\n    int non_zero_count= 0;\n    for(int current_index= 0; current_index < list_size; ++current_index)\n    {\n        if(numberList[current_index] != 0)\n        {\n            numberList[non_zero_count++]= numberList[current_index];\n        }\n    }\n    while(non_zero_count < list_size)\n    {\n        numberList[non_zero_count++]= 0;\n    }\n    return numberList;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSubarraySumWithDistinctElements(vector<int> &numbers, int windowSize)\n{\n    int maxSum = 0, currentWindowSum = 0;\n    unordered_map<int, int> frequencyMap;\n\n    for (int index = 0; index < numbers.size(); index++)\n    {\n        frequencyMap[numbers[index]]++;\n        currentWindowSum += numbers[index];\n        if (index >= windowSize)\n        {\n            frequencyMap[numbers[index - windowSize]]--;\n            currentWindowSum -= numbers[index - windowSize];\n        }\n        if (index >= windowSize - 1)\n        {\n            bool isDistinct = true;\n            // Modify the range-based for loop to a traditional for loop\n            for (int i = 0; i < frequencyMap.size(); ++i)\n            {\n                auto it = frequencyMap.begin();\n                advance(it, i);\n                if (it->second > 1)\n                {\n                    isDistinct = false;\n                    break;\n                }\n            }\n            if (isDistinct)\n            {\n                maxSum = max(maxSum, currentWindowSum);\n            }\n        }\n    }\n    return maxSum;\n}",
    "output": "#include <vector>\n#include <unordered_map>\n\nint MaxSubarraySumWithDistinctElements(std::vector<int> &numbers, int windowSize)\n{\n    int max_sum= 0, current_window_sum= 0;\n    std::unordered_map<int, int> frequency_map;\n\n    for(int index= 0; index < numbers.size(); index++)\n    {\n        frequency_map[numbers[index]]++;\n        current_window_sum+= numbers[index];\n        if(index >= windowSize)\n        {\n            frequency_map[numbers[index - windowSize]]--;\n            current_window_sum-= numbers[index - windowSize];\n        }\n        if(index >= windowSize - 1)\n        {\n            bool is_distinct= true;\n            for(const auto &pair : frequency_map)\n            {\n                if(pair.second > 1)\n                {\n                    is_distinct= false;\n                    break;\n                }\n            }\n            if(is_distinct)\n            {\n                max_sum= std::max(max_sum, current_window_sum);\n            }\n        }\n    }\n    return max_sum;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint hireWorkers(vector<int> &workerCosts, int numberOfWorkers, int candidateLimit)\n{\n    int totalCosts= workerCosts.size();\n    vector<pair<int, int>> workers;\n    for(int i= 0; i < totalCosts; ++i)\n        workers.emplace_back(workerCosts[i], i);\n    sort(workers.begin(), workers.end());\n\n    int totalCost= 0;\n    for(int i= 0; i < numberOfWorkers; ++i)\n    {\n        if(min(workers[i].second, totalCosts - workers[i].second - 1) < candidateLimit)\n            totalCost+= workers[i].first;\n    }\n    return totalCost;\n}",
    "output": "#include <vector>\n#include <utility>\n#include <algorithm>\n\nint HireWorkers(std::vector<int> &workerCosts, int numberOfWorkers, int candidateLimit)\n{\n    int total_costs= workerCosts.size();\n    std::vector<std::pair<int, int>> workers;\n    for(int i= 0; i < total_costs; ++i)\n        workers.emplace_back(workerCosts[i], i);\n    std::sort(workers.begin(), workers.end());\n\n    int total_cost= 0;\n    for(int i= 0; i < numberOfWorkers; ++i)\n    {\n        if(std::min(workers[i].second, total_costs - workers[i].second - 1) < candidateLimit)\n            total_cost+= workers[i].first;\n    }\n    return total_cost;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\n// for abs\nusing namespace std;\n\nint calculateMinimumTotalDistance(vector<int> &robotPositions, vector<vector<int>> &factoryLocations)\n{\n    sort(robotPositions.begin(), robotPositions.end());\n    sort(factoryLocations.begin(), factoryLocations.end());\n\n    int totalDistance = 0, robotIndex = 0;\n    for (int i = 0; i < factoryLocations.size(); ++i)\n    {\n        const auto &factory = factoryLocations[i];\n        int availableCapacity = factory[1];\n        while (availableCapacity-- > 0 && robotIndex < robotPositions.size())\n        {\n            totalDistance += abs(factory[0] - robotPositions[robotIndex]);\n            robotIndex++;\n        }\n    }\n\n    return totalDistance;\n}",
    "output": "#include <vector>\n#include <algorithm>\n#include <cstdlib>\n\nint CalculateMinimumTotalDistance(std::vector<int> &robotPositions, std::vector<std::vector<int>> &factoryLocations)\n{\n    std::sort(robotPositions.begin(), robotPositions.end());\n    std::sort(factoryLocations.begin(), factoryLocations.end());\n\n    int total_distance= 0, robot_index= 0;\n    for(const auto &factory : factoryLocations)\n    {\n        int available_capacity= factory[1];\n        while(available_capacity-- > 0 && robot_index < robotPositions.size())\n        {\n            total_distance+= std::abs(factory[0] - robotPositions[robot_index]);\n            robot_index++;\n        }\n    }\n\n    return total_distance;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minValidSubarrays(vector<int> &numberList)\n{\n    int subarrayCount= 0;\n    for(int currentIndex= 0; currentIndex < numberList.size(); currentIndex++)\n    {\n        while(currentIndex < numberList.size() && gcd(numberList[currentIndex], numberList.back()) == 1)\n        {\n            currentIndex++;\n        }\n        if(currentIndex < numberList.size())\n        {\n            subarrayCount++;\n            numberList.pop_back();\n        }\n    }\n    return subarrayCount > 0 ? subarrayCount : -1;\n}",
    "output": "#include <numeric>\nint MinValidSubarrays(vector<int> &numberList)\n{\n    int subarray_count= 0;\n    for(int current_index= 0; current_index < numberList.size(); current_index++)\n    {\n        while(current_index < numberList.size() && std::gcd(numberList[current_index], numberList.back()) == 1)\n        {\n            current_index++;\n        }\n        if(current_index < numberList.size())\n        {\n            subarray_count++;\n            numberList.pop_back();\n        }\n    }\n    return subarray_count > 0 ? subarray_count : -1;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint distinctAverages(vector<int> &numberList)\n{\n    set<double> uniqueAverages;\n    sort(numberList.begin(), numberList.end());\n    int listSize= numberList.size();\n    for(int index= 0; index < listSize / 2; index++)\n    {\n        uniqueAverages.insert((numberList[index] + numberList[listSize - 1 - index]) / 2.0);\n    }\n    return uniqueAverages.size();\n}",
    "output": "#include <vector>\n#include <set>\n#include <algorithm>\n\nint DistinctAverages(std::vector<int> &numberList)\n{\n    std::set<double> unique_averages;\n    std::sort(numberList.begin(), numberList.end());\n    int list_size= numberList.size();\n    for(int index= 0; index < list_size / 2; index++)\n    {\n        unique_averages.insert((numberList[index] + numberList[list_size - 1 - index]) / 2.0);\n    }\n    return unique_averages.size();\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "int modulusPower(long base, int exponent, int modulus)\n{\n    long result= 1;\n    while(exponent > 0)\n    {\n        if(exponent % 2 == 1)\n        {\n            result= (result * base) % modulus;\n        }\n        base= (base * base) % modulus;\n        exponent/= 2;\n    }\n    return (int)result;\n}\n\nint countGoodStrings(int minLength, int maxLength, int zeroCount, int oneCount)\n{\n    long modulus= 1000000007;\n    return (((modulusPower(2, maxLength, modulus) - modulusPower(2, minLength - 1, modulus) + 1) * (zeroCount + 1)) % modulus * (oneCount + 1)) % modulus;\n}",
    "output": "int ModulusPower(long base, int exponent, int modulus)\n{\n    long result= 1;\n    while(exponent > 0)\n    {\n        if(exponent % 2 == 1)\n        {\n            result= (result * base) % modulus;\n        }\n        base= (base * base) % modulus;\n        exponent/= 2;\n    }\n    return (int)result;\n}\n\nint CountGoodStrings(int minLength, int maxLength, int zeroCount, int oneCount)\n{\n    long modulus= 1000000007;\n    return (((ModulusPower(2, maxLength, modulus) - ModulusPower(2, minLength - 1, modulus) + 1) * (zeroCount + 1)) % modulus * (oneCount + 1)) % modulus;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid depthFirstSearch(int currentNode, int parentNode, int bobTime, int currentTime, int &aliceIncome, int &maximumIncome, vector<int> &amounts, unordered_map<int, vector<int>> &tree)\n{\n    if(currentTime < bobTime || amounts[currentNode] >= 0)\n    {\n        aliceIncome += amounts[currentNode];\n    }\n    else\n    {\n        aliceIncome += amounts[currentNode] / 2;\n    }\n    amounts[currentNode] = 0;\n    bool isLeafNode = true;\n    for(int j = 0; j < tree[currentNode].size(); ++j)\n    {\n        int childNode = tree[currentNode][j];\n        if(childNode != parentNode)\n        {\n            isLeafNode = false;\n            int temporaryIncome = aliceIncome;\n            depthFirstSearch(childNode, currentNode, bobTime, currentTime + 1, temporaryIncome, maximumIncome, amounts, tree);\n        }\n    }\n    if(isLeafNode)\n    {\n        maximumIncome = max(maximumIncome, aliceIncome);\n    }\n}\n\nint calculateMaxNetIncome(vector<vector<int>> &edges, int bobTime, vector<int> &amounts)\n{\n    unordered_map<int, vector<int>> tree;\n    for(const auto &edge : edges)\n    {\n        tree[edge[0]].emplace_back(edge[1]);\n        tree[edge[1]].emplace_back(edge[0]);\n    }\n    int maximumIncome = -100000;\n    int aliceIncome = 0;\n    depthFirstSearch(0, -1, bobTime, 0, aliceIncome, maximumIncome, amounts, tree);\n    return maximumIncome;\n}",
    "output": "#include <unordered_map>\n#include <vector>\n\nvoid DepthFirstSearch(int currentNode, int parentNode, int bobTime, int currentTime, int &aliceIncome, int &maximumIncome, std::vector<int> &amounts, std::unordered_map<int, std::vector<int>> &tree)\n{\n    if(currentTime < bobTime || amounts[currentNode] >= 0)\n    {\n        aliceIncome += amounts[currentNode];\n    }\n    else\n    {\n        aliceIncome += amounts[currentNode] / 2;\n    }\n    amounts[currentNode] = 0;\n    bool is_leaf_node = true;\n    for(int child_node : tree[currentNode])\n    {\n        if(child_node != parentNode)\n        {\n            is_leaf_node = false;\n            int temporary_income = aliceIncome;\n            DepthFirstSearch(child_node, currentNode, bobTime, currentTime + 1, temporary_income, maximum_income, amounts, tree);\n        }\n    }\n    if(is_leaf_node)\n    {\n        maximum_income = std::max(maximum_income, aliceIncome);\n    }\n}\n\nint CalculateMaxNetIncome(std::vector<std::vector<int>> &edges, int bobTime, std::vector<int> &amounts)\n{\n    std::unordered_map<int, std::vector<int>> tree;\n    for(const auto &edge : edges)\n    {\n        tree[edge[0]].emplace_back(edge[1]);\n        tree[edge[1]].emplace_back(edge[0]);\n    }\n    int maximum_income = -100000;\n    int alice_income = 0;\n    DepthFirstSearch(0, -1, bobTime, 0, alice_income, maximum_income, amounts, tree);\n    return maximum_income;\n}\n"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> splitMessage(string inputMessage, int characterLimit)\n{\n    int messageLength= inputMessage.size();\n    int extraCharacters= (characterLimit - 3) * (messageLength / (characterLimit - 3)) - messageLength;\n    int fullParts= messageLength / (characterLimit - 3);\n    if((messageLength + fullParts + extraCharacters) % (characterLimit - 2) != 0)\n        return {};\n    int numberOfParts= (messageLength + fullParts + extraCharacters) / (characterLimit - 2);\n    vector<string> messageParts;\n    for(int currentIndex= 0, partIndex= 1, characterCount= 0; currentIndex < messageLength || partIndex <= numberOfParts;)\n    {\n        string tempPart;\n        while(characterCount < characterLimit - 3)\n        {\n            characterCount++;\n            tempPart+= inputMessage[currentIndex++];\n            if(currentIndex == messageLength)\n                break;\n        }\n        characterCount= 0;\n        tempPart+= to_string(partIndex) + \"/\" + to_string(numberOfParts) + \" \";\n        partIndex++;\n        messageParts.push_back(tempPart);\n    }\n    return messageParts;\n}",
    "output": "#include <string>\n#include <vector>\n\nstd::vector<std::string> SplitMessage(std::string inputMessage, int characterLimit)\n{\n    int message_length = inputMessage.size();\n    int extra_characters = (characterLimit - 3) * (message_length / (characterLimit - 3)) - message_length;\n    int full_parts = message_length / (characterLimit - 3);\n    if ((message_length + full_parts + extra_characters) % (characterLimit - 2) != 0)\n        return {};\n    int number_of_parts = (message_length + full_parts + extra_characters) / (characterLimit - 2);\n    std::vector<std::string> message_parts;\n    for (int current_index = 0, part_index = 1, character_count = 0; current_index < message_length || part_index <= number_of_parts;)\n    {\n        std::string temp_part;\n        while (character_count < characterLimit - 3)\n        {\n            character_count++;\n            temp_part += inputMessage[current_index++];\n            if (current_index == message_length)\n                break;\n        }\n        character_count = 0;\n        temp_part += std::to_string(part_index) + \"/\" + std::to_string(number_of_parts) + \" \";\n        part_index++;\n        message_parts.push_back(temp_part);\n    }\n    return message_parts;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<double> convertTemperature(double celsiusTemperature)\n{\n    double kelvinTemperature = celsiusTemperature + 273.15;\n    double fahrenheitTemperature = celsiusTemperature * 1.80 + 32.00;\n    return {kelvinTemperature, fahrenheitTemperature};\n}",
    "output": "#include <vector>\n\nstd::vector<double> ConvertTemperature(double celsiusTemperature)\n{\n    double kelvin_temperature= celsiusTemperature + 273.15;\n    double fahrenheit_temperature= celsiusTemperature * 1.80 + 32.00;\n    return {kelvin_temperature, fahrenheit_temperature};\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint lcm(int firstNumber, int secondNumber)\n{\n    int currentMultiple= firstNumber;\n    while((currentMultiple % secondNumber) != 0)\n    {\n        currentMultiple+= firstNumber;\n    }\n    return currentMultiple;\n}\n\nint countLcmSubarrays(vector<int> &numberArray, int targetLcm)\n{\n    int subarrayCount= 0;\n    for(int startIndex= 0; startIndex < numberArray.size(); startIndex++)\n    {\n        int currentLcm= numberArray[startIndex];\n        for(int endIndex= startIndex; endIndex < numberArray.size(); endIndex++)\n        {\n            currentLcm= lcm(currentLcm, numberArray[endIndex]);\n            if(currentLcm == targetLcm)\n            {\n                subarrayCount++;\n            }\n        }\n    }\n    return subarrayCount;\n}",
    "output": "#include <vector>\n\nint Lcm(int firstNumber, int secondNumber)\n{\n    int current_multiple= firstNumber;\n    while((current_multiple % secondNumber) != 0)\n    {\n        current_multiple+= firstNumber;\n    }\n    return current_multiple;\n}\n\nint CountLcmSubarrays(std::vector<int> &numberArray, int targetLcm)\n{\n    int subarray_count= 0;\n    for(int start_index= 0; start_index < numberArray.size(); start_index++)\n    {\n        int current_lcm= numberArray[start_index];\n        for(int end_index= start_index; end_index < numberArray.size(); end_index++)\n        {\n            current_lcm= Lcm(current_lcm, numberArray[end_index]);\n            if(current_lcm == targetLcm)\n            {\n                subarray_count++;\n            }\n        }\n    }\n    return subarray_count;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nint calculateMinSwaps(TreeNode *rootNode)\n{\n    int swapCount= 0;\n    queue<pair<TreeNode *, int>> nodeQueue;\n    nodeQueue.push({rootNode, 0});\n\n    vector<int> levelValues;\n    int previousDepth= -1;\n\n    while(!nodeQueue.empty())\n    {\n        auto currentNode= nodeQueue.front();\n        nodeQueue.pop();\n        TreeNode *currentTreeNode= currentNode.first;\n        int currentDepth= currentNode.second;\n\n        if(previousDepth != currentDepth)\n        {\n            sort(levelValues.begin(), levelValues.end());\n            for(int i= 1; i < levelValues.size(); ++i)\n            {\n                swapCount+= abs(levelValues[i] - levelValues[i - 1]) - 1;\n            }\n            previousDepth= currentDepth;\n            levelValues.clear();\n        }\n        levelValues.push_back(currentTreeNode->value);\n\n        if(currentTreeNode->leftChild)\n            nodeQueue.push({currentTreeNode->leftChild, currentDepth + 1});\n        if(currentTreeNode->rightChild)\n            nodeQueue.push({currentTreeNode->rightChild, currentDepth + 1});\n    }\n\n    sort(levelValues.begin(), levelValues.end());\n    for(int i= 1; i < levelValues.size(); ++i)\n    {\n        swapCount+= abs(levelValues[i] - levelValues[i - 1]) - 1;\n    }\n\n    return swapCount;\n}",
    "output": "#include <algorithm>\n#include <queue>\n#include <vector>\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nint CalculateMinSwaps(TreeNode *rootNode)\n{\n    int swap_count= 0;\n    std::queue<std::pair<TreeNode *, int>> node_queue;\n    node_queue.push({rootNode, 0});\n\n    std::vector<int> level_values;\n    int previous_depth= -1;\n\n    while(!node_queue.empty())\n    {\n        auto current_node= node_queue.front();\n        node_queue.pop();\n        TreeNode *current_tree_node= current_node.first;\n        int current_depth= current_node.second;\n\n        if(previous_depth != current_depth)\n        {\n            std::sort(level_values.begin(), level_values.end());\n            for(int i= 1; i < level_values.size(); ++i)\n            {\n                swap_count+= std::abs(level_values[i] - level_values[i - 1]) - 1;\n            }\n            previous_depth= current_depth;\n            level_values.clear();\n        }\n        level_values.push_back(current_tree_node->value);\n\n        if(current_tree_node->leftChild)\n            node_queue.push({current_tree_node->leftChild, current_depth + 1});\n        if(current_tree_node->rightChild)\n            node_queue.push({current_tree_node->rightChild, current_depth + 1});\n    }\n\n    std::sort(level_values.begin(), level_values.end());\n    for(int i= 1; i < level_values.size(); ++i)\n    {\n        swap_count+= std::abs(level_values[i] - level_values[i - 1]) - 1;\n    }\n\n    return swap_count;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countMaxPalindromicSubstrings(string inputString, int minLength)\n{\n    int stringLength= inputString.size();\n    if(stringLength < minLength)\n    {\n        return 0;\n    }\n    int palindromeCount= 0;\n    vector<vector<bool>> isPalindrome(stringLength, vector<bool>(stringLength, false));\n    for(int startIndex= stringLength - 1; startIndex >= 0; startIndex--)\n    {\n        for(int endIndex= startIndex; endIndex < stringLength; endIndex++)\n        {\n            if(startIndex == endIndex)\n            {\n                isPalindrome[startIndex][endIndex]= true;\n            }\n            else if(inputString[startIndex] == inputString[endIndex])\n            {\n                isPalindrome[startIndex][endIndex]= startIndex + 1 > endIndex - 1 || isPalindrome[startIndex + 1][endIndex - 1];\n            }\n            else\n            {\n                isPalindrome[startIndex][endIndex]= false;\n            }\n            if(endIndex - startIndex + 1 >= minLength && isPalindrome[startIndex][endIndex])\n            {\n                palindromeCount++;\n                startIndex= endIndex;\n                break;\n            }\n        }\n    }\n    return palindromeCount;\n}",
    "output": "#include <string>\n#include <vector>\n\nint CountMaxPalindromicSubstrings(std::string inputString, int minLength)\n{\n    int string_length= inputString.size();\n    if(string_length < minLength)\n    {\n        return 0;\n    }\n    int palindrome_count= 0;\n    std::vector<std::vector<bool>> is_palindrome(string_length, std::vector<bool>(string_length, false));\n    for(int start_index= string_length - 1; start_index >= 0; start_index--)\n    {\n        for(int end_index= start_index; end_index < string_length; end_index++)\n        {\n            if(start_index == end_index)\n            {\n                is_palindrome[start_index][end_index]= true;\n            }\n            else if(inputString[start_index] == inputString[end_index])\n            {\n                is_palindrome[start_index][end_index]= start_index + 1 > end_index - 1 || is_palindrome[start_index + 1][end_index - 1];\n            }\n            else\n            {\n                is_palindrome[start_index][end_index]= false;\n            }\n            if(end_index - start_index + 1 >= minLength && is_palindrome[start_index][end_index])\n            {\n                palindrome_count++;\n                start_index= end_index;\n                break;\n            }\n        }\n    }\n    return palindrome_count;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> minTotalCost(int numberOfCities, vector<vector<int>> &roads, vector<int> &appleCosts, int k)\n{\n    vector<vector<pair<int, int>>> cityGraph(numberOfCities + 1);\n    for (int i = 0; i < roads.size(); ++i)\n    {\n        cityGraph[roads[i][0]].push_back({roads[i][1], roads[i][2]});\n        cityGraph[roads[i][1]].push_back({roads[i][0], roads[i][2]});\n    }\n\n    vector<int> totalCosts(numberOfCities);\n    for (int startCity = 1; startCity <= numberOfCities; ++startCity)\n    {\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> minHeap;\n        vector<int> distance(numberOfCities + 1, 1e9);\n        distance[startCity] = 0;\n        minHeap.push({0, startCity});\n        while (!minHeap.empty())\n        {\n            int currentCity = minHeap.top().second;\n            int currentDistance = minHeap.top().first;\n            minHeap.pop();\n\n            if (currentDistance > distance[currentCity])\n                continue;\n\n            for (int j = 0; j < cityGraph[currentCity].size(); ++j)\n            {\n                int adjacentCity = cityGraph[currentCity][j].first;\n                int cost = currentDistance + cityGraph[currentCity][j].second + (currentCity != startCity ? cityGraph[currentCity][j].second * k : 0) + appleCosts[adjacentCity - 1];\n\n                if (cost < distance[adjacentCity])\n                {\n                    distance[adjacentCity] = cost;\n                    minHeap.push({cost, adjacentCity});\n                }\n            }\n        }\n\n        totalCosts[startCity - 1] = distance[startCity];\n    }\n    return totalCosts;\n}",
    "output": "#include <queue>\n#include <utility>\n#include <vector>\n\nstd::vector<int> MinTotalCost(int numberOfCities, std::vector<std::vector<int>> &roads, std::vector<int> &appleCosts, int k)\n{\n    std::vector<std::vector<std::pair<int, int>>> city_graph(numberOfCities + 1);\n    for(auto &road : roads)\n    {\n        city_graph[road[0]].push_back({road[1], road[2]});\n        city_graph[road[1]].push_back({road[0], road[2]});\n    }\n\n    std::vector<int> total_costs(numberOfCities);\n    for(int start_city= 1; start_city <= numberOfCities; ++start_city)\n    {\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> min_heap;\n        std::vector<int> distance(numberOfCities + 1, 1e9);\n        distance[start_city]= 0;\n        min_heap.push({0, start_city});\n        while(!min_heap.empty())\n        {\n            int current_city= min_heap.top().second;\n            int current_distance= min_heap.top().first;\n            min_heap.pop();\n\n            if(current_distance > distance[current_city])\n                continue;\n\n            for(auto &edge : city_graph[current_city])\n            {\n                int adjacent_city= edge.first;\n                int cost= current_distance + edge.second + (current_city != start_city ? edge.second * k : 0) + appleCosts[adjacent_city - 1];\n\n                if(cost < distance[adjacent_city])\n                {\n                    distance[adjacent_city]= cost;\n                    min_heap.push({cost, adjacent_city});\n                }\n            }\n        }\n\n        total_costs[start_city - 1]= distance[start_city];\n    }\n    return total_costs;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countTriplets(vector<int> &numberList)\n{\n    int tripletCount= 0;\n    int listSize= numberList.size();\n\n    for(int firstIndex= 0; firstIndex < listSize; firstIndex++)\n    {\n        for(int secondIndex= firstIndex + 1; secondIndex < listSize; secondIndex++)\n        {\n            for(int thirdIndex= secondIndex + 1; thirdIndex < listSize; thirdIndex++)\n            {\n                if(numberList[firstIndex] != numberList[secondIndex] && numberList[firstIndex] != numberList[thirdIndex] && numberList[secondIndex] != numberList[thirdIndex])\n                {\n                    tripletCount++;\n                }\n            }\n        }\n    }\n\n    return tripletCount;\n}",
    "output": "#include <vector>\n\nint CountTriplets(std::vector<int> &numberList)\n{\n    int triplet_count= 0;\n    int list_size= numberList.size();\n\n    for(int first_index= 0; first_index < list_size; first_index++)\n    {\n        for(int second_index= first_index + 1; second_index < list_size; second_index++)\n        {\n            for(int third_index= second_index + 1; third_index < list_size; third_index++)\n            {\n                if(numberList[first_index] != numberList[second_index] && numberList[first_index] != numberList[third_index] && numberList[second_index] != numberList[third_index])\n                {\n                    triplet_count++;\n                }\n            }\n        }\n    }\n\n    return triplet_count;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nvector<vector<int>> findMinMax(TreeNode *root, vector<int> &queries)\n{\n    if(!root)\n    {\n        return {};\n    }\n\n    vector<vector<int>> result(queries.size(), vector<int>{-1, -1});\n    for(size_t index= 0; index < queries.size(); index++)\n    {\n        TreeNode *currentNode= root;\n        int currentQuery= queries[index];\n        while(currentNode)\n        {\n            if(currentNode->value < currentQuery)\n            {\n                result[index][0]= currentNode->value;\n                currentNode= currentNode->rightChild;\n            }\n            else\n            {\n                result[index][1]= currentNode->value;\n                if(currentNode->value == currentQuery)\n                {\n                    result[index][0]= currentQuery;\n                    break;\n                }\n                currentNode= currentNode->leftChild;\n            }\n        }\n    }\n    return result;\n}",
    "output": "#include <vector>\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x) : value(x), leftChild(nullptr), rightChild(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nstd::vector<std::vector<int>> FindMinMax(TreeNode *root, std::vector<int> &queries)\n{\n    if(!root)\n    {\n        return {};\n    }\n\n    std::vector<std::vector<int>> result(queries.size(), std::vector<int>{-1, -1});\n    for(size_t index= 0; index < queries.size(); index++)\n    {\n        TreeNode *current_node= root;\n        int current_query= queries[index];\n        while(current_node)\n        {\n            if(current_node->value < current_query)\n            {\n                result[index][0]= current_node->value;\n                current_node= current_node->rightChild;\n            }\n            else\n            {\n                result[index][1]= current_node->value;\n                if(current_node->value == current_query)\n                {\n                    result[index][0]= current_query;\n                    break;\n                }\n                current_node= current_node->leftChild;\n            }\n        }\n    }\n    return result;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMinimumFuel(vector<vector<int>> &roadConnections, int seatCapacity)\n{\n    int numberOfCities = roadConnections.size() + 1;\n    vector<vector<int>> cityGraph(numberOfCities);\n    for (const auto &road : roadConnections) // This can remain as a range-based for loop\n    {\n        cityGraph[road[0]].push_back(road[1]);\n        cityGraph[road[1]].push_back(road[0]);\n    }\n\n    vector<int> cityDistance(numberOfCities, -1);\n    queue<int> cityQueue;\n    cityQueue.push(0);\n    cityDistance[0] = 0;\n\n    while (!cityQueue.empty())\n    {\n        int currentCity = cityQueue.front();\n        cityQueue.pop();\n        for (int neighborCity : cityGraph[currentCity]) // This can remain as a range-based for loop\n        {\n            if (cityDistance[neighborCity] == -1)\n            {\n                cityDistance[neighborCity] = cityDistance[currentCity] + 1;\n                cityQueue.push(neighborCity);\n            }\n        }\n    }\n\n    int totalFuelRequired = 0;\n    for (int cityIndex = 1; cityIndex < numberOfCities; cityIndex++)\n    {\n        totalFuelRequired += (cityDistance[cityIndex] - 1) / (seatCapacity - 1) + 1;\n    }\n    return totalFuelRequired;\n}",
    "output": "#include <queue>\n#include <vector>\n\nint CalculateMinimumFuel(std::vector<std::vector<int>> &roadConnections, int seatCapacity)\n{\n    int number_of_cities= roadConnections.size() + 1;\n    std::vector<std::vector<int>> cityGraph(number_of_cities);\n    for(auto &road : roadConnections)\n    {\n        cityGraph[road[0]].push_back(road[1]);\n        cityGraph[road[1]].push_back(road[0]);\n    }\n\n    std::vector<int> cityDistance(number_of_cities, -1);\n    std::queue<int> cityQueue;\n    cityQueue.push(0);\n    cityDistance[0]= 0;\n\n    while(!cityQueue.empty())\n    {\n        int current_city= cityQueue.front();\n        cityQueue.pop();\n        for(int neighbor_city : cityGraph[current_city])\n        {\n            if(cityDistance[neighbor_city] == -1)\n            {\n                cityDistance[neighbor_city]= cityDistance[current_city] + 1;\n                cityQueue.push(neighbor_city);\n            }\n        }\n    }\n\n    int total_fuel_required= 0;\n    for(int city_index= 1; city_index < number_of_cities; city_index++)\n    {\n        total_fuel_required+= (cityDistance[city_index] - 1) / (seatCapacity - 1) + 1;\n    }\n    return total_fuel_required;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint numBeautifulPartitions(const string &inputString, int partitionCount, int minimumLength)\n{\n    const int modulo= 1e9 + 7;\n    unordered_set<char> primeDigits= {'2', '3', '5', '7'};\n    int stringLength= inputString.length();\n    vector<vector<int>> dynamicProgramming(stringLength + 1, vector<int>(partitionCount + 1, 0));\n    dynamicProgramming[0][0]= 1;\n\n    for(int currentIndex= 1; currentIndex <= stringLength; ++currentIndex)\n    {\n        for(int currentPartitions= 1; currentPartitions <= partitionCount; ++currentPartitions)\n        {\n            for(int length= minimumLength; length <= currentIndex && currentIndex - length >= currentPartitions - 1; ++length)\n            {\n                if(primeDigits.count(inputString[currentIndex - length]) && !primeDigits.count(inputString[currentIndex - 1]))\n                {\n                    dynamicProgramming[currentIndex][currentPartitions]+= dynamicProgramming[currentIndex - length][currentPartitions - 1];\n                    if(dynamicProgramming[currentIndex][currentPartitions] >= modulo)\n                        dynamicProgramming[currentIndex][currentPartitions]-= modulo;\n                }\n            }\n        }\n    }\n\n    return dynamicProgramming[stringLength][partitionCount];\n}",
    "output": "#include <string>\n#include <unordered_set>\n#include <vector>\n\nstd::unordered_set<char> prime_digits = {'2', '3', '5', '7'};\n\nint NumBeautifulPartitions(const std::string &inputString, int partitionCount, int minimumLength)\n{\n    const int modulo = 1e9 + 7;\n    int string_length = inputString.length();\n    std::vector<std::vector<int>> dynamic_programming(string_length + 1, std::vector<int>(partitionCount + 1, 0));\n    dynamic_programming[0][0] = 1;\n\n    for (int current_index = 1; current_index <= string_length; ++current_index)\n    {\n        for (int current_partitions = 1; current_partitions <= partitionCount; ++current_partitions)\n        {\n            for (int length = minimumLength; length <= current_index && current_index - length >= current_partitions - 1; ++length)\n            {\n                if (prime_digits.count(inputString[current_index - length]) && !prime_digits.count(inputString[current_index - 1]))\n                {\n                    dynamic_programming[current_index][current_partitions] += dynamic_programming[current_index - length][current_partitions - 1];\n                    if (dynamic_programming[current_index][current_partitions] >= modulo)\n                        dynamic_programming[current_index][current_partitions] -= modulo;\n                }\n            }\n        }\n    }\n\n    return dynamic_programming[string_length][partitionCount];\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<vector<int>> &adjacencyList, vector<int> &nodeValues, int &maximumXor)\n{\n    int currentXorSum = nodeValues[currentNode];\n\n    for (int i = 0; i < adjacencyList[currentNode].size(); ++i)\n    {\n        int childNode = adjacencyList[currentNode][i];\n        if (childNode != parentNode)\n        {\n            currentXorSum ^= depthFirstSearch(childNode, currentNode, adjacencyList, nodeValues, maximumXor);\n        }\n    }\n\n    maximumXor = max(maximumXor, currentXorSum);\n\n    return currentXorSum;\n}\n\nint maxXorSubtree(int totalNodes, vector<vector<int>> &edges, vector<int> &nodeValues)\n{\n    vector<vector<int>> adjacencyList(totalNodes);\n\n    for (const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1]);\n        adjacencyList[edge[1]].emplace_back(edge[0]);\n    }\n\n    int maximumXor = 0;\n    int rootXorSum = depthFirstSearch(0, -1, adjacencyList, nodeValues, maximumXor);\n\n    return rootXorSum ^ maximumXor;\n}",
    "output": "#include <unordered_map>\n#include <vector>\n\nint DepthFirstSearch(int currentNode, int parentNode, std::vector<std::vector<int>> &adjacencyList, std::vector<int> &nodeValues, int &maximumXor)\n{\n    int current_xor_sum = nodeValues[currentNode];\n\n    for(int child_node : adjacencyList[currentNode])\n    {\n        if(child_node != parentNode)\n        {\n            current_xor_sum ^= DepthFirstSearch(child_node, currentNode, adjacencyList, nodeValues, maximumXor);\n        }\n    }\n\n    maximumXor = std::max(maximumXor, current_xor_sum);\n\n    return current_xor_sum;\n}\n\nint MaxXorSubtree(int totalNodes, std::vector<std::vector<int>> &edges, std::vector<int> &nodeValues)\n{\n    std::vector<std::vector<int>> adjacencyList(totalNodes);\n\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1]);\n        adjacencyList[edge[1]].emplace_back(edge[0]);\n    }\n\n    int maximum_xor = 0;\n    int root_xor_sum = DepthFirstSearch(0, -1, adjacencyList, nodeValues, maximum_xor);\n\n    return root_xor_sum ^ maximum_xor;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "int minCuts(int number)\n{\n    if(number % 2 == 0)\n        return number / 2;\n    else\n        return number;\n}",
    "output": "int MinCuts(int number)\n{\n    if(number % 2 == 0)\n        return number / 2;\n    else\n        return number;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> createDifferenceMatrix(vector<vector<int>> &inputGrid)\n{\n    int rowCount= inputGrid.size(), columnCount= inputGrid[0].size();\n    vector<int> rowSum(rowCount, 0), columnSum(columnCount, 0);\n    vector<vector<int>> differenceMatrix(rowCount, vector<int>(columnCount));\n\n    for(int currentRowIndex= 0; currentRowIndex < rowCount; ++currentRowIndex)\n    {\n        for(int currentColIndex= 0; currentColIndex < columnCount; ++currentColIndex)\n        {\n            rowSum[currentRowIndex]+= inputGrid[currentRowIndex][currentColIndex];\n            columnSum[currentColIndex]+= inputGrid[currentRowIndex][currentColIndex];\n        }\n    }\n\n    for(int currentRowIndex= 0; currentRowIndex < rowCount; ++currentRowIndex)\n    {\n        for(int currentColIndex= 0; currentColIndex < columnCount; ++currentColIndex)\n        {\n            differenceMatrix[currentRowIndex][currentColIndex]= rowSum[currentRowIndex] + columnSum[currentColIndex] - (columnCount - rowSum[currentRowIndex]) - (rowCount - columnSum[currentColIndex]);\n        }\n    }\n\n    return differenceMatrix;\n}",
    "output": "#include <vector>\n\nstd::vector<std::vector<int>> CreateDifferenceMatrix(std::vector<std::vector<int>> &inputGrid)\n{\n    int row_count= inputGrid.size(), column_count= inputGrid[0].size();\n    std::vector<int> row_sum(row_count, 0), column_sum(column_count, 0);\n    std::vector<std::vector<int>> difference_matrix(row_count, std::vector<int>(column_count));\n\n    for(int current_row_index= 0; current_row_index < row_count; ++current_row_index)\n    {\n        for(int current_col_index= 0; current_col_index < column_count; ++current_col_index)\n        {\n            row_sum[current_row_index]+= inputGrid[current_row_index][current_col_index];\n            column_sum[current_col_index]+= inputGrid[current_row_index][current_col_index];\n        }\n    }\n\n    for(int current_row_index= 0; current_row_index < row_count; ++current_row_index)\n    {\n        for(int current_col_index= 0; current_col_index < column_count; ++current_col_index)\n        {\n            difference_matrix[current_row_index][current_col_index]= row_sum[current_row_index] + column_sum[current_col_index] - (column_count - row_sum[current_row_index]) - (row_count - column_sum[current_col_index]);\n        }\n    }\n\n    return difference_matrix;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minPenalty(string customerSequence)\n{\n    int customerCount = customerSequence.length();\n    int openPenalty = 0, closedPenalty = 0;\n\n    for (int i = 0; i < customerCount; ++i)\n    {\n        char currentCustomer = customerSequence[i];\n        if (currentCustomer == 'N')\n            openPenalty++;\n        else\n            closedPenalty++;\n    }\n\n    int minimumPenalty = closedPenalty;\n    int currentPenalty = closedPenalty;\n\n    for (int index = 0; index < customerCount; index++)\n    {\n        if (customerSequence[index] == 'N')\n            currentPenalty--;\n        else\n            currentPenalty++;\n\n        minimumPenalty = min(minimumPenalty, currentPenalty);\n    }\n\n    return minimumPenalty;\n}",
    "output": "#include <string>\n#include <algorithm>\n\nint MinPenalty(std::string customerSequence)\n{\n    int customer_count= customerSequence.length();\n    int open_penalty= 0, closed_penalty= 0;\n\n    for(char current_customer : customerSequence)\n    {\n        if(current_customer == 'N')\n            open_penalty++;\n        else\n            closed_penalty++;\n    }\n\n    int minimum_penalty= closed_penalty;\n    int current_penalty= closed_penalty;\n\n    for(int index= 0; index < customer_count; index++)\n    {\n        if(customerSequence[index] == 'N')\n            current_penalty--;\n        else\n            current_penalty++;\n\n        minimum_penalty= std::min(minimum_penalty, current_penalty);\n    }\n\n    return minimum_penalty;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countPalindromeSubsequences(string inputString, int modulus)\n{\n    int stringLength= inputString.size();\n    const int modulusValue= 1000000007;\n    vector<vector<int>> dpTable(10, vector<int>(stringLength, 0));\n    for(int i= 0; i < stringLength; ++i)\n        dpTable[inputString[i] - '0'][i]= 1;\n    for(int length= 1; length <= 4; ++length)\n    {\n        for(int digit= 0; digit < 10; ++digit)\n        {\n            for(int i= 0, j= length; j < stringLength; ++i, ++j)\n            {\n                dpTable[digit][j]= (dpTable[digit][j - 1] + (inputString[j] - '0' == digit)) % modulusValue;\n            }\n        }\n    }\n    long long totalCount= 0;\n    for(int firstDigit= 0; firstDigit < 10; ++firstDigit)\n    {\n        for(int secondDigit= 0; secondDigit < 10; ++secondDigit)\n        {\n            totalCount+= (1LL * dpTable[firstDigit][stringLength - 5] * dpTable[secondDigit][stringLength - 1]) % modulusValue;\n        }\n    }\n    return totalCount % modulusValue;\n}",
    "output": "#include <string>\n#include <vector>\n\nint CountPalindromeSubsequences(std::string inputString, int modulus)\n{\n    int string_length= inputString.size();\n    const int modulus_value= 1000000007;\n    std::vector<std::vector<int>> dp_table(10, std::vector<int>(string_length, 0));\n    for(int i= 0; i < string_length; ++i)\n        dp_table[inputString[i] - '0'][i]= 1;\n    for(int length= 1; length <= 4; ++length)\n    {\n        for(int digit= 0; digit < 10; ++digit)\n        {\n            for(int i= 0, j= length; j < string_length; ++i, ++j)\n            {\n                dp_table[digit][j]= (dp_table[digit][j - 1] + (inputString[j] - '0' == digit)) % modulus_value;\n            }\n        }\n    }\n    long long total_count= 0;\n    for(int first_digit= 0; first_digit < 10; ++first_digit)\n    {\n        for(int second_digit= 0; second_digit < 10; ++second_digit)\n        {\n            total_count+= (1LL * dp_table[first_digit][string_length - 5] * dp_table[second_digit][string_length - 1]) % modulus_value;\n        }\n    }\n    return total_count % modulus_value;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "int findPivot(int totalNumbers)\n{\n    int totalSum= totalNumbers * (totalNumbers + 1) / 2;\n    int leftSum= 0;\n    for(int currentNumber= 1; currentNumber <= totalNumbers; ++currentNumber)\n    {\n        leftSum+= currentNumber;\n        if(2 * leftSum == totalSum)\n        {\n            return currentNumber;\n        }\n    }\n    return -1;\n}",
    "output": "int FindPivot(int totalNumbers)\n{\n    int total_sum= totalNumbers * (totalNumbers + 1) / 2;\n    int left_sum= 0;\n    for(int current_number= 1; current_number <= totalNumbers; ++current_number)\n    {\n        left_sum+= current_number;\n        if(2 * left_sum == total_sum)\n        {\n            return current_number;\n        }\n    }\n    return -1;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minAddition(string sourceString, string targetString)\n{\n    int sourceLength = sourceString.length();\n    int targetLength = targetString.length();\n    int sourceIndex = 0, targetIndex = 0;\n    while(sourceIndex < sourceLength && targetIndex < targetLength)\n    {\n        if(sourceString[sourceIndex] == targetString[targetIndex])\n        {\n            targetIndex++;\n        }\n        sourceIndex++;\n    }\n    return targetLength - targetIndex;\n}",
    "output": "int MinAddition(std::string sourceString, std::string targetString)\n{\n    int source_length= sourceString.length();\n    int target_length= targetString.length();\n    int source_index= 0, target_index= 0;\n    while(source_index < source_length && target_index < target_length)\n    {\n        if(sourceString[source_index] == targetString[target_index])\n        {\n            target_index++;\n        }\n        source_index++;\n    }\n    return target_length - target_index;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "class ListNode\n{\n  public:\n    int value;\n    ListNode *next;\n};\n\nListNode *removeNodes(ListNode *head)\n{\n    if(!head)\n        return NULL;\n    ListNode *maxNode= head;\n    ListNode *currentNode= head;\n    ListNode *previousNode= NULL;\n\n    while(currentNode && currentNode->next)\n    {\n        if(currentNode->next->value > maxNode->value)\n        {\n            if(previousNode)\n                previousNode->next= currentNode->next;\n            else\n                head= currentNode->next;\n            maxNode= currentNode->next;\n        }\n        else\n        {\n            previousNode= currentNode;\n        }\n        currentNode= currentNode->next;\n    }\n    maxNode->next= removeNodes(maxNode->next);\n    return head;\n}",
    "output": "class ListNode\n{\n  public:\n    int value;\n    ListNode *next;\n};\n\nListNode *RemoveNodes(ListNode *head)\n{\n    if(!head)\n        return nullptr;\n    ListNode *max_node= head;\n    ListNode *current_node= head;\n    ListNode *previous_node= nullptr;\n\n    while(current_node && current_node->next)\n    {\n        if(current_node->next->value > max_node->value)\n        {\n            if(previous_node)\n                previous_node->next= current_node->next;\n            else\n                head= current_node->next;\n            max_node= current_node->next;\n        }\n        else\n        {\n            previous_node= current_node;\n        }\n        current_node= current_node->next;\n    }\n    max_node->next= RemoveNodes(max_node->next);\n    return head;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countSubarraysWithMedian(vector<int> &numbers, int target)\n{\n    int resultCount = 0;\n    for(int startIndex = 0; startIndex < numbers.size(); ++startIndex)\n    {\n        int targetCount = 0;\n        vector<int> subarray;\n        for(int endIndex = startIndex; endIndex < numbers.size(); ++endIndex)\n        {\n            targetCount += (numbers[endIndex] == target);\n            subarray.insert(lower_bound(subarray.begin(), subarray.end(), numbers[endIndex]), numbers[endIndex]);\n            if((subarray.size() % 2 == 1) && (subarray[subarray.size() / 2] == target))\n            {\n                resultCount += targetCount;\n            }\n        }\n    }\n    return resultCount;\n}",
    "output": "int CountSubarraysWithMedian(std::vector<int> &numbers, int target)\n{\n    int result_count= 0;\n    for(int start_index= 0; start_index < numbers.size(); ++start_index)\n    {\n        int target_count= 0;\n        std::vector<int> subarray;\n        for(int end_index= start_index; end_index < numbers.size(); ++end_index)\n        {\n            target_count+= (numbers[end_index] == target);\n            subarray.insert(lower_bound(subarray.begin(), subarray.end(), numbers[end_index]), numbers[end_index]);\n            if((subarray.size() % 2 == 1) && (subarray[subarray.size() / 2] == target))\n            {\n                result_count+= target_count;\n            }\n        }\n    }\n    return result_count;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateRatioSubstringCount(string inputString, int firstNum, int secondNum)\n{\n    int zeroCount = 0, oneCount = 0;\n    map<int, int> frequencyMap;\n    int substringCount = 0;\n\n    frequencyMap[0] = 1;\n\n    for (int i = 0; i < inputString.size(); ++i)\n    {\n        char currentChar = inputString[i];\n        if (currentChar == '0')\n            zeroCount++;\n        else\n            oneCount++;\n\n        int currentDifference = zeroCount * secondNum - oneCount * firstNum;\n        substringCount += frequencyMap[currentDifference];\n        frequencyMap[currentDifference]++;\n    }\n    return substringCount;\n}",
    "output": "int CalculateRatioSubstringCount(std::string inputString, int firstNum, int secondNum)\n{\n    int zero_count= 0, one_count= 0;\n    std::map<int, int> frequency_map;\n    int substring_count= 0;\n\n    frequency_map[0]= 1;\n\n    for(char currentChar : inputString)\n    {\n        if(currentChar == '0')\n            zero_count++;\n        else\n            one_count++;\n\n        int current_difference= zero_count * secondNum - one_count * firstNum;\n        substring_count+= frequency_map[current_difference];\n        frequency_map[current_difference]++;\n    }\n    return substring_count;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isCircular(string sentence)\n{\n    stringstream stream(sentence);\n    string currentWord, previousWord;\n\n    while(stream >> currentWord)\n    {\n        if(!previousWord.empty() && previousWord.back() != currentWord.front())\n        {\n            return false;\n        }\n        previousWord = currentWord;\n    }\n\n    return currentWord.back() == sentence.front();\n}",
    "output": "bool IsCircular(std::string sentence)\n{\n    std::stringstream stream(sentence);\n    std::string current_word, previous_word;\n\n    while(stream >> current_word)\n    {\n        if(!previous_word.empty() && previous_word.back() != current_word.front())\n        {\n            return false;\n        }\n        previous_word= current_word;\n    }\n\n    return current_word.back() == sentence.front();\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maximumChemistry(vector<int> &skillLevels)\n{\n    int totalSum = 0;\n    for (int i = 0; i < skillLevels.size(); ++i)\n    {\n        totalSum += skillLevels[i];\n    }\n    int targetSum = totalSum / 2;\n    if (totalSum % 2 == 1)\n        return -1;\n\n    unordered_map<int, int> dynamicProgrammingMap;\n    dynamicProgrammingMap[0] = 1;\n    int maxChemistry = 0;\n\n    for (int i = 0; i < skillLevels.size(); ++i)\n    {\n        int skill = skillLevels[i];\n        for (int j = targetSum - skill; j >= 0; j--)\n        {\n            if (dynamicProgrammingMap[j])\n            {\n                dynamicProgrammingMap[j + skill] += dynamicProgrammingMap[j];\n                if (j + skill == targetSum)\n                {\n                    maxChemistry += dynamicProgrammingMap[j] * skill;\n                }\n            }\n        }\n    }\n\n    return (maxChemistry > 0) ? maxChemistry : -1;\n}",
    "output": "#include <unordered_map>\n#include <vector>\n\nint MaximumChemistry(std::vector<int> &skillLevels)\n{\n    int total_sum= 0;\n    for(int skill : skillLevels)\n    {\n        total_sum+= skill;\n    }\n    int target_sum= total_sum / 2;\n    if(total_sum % 2 == 1)\n        return -1;\n\n    std::unordered_map<int, int> dynamic_programming_map;\n    dynamic_programming_map[0]= 1;\n    int max_chemistry= 0;\n\n    for(int skill : skillLevels)\n    {\n        for(int i= target_sum - skill; i >= 0; i--)\n        {\n            if(dynamic_programming_map[i])\n            {\n                dynamic_programming_map[i + skill]+= dynamic_programming_map[i];\n                if(i + skill == target_sum)\n                {\n                    max_chemistry+= dynamic_programming_map[i] * skill;\n                }\n            }\n        }\n    }\n\n    return (max_chemistry > 0) ? max_chemistry : -1;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumScore(int totalCities, vector<vector<int>> &roads)\n{\n    vector<vector<pair<int, int>>> adjacencyList(totalCities + 1);\n    for (int i = 0; i < roads.size(); ++i)\n    {\n        adjacencyList[roads[i][0]].push_back({roads[i][1], roads[i][2]});\n        adjacencyList[roads[i][1]].push_back({roads[i][0], roads[i][2]});\n    }\n\n    const int infinity = 1e9;\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> priorityQueue;\n    priorityQueue.push({0, 1});\n\n    vector<int> minimumDistance(totalCities + 1, infinity);\n    while (!priorityQueue.empty())\n    {\n        int currentCity = priorityQueue.top().second;\n        int currentDistance = priorityQueue.top().first;\n        priorityQueue.pop();\n\n        if (currentCity == totalCities)\n        {\n            return currentDistance;\n        }\n\n        if (currentDistance < minimumDistance[currentCity])\n        {\n            minimumDistance[currentCity] = currentDistance;\n            for (int j = 0; j < adjacencyList[currentCity].size(); ++j)\n            {\n                const auto &neighbor = adjacencyList[currentCity][j];\n                int nextCity = neighbor.first;\n                int nextDistance = max(currentDistance, neighbor.second);\n                if (nextDistance < minimumDistance[nextCity])\n                {\n                    priorityQueue.push({nextDistance, nextCity});\n                }\n            }\n        }\n    }\n\n    return -1;\n}",
    "output": "#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\n\nint MinimumScore(int totalCities, std::vector<std::vector<int>> &roads)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacency_list(totalCities + 1);\n    for(const auto &road : roads)\n    {\n        adjacency_list[road[0]].push_back({road[1], road[2]});\n        adjacency_list[road[1]].push_back({road[0], road[2]});\n    }\n\n    const int infinity= 1e9;\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<>> priority_queue;\n    priority_queue.push({0, 1});\n\n    std::vector<int> minimum_distance(totalCities + 1, infinity);\n    while(!priority_queue.empty())\n    {\n        int current_city= priority_queue.top().second;\n        int current_distance= priority_queue.top().first;\n        priority_queue.pop();\n\n        if(current_city == totalCities)\n        {\n            return current_distance;\n        }\n\n        if(current_distance < minimum_distance[current_city])\n        {\n            minimum_distance[current_city]= current_distance;\n            for(const auto &neighbor : adjacency_list[current_city])\n            {\n                int next_city= neighbor.first;\n                int next_distance= std::max(current_distance, neighbor.second);\n                if(next_distance < minimum_distance[next_city])\n                {\n                    priority_queue.push({next_distance, next_city});\n                }\n            }\n        }\n    }\n\n    return -1;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxGroups(int numberOfNodes, vector<vector<int>> &edges)\n{\n    vector<vector<int>> adjacencyList(numberOfNodes + 1);\n    vector<int> nodeColor(numberOfNodes + 1, 0);\n\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        adjacencyList[edges[i][0]].push_back(edges[i][1]);\n        adjacencyList[edges[i][1]].push_back(edges[i][0]);\n    }\n\n    int maximumGroupSize = 0;\n    for (int nodeIndex = 1; nodeIndex <= numberOfNodes; ++nodeIndex)\n    {\n        if (nodeColor[nodeIndex] == 0)\n        {\n            queue<int> nodeQueue;\n            nodeQueue.push(nodeIndex);\n            nodeColor[nodeIndex] = 1;\n            while (!nodeQueue.empty())\n            {\n                int currentNode = nodeQueue.front();\n                nodeQueue.pop();\n                maximumGroupSize = max(maximumGroupSize, nodeColor[currentNode]);\n                for (int j = 0; j < adjacencyList[currentNode].size(); ++j)\n                {\n                    int neighbor = adjacencyList[currentNode][j];\n                    if (nodeColor[neighbor] == 0)\n                    {\n                        nodeColor[neighbor] = nodeColor[currentNode] + 1;\n                        nodeQueue.push(neighbor);\n                    }\n                    else if (nodeColor[neighbor] == nodeColor[currentNode])\n                    {\n                        return -1;\n                    }\n                }\n            }\n        }\n    }\n    return maximumGroupSize;\n}",
    "output": "#include <queue>\n#include <vector>\n\nint MaxGroups(int numberOfNodes, std::vector<std::vector<int>> &edges)\n{\n    std::vector<std::vector<int>> adjacency_list(numberOfNodes + 1);\n    std::vector<int> node_color(numberOfNodes + 1, 0);\n\n    for(auto &edge : edges)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    int maximum_group_size= 0;\n    for(int node_index= 1; node_index <= numberOfNodes; ++node_index)\n    {\n        if(node_color[node_index] == 0)\n        {\n            std::queue<int> node_queue;\n            node_queue.push(node_index);\n            node_color[node_index]= 1;\n            while(!node_queue.empty())\n            {\n                int current_node= node_queue.front();\n                node_queue.pop();\n                maximum_group_size= std::max(maximum_group_size, node_color[current_node]);\n                for(int neighbor : adjacency_list[current_node])\n                {\n                    if(node_color[neighbor] == 0)\n                    {\n                        node_color[neighbor]= node_color[current_node] + 1;\n                        node_queue.push(neighbor);\n                    }\n                    else if(node_color[neighbor] == node_color[current_node])\n                    {\n                        return -1;\n                    }\n                }\n            }\n        }\n    }\n    return maximum_group_size;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countOfEvenSubarrays(vector<int> &numberArray)\n{\n    int arraySize = numberArray.size();\n    int evenCount = 0, oddCount = 0, totalCount = 0;\n\n    for (int i = 0; i < arraySize; ++i)\n    {\n        int currentNumber = numberArray[i];\n        if (currentNumber % 2 == 0)\n        {\n            evenCount++;\n            totalCount += evenCount;\n        }\n        else\n        {\n            swap(evenCount, oddCount);\n            oddCount++;\n            totalCount += oddCount;\n        }\n    }\n\n    return totalCount;\n}",
    "output": "#include <vector>\n#include <algorithm> // For std::swap\n\nint CountOfEvenSubarrays(std::vector<int> &numberArray)\n{\n    int array_size= numberArray.size();\n    int even_count= 0, odd_count= 0, total_count= 0;\n\n    for(int current_number : numberArray)\n    {\n        if(current_number % 2 == 0)\n        {\n            even_count++;\n            total_count+= even_count;\n        }\n        else\n        {\n            std::swap(even_count, odd_count);\n            odd_count++;\n            total_count+= odd_count;\n        }\n    }\n\n    return total_count;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxValue(vector<string> &stringList)\n{\n    int maxValue = 0;\n    for (int i = 0; i < stringList.size(); ++i)\n    {\n        const string &currentString = stringList[i];\n        int currentValue;\n        if (currentString.find_first_not_of(\"0123456789\") == string::npos)\n        {\n            currentValue = stoi(currentString);\n        }\n        else\n        {\n            currentValue = static_cast<int>(currentString.length());\n        }\n        maxValue = max(maxValue, currentValue);\n    }\n    return maxValue;\n}",
    "output": "#include <string>\n#include <vector>\n\nint MaxValue(std::vector<std::string> &stringList)\n{\n    int max_value= 0;\n    for(const std::string &current_string : stringList)\n    {\n        int current_value;\n        if(current_string.find_first_not_of(\"0123456789\") == std::string::npos)\n        {\n            current_value= std::stoi(current_string);\n        }\n        else\n        {\n            current_value= static_cast<int>(current_string.length());\n        }\n        max_value= std::max(max_value, current_value);\n    }\n    return max_value;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxStarSum(const vector<int> &nodeValues, const vector<vector<int>> &edges, int k)\n{\n    vector<int> adjacencyList[100000];\n    int maximumSum = -1e9;\n\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        const vector<int> &edge = edges[i];\n        adjacencyList[edge[0]].push_back(nodeValues[edge[1]]);\n        adjacencyList[edge[1]].push_back(nodeValues[edge[0]]);\n    }\n\n    for (int nodeIndex = 0; nodeIndex < nodeValues.size(); nodeIndex++)\n    {\n        sort(adjacencyList[nodeIndex].rbegin(), adjacencyList[nodeIndex].rend());\n        int currentSum = nodeValues[nodeIndex];\n        for (int j = 0; j < k && j < adjacencyList[nodeIndex].size(); j++)\n        {\n            currentSum += adjacencyList[nodeIndex][j];\n        }\n        maximumSum = max(maximumSum, currentSum);\n    }\n\n    return maximumSum;\n}",
    "output": "#include <algorithm>\n#include <vector>\n\nint MaxStarSum(const std::vector<int> &nodeValues, const std::vector<std::vector<int>> &edges, int k)\n{\n    std::vector<int> adjacency_list[100000];\n    int maximum_sum= -1e9;\n\n    for(const std::vector<int> &edge : edges)\n    {\n        adjacency_list[edge[0]].push_back(nodeValues[edge[1]]);\n        adjacency_list[edge[1]].push_back(nodeValues[edge[0]]);\n    }\n\n    for(int node_index= 0; node_index < nodeValues.size(); node_index++)\n    {\n        std::sort(adjacency_list[node_index].rbegin(), adjacency_list[node_index].rend());\n        int current_sum= nodeValues[node_index];\n        for(int j= 0; j < k && j < adjacency_list[node_index].size(); j++)\n        {\n            current_sum+= adjacency_list[node_index][j];\n        }\n        maximum_sum= std::max(maximum_sum, current_sum);\n    }\n\n    return maximum_sum;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumPathCost(vector<int> &stoneCosts)\n{\n    int numberOfStones= stoneCosts.size();\n    int minimumCost= stoneCosts[numberOfStones - 1];\n    for(int index= 1; index < numberOfStones - 1; ++index)\n    {\n        minimumCost= min(minimumCost, max(stoneCosts[index], stoneCosts[numberOfStones - 1] - stoneCosts[index]));\n    }\n    return minimumCost;\n}",
    "output": "#include <vector>\n#include <algorithm>\n\nint MinimumPathCost(std::vector<int> &stoneCosts)\n{\n    int number_of_stones = stoneCosts.size();\n    int minimum_cost = stoneCosts[number_of_stones - 1];\n    for(int index = 1; index < number_of_stones - 1; ++index)\n    {\n        minimum_cost = std::min(minimum_cost, std::max(stoneCosts[index], stoneCosts[number_of_stones - 1] - stoneCosts[index]));\n    }\n    return minimum_cost;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minCost(vector<int> &firstArray, vector<int> &secondArray)\n{\n    unordered_map<int, vector<int>> valueToIndices;\n    for(int index = 0; index < firstArray.size(); ++index)\n    {\n        valueToIndices[firstArray[index]].push_back(index);\n    }\n\n    int totalCost = 0;\n    for(int i = 0; i < secondArray.size(); ++i)\n    {\n        int value = secondArray[i];\n        if(valueToIndices[value].empty())\n            return -1;\n        totalCost += valueToIndices[value].back();\n        valueToIndices[value].pop_back();\n    }\n\n    return totalCost;\n}",
    "output": "#include <vector>\n#include <unordered_map>\n\nint MinCost(std::vector<int> &firstArray, std::vector<int> &secondArray)\n{\n    std::unordered_map<int, std::vector<int>> value_to_indices;\n    for(int index= 0; index < firstArray.size(); ++index)\n    {\n        value_to_indices[firstArray[index]].push_back(index);\n    }\n\n    int total_cost= 0;\n    for(int value : secondArray)\n    {\n        if(value_to_indices[value].empty())\n            return -1;\n        total_cost+= value_to_indices[value].back();\n        value_to_indices[value].pop_back();\n    }\n\n    return total_cost;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxValueAfterOperations(vector<vector<int>> &grid)\n{\n    int totalMaxValue= 0;\n    while(!grid.empty())\n    {\n        int currentMaxValue= 0, maxRowIndex= -1;\n\n        for(int rowIndex= 0; rowIndex < grid.size(); ++rowIndex)\n        {\n            auto maxElementIterator= max_element(grid[rowIndex].begin(), grid[rowIndex].end());\n            if(*maxElementIterator > currentMaxValue)\n            {\n                currentMaxValue= *maxElementIterator;\n                maxRowIndex= rowIndex;\n            }\n            grid[rowIndex].erase(maxElementIterator);\n        }\n\n        totalMaxValue+= currentMaxValue;\n        if(grid[maxRowIndex].empty())\n        {\n            grid.erase(grid.begin() + maxRowIndex);\n        }\n    }\n\n    return totalMaxValue;\n}",
    "output": "#include <vector>\n#include <algorithm>\n\nint MaxValueAfterOperations(std::vector<std::vector<int>> &grid)\n{\n    int total_max_value= 0;\n    while(!grid.empty())\n    {\n        int current_max_value= 0, max_row_index= -1;\n\n        for(int row_index= 0; row_index < grid.size(); ++row_index)\n        {\n            auto max_element_iterator= std::max_element(grid[row_index].begin(), grid[row_index].end());\n            if(*max_element_iterator > current_max_value)\n            {\n                current_max_value= *max_element_iterator;\n                max_row_index= row_index;\n            }\n            grid[row_index].erase(max_element_iterator);\n        }\n\n        total_max_value+= current_max_value;\n        if(grid[max_row_index].empty())\n        {\n            grid.erase(grid.begin() + max_row_index);\n        }\n    }\n\n    return total_max_value;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint longestSquareStreak(vector<int> &numberList)\n{\n    unordered_set<int> numberSet(numberList.begin(), numberList.end());\n    int longestStreak = -1;\n\n    for (auto it = numberSet.begin(); it != numberSet.end(); ++it)\n    {\n        int currentNumber = *it;\n        int currentStreak = 1;\n\n        while (numberSet.count(static_cast<int>(pow(currentNumber, 0.5))) > 0)\n        {\n            ++currentStreak;\n            currentNumber = static_cast<int>(pow(currentNumber, 0.5));\n        }\n\n        longestStreak = max(longestStreak, currentStreak);\n    }\n\n    return longestStreak >= 2 ? longestStreak : -1;\n}",
    "output": "#include <algorithm>\n#include <cmath>\n#include <unordered_set>\n\nint LongestSquareStreak(std::vector<int> &numberList)\n{\n    std::unordered_set<int> number_set(numberList.begin(), numberList.end());\n    int longest_streak= -1;\n\n    for(int current_number : number_set)\n    {\n        int current_streak= 1;\n\n        while(number_set.count(static_cast<int>(std::pow(current_number, 0.5))) > 0)\n        {\n            ++current_streak;\n            current_number= static_cast<int>(std::pow(current_number, 0.5));\n        }\n\n        longest_streak= std::max(longest_streak, current_streak);\n    }\n\n    return longest_streak >= 2 ? longest_streak : -1;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Allocator\n{\n    vector<int> memory;\n\n  public:\n    Allocator(int size) : memory(size, 0) {}\n\n    int allocate(int blockSize, int memoryId)\n    {\n        int startIndex= -1, freeCount= 0;\n        for(int i= 0; i <= memory.size(); ++i)\n        {\n            if(i < memory.size() && memory[i] == 0)\n            {\n                if(startIndex == -1)\n                    startIndex= i;\n                freeCount++;\n            }\n            else\n            {\n                if(freeCount >= blockSize)\n                {\n                    fill(memory.begin() + startIndex, memory.begin() + startIndex + blockSize, memoryId);\n                    return startIndex;\n                }\n                startIndex= -1;\n                freeCount= 0;\n            }\n        }\n        return -1;\n    }\n\n    int free(int memoryId)\n    {\n        int freedCount= 0;\n        for(int i= 0; i < memory.size(); ++i)\n        {\n            if(memory[i] == memoryId)\n            {\n                freedCount++;\n                memory[i]= 0;\n            }\n        }\n        return freedCount;\n    }\n};",
    "output": "#include <vector>\n#include <algorithm> // for std::fill\n\nclass Allocator\n{\n    std::vector<int> memory;\n\n  public:\n    Allocator(int size) : memory(size, 0) {}\n\n    int Allocate(int blockSize, int memoryId)\n    {\n        int start_index= -1, free_count= 0;\n        for(int i= 0; i <= memory.size(); ++i)\n        {\n            if(i < memory.size() && memory[i] == 0)\n            {\n                if(start_index == -1)\n                    start_index= i;\n                free_count++;\n            }\n            else\n            {\n                if(free_count >= blockSize)\n                {\n                    std::fill(memory.begin() + start_index, memory.begin() + start_index + blockSize, memoryId);\n                    return start_index;\n                }\n                start_index= -1;\n                free_count= 0;\n            }\n        }\n        return -1;\n    }\n\n    int Free(int memoryId)\n    {\n        int freed_count= 0;\n        for(int i= 0; i < memory.size(); ++i)\n        {\n            if(memory[i] == memoryId)\n            {\n                freed_count++;\n                memory[i]= 0;\n            }\n        }\n        return freed_count;\n    }\n};"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> traverseMatrix(vector<vector<int>> &grid, const vector<int> &queries, int rows, int columns)\n{\n    vector<int> directionX= {-1, 0, 1, 0};\n    vector<int> directionY= {0, 1, 0, -1};\n    vector<int> result(queries.size(), 0);\n\n    for(int queryIndex= 0; queryIndex < queries.size(); ++queryIndex)\n    {\n        int queryValue= queries[queryIndex];\n        int pointsCount= 0;\n        set<pair<int, int>> visitedCells;\n\n        function<void(int, int)> depthFirstSearch= [&](int currentX, int currentY)\n        {\n            if(visitedCells.find({currentX, currentY}) == visitedCells.end() && grid[currentX][currentY] < queryValue)\n            {\n                visitedCells.insert({currentX, currentY});\n                pointsCount++;\n                for(int directionIndex= 0; directionIndex < 4; ++directionIndex)\n                {\n                    int nextX= currentX + directionX[directionIndex], nextY= currentY + directionY[directionIndex];\n                    if(nextX >= 0 && nextX < rows && nextY >= 0 && nextY < columns)\n                    {\n                        depthFirstSearch(nextX, nextY);\n                    }\n                }\n            }\n        };\n\n        depthFirstSearch(0, 0);\n        result[queryIndex]= pointsCount;\n    }\n\n    return result;\n}\n\nvector<int> maxPoints(vector<vector<int>> &grid, vector<int> &queries)\n{\n    int rows= grid.size();\n    int columns= grid[0].size();\n    return traverseMatrix(grid, queries, rows, columns);\n}",
    "output": "#include <set>\n#include <utility>\n#include <vector>\n#include <functional>\n\nstd::vector<int> TraverseMatrix(std::vector<std::vector<int>> &grid, const std::vector<int> &queries, int rows, int columns)\n{\n    std::vector<int> direction_x= {-1, 0, 1, 0};\n    std::vector<int> direction_y= {0, 1, 0, -1};\n    std::vector<int> result(queries.size(), 0);\n\n    for(int query_index= 0; query_index < queries.size(); ++query_index)\n    {\n        int query_value= queries[query_index];\n        int points_count= 0;\n        std::set<std::pair<int, int>> visited_cells;\n\n        std::function<void(int, int)> depth_first_search= [&](int currentX, int currentY)\n        {\n            if(visited_cells.find({currentX, currentY}) == visited_cells.end() && grid[currentX][currentY] < query_value)\n            {\n                visited_cells.insert({currentX, currentY});\n                points_count++;\n                for(int direction_index= 0; direction_index < 4; ++direction_index)\n                {\n                    int next_x= currentX + direction_x[direction_index], next_y= currentY + direction_y[direction_index];\n                    if(next_x >= 0 && next_x < rows && next_y >= 0 && next_y < columns)\n                    {\n                        depth_first_search(next_x, next_y);\n                    }\n                }\n            }\n        };\n\n        depth_first_search(0, 0);\n        result[query_index]= points_count;\n    }\n\n    return result;\n}\n\nstd::vector<int> MaxPoints(std::vector<std::vector<int>> &grid, std::vector<int> &queries)\n{\n    int rows= grid.size();\n    int columns= grid[0].size();\n    return TraverseMatrix(grid, queries, rows, columns);\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint subsequenceOrSum(vector<int> &numbers)\n{\n    int orResult = 0;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int currentNumber = numbers[i];\n        orResult |= currentNumber;\n    }\n    return orResult;\n}",
    "output": "#include <vector>\n\nint SubsequenceOrSum(std::vector<int> &numbers)\n{\n    int or_result= 0;\n    for(int current_number : numbers)\n    {\n        or_result |= current_number;\n    }\n    return or_result;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countSimilarPairs(vector<string> &wordList)\n{\n    int similarPairCount = 0;\n    for(int firstIndex = 0; firstIndex < wordList.size(); ++firstIndex)\n    {\n        for(int secondIndex = firstIndex + 1; secondIndex < wordList.size(); ++secondIndex)\n        {\n            unordered_set<char> firstWordSet{wordList[firstIndex].begin(), wordList[firstIndex].end()};\n            unordered_set<char> secondWordSet{wordList[secondIndex].begin(), wordList[secondIndex].end()};\n            if(firstWordSet == secondWordSet)\n                similarPairCount++;\n        }\n    }\n    return similarPairCount;\n}",
    "output": "#include <string>\n#include <unordered_set>\n#include <vector>\n\nint CountSimilarPairs(std::vector<std::string> &wordList)\n{\n    int similar_pair_count= 0;\n    for(int first_index= 0; first_index < wordList.size(); ++first_index)\n    {\n        for(int second_index= first_index + 1; second_index < wordList.size(); ++second_index)\n        {\n            std::unordered_set<char> first_word_set{wordList[first_index].begin(), wordList[first_index].end()};\n            std::unordered_set<char> second_word_set{wordList[second_index].begin(), wordList[second_index].end()};\n            if(first_word_set == second_word_set)\n                similar_pair_count++;\n        }\n    }\n    return similar_pair_count;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "int smallestFactorization(int number)\n{\n    if(number <= 3)\n        return number;\n    int factorizationResult= 0, factorMultiplier= 1;\n    for(int currentFactor= 2; currentFactor <= 5; ++currentFactor)\n    {\n        while(number % currentFactor == 0)\n        {\n            factorizationResult+= factorMultiplier * currentFactor;\n            factorMultiplier*= 10;\n            number/= currentFactor;\n        }\n    }\n    return number == 1 ? factorizationResult : number;\n}",
    "output": "int SmallestFactorization(int number)\n{\n    if(number <= 3)\n        return number;\n    int factorization_result= 0, factor_multiplier= 1;\n    for(int current_factor= 2; current_factor <= 5; ++current_factor)\n    {\n        while(number % current_factor == 0)\n        {\n            factorization_result+= factor_multiplier * current_factor;\n            factor_multiplier*= 10;\n            number/= current_factor;\n        }\n    }\n    return number == 1 ? factorization_result : number;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPossibleDegreeEven(int numberOfVertices, vector<vector<int>> &edges)\n{\n    vector<int> vertexDegrees(numberOfVertices + 1, 0);\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        vertexDegrees[edges[i][0]]++;\n        vertexDegrees[edges[i][1]]++;\n    }\n\n    int oddDegreeCount = 0;\n    for (int index = 1; index <= numberOfVertices; index++)\n    {\n        if (vertexDegrees[index] % 2 != 0)\n            oddDegreeCount++;\n    }\n\n    return (oddDegreeCount == 0 || oddDegreeCount == 2);\n}",
    "output": "#include <vector>\n\nbool IsPossibleDegreeEven(int numberOfVertices, std::vector<std::vector<int>> &edges)\n{\n    std::vector<int> vertex_degrees(numberOfVertices + 1, 0);\n    for(const auto &edge : edges)\n    {\n        vertex_degrees[edge[0]]++;\n        vertex_degrees[edge[1]]++;\n    }\n\n    int odd_degree_count= 0;\n    for(int index= 1; index <= numberOfVertices; index++)\n    {\n        if(vertex_degrees[index] % 2 != 0)\n            odd_degree_count++;\n    }\n\n    return (odd_degree_count == 0 || odd_degree_count == 2);\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> lengthOfCycle(int numberOfNodes, const vector<vector<int>> &queries)\n{\n    vector<int> cycleLengths;\n    for (int i = 0; i < queries.size(); ++i)\n    {\n        const auto &query = queries[i];\n        int depthA = 0, depthB = 0, nodeA = query[0], nodeB = query[1];\n        while (nodeA != nodeB)\n        {\n            if (nodeA < nodeB)\n                swap(nodeA, nodeB);\n            nodeA >>= 1;\n            depthA++;\n        }\n        cycleLengths.push_back(depthA + depthB);\n    }\n    return cycleLengths;\n}",
    "output": "#include <vector>\n\nstd::vector<int> LengthOfCycle(int numberOfNodes, const std::vector<std::vector<int>> &queries)\n{\n    std::vector<int> cycle_lengths;\n    for(const auto &query : queries)\n    {\n        int depth_a= 0, depth_b= 0, node_a= query[0], node_b= query[1];\n        while(node_a != node_b)\n        {\n            if(node_a < node_b)\n                std::swap(node_a, node_b);\n            node_a>>= 1;\n            depth_a++;\n        }\n        cycle_lengths.push_back(depth_a + depth_b);\n    }\n    return cycle_lengths;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isValidPath(vector<vector<int>> &grid, int currentRow, int currentCol, int zeroCount, int oneCount)\n{\n    if(currentRow < 0 || currentCol < 0 || currentRow >= grid.size() || currentCol >= grid[0].size())\n    {\n        return false;\n    }\n    if(grid[currentRow][currentCol] == 1)\n    {\n        oneCount++;\n    }\n    else\n    {\n        zeroCount++;\n    }\n    if(currentRow == grid.size() - 1 && currentCol == grid[0].size() - 1)\n    {\n        return zeroCount == oneCount;\n    }\n    return isValidPath(grid, currentRow + 1, currentCol, zeroCount, oneCount) || isValidPath(grid, currentRow, currentCol + 1, zeroCount, oneCount);\n}\n\nbool equalPath(vector<vector<int>> &grid)\n{\n    return isValidPath(grid, 0, 0, 0, 0);\n}",
    "output": "#include <vector>\n\nbool IsValidPath(std::vector<std::vector<int>> &grid, int currentRow, int currentCol, int zeroCount, int oneCount)\n{\n    if(currentRow < 0 || currentCol < 0 || currentRow >= grid.size() || currentCol >= grid[0].size())\n    {\n        return false;\n    }\n    if(grid[currentRow][currentCol] == 1)\n    {\n        oneCount++;\n    }\n    else\n    {\n        zeroCount++;\n    }\n    if(currentRow == grid.size() - 1 && currentCol == grid[0].size() - 1)\n    {\n        return zeroCount == oneCount;\n    }\n    return IsValidPath(grid, currentRow + 1, currentCol, zeroCount, oneCount) || IsValidPath(grid, currentRow, currentCol + 1, zeroCount, oneCount);\n}\n\nbool EqualPath(std::vector<std::vector<int>> &grid)\n{\n    return IsValidPath(grid, 0, 0, 0, 0);\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxCapturedForts(vector<int> &forts)\n{\n    int totalForts= forts.size();\n    int maxCapture= 0;\n    for(int currentFort= 0; currentFort < totalForts; currentFort++)\n    {\n        if(forts[currentFort] == 1)\n        {\n            for(int nextFort= currentFort + 1; nextFort < totalForts; nextFort++)\n            {\n                if(forts[nextFort] != -1)\n                {\n                    int captureCount= 0;\n                    for(int intermediateFort= currentFort + 1; intermediateFort < nextFort; intermediateFort++)\n                    {\n                        if(forts[intermediateFort] == 0)\n                            captureCount++;\n                    }\n                    if(forts[nextFort] == 1)\n                        maxCapture= max(maxCapture, captureCount);\n                }\n            }\n        }\n    }\n    return maxCapture;\n}",
    "output": "#include <vector>\n#include <algorithm>\n\nint MaxCapturedForts(std::vector<int> &forts)\n{\n    int total_forts= forts.size();\n    int max_capture= 0;\n    for(int current_fort= 0; current_fort < total_forts; current_fort++)\n    {\n        if(forts[current_fort] == 1)\n        {\n            for(int next_fort= current_fort + 1; next_fort < total_forts; next_fort++)\n            {\n                if(forts[next_fort] != -1)\n                {\n                    int capture_count= 0;\n                    for(int intermediate_fort= current_fort + 1; intermediate_fort < next_fort; intermediate_fort++)\n                    {\n                        if(forts[intermediate_fort] == 0)\n                            capture_count++;\n                    }\n                    if(forts[next_fort] == 1)\n                        max_capture= std::max(max_capture, capture_count);\n                }\n            }\n        }\n    }\n    return max_capture;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> topKStudents(const vector<string> &positiveFeedback,\n                          const vector<string> &negativeFeedback,\n                          const vector<string> &reports,\n                          const vector<int> &studentIds,\n                          int k)\n{\n    unordered_map<int, int> studentPoints;\n    for(size_t i = 0; i < reports.size(); ++i)\n    {\n        int positiveCount = 0, negativeCount = 0;\n        for(size_t j = 0; j < positiveFeedback.size(); ++j)\n        {\n            const auto &positive = positiveFeedback[j];\n            size_t positiveIndex = reports[i].find(positive);\n            while(positiveIndex != string::npos)\n            {\n                ++positiveCount;\n                positiveIndex = reports[i].find(positive, positiveIndex + positive.length());\n            }\n        }\n        for(size_t j = 0; j < negativeFeedback.size(); ++j)\n        {\n            const auto &negative = negativeFeedback[j];\n            size_t negativeIndex = reports[i].find(negative);\n            while(negativeIndex != string::npos)\n            {\n                ++negativeCount;\n                negativeIndex = reports[i].find(negative, negativeIndex + negative.length());\n            }\n        }\n        studentPoints[studentIds[i]] += 3 * positiveCount - negativeCount;\n    }\n\n    vector<int> students(studentIds.begin(), studentIds.end());\n    sort(students.begin(), students.end(), [&studentPoints](int a, int b)\n         { return studentPoints[a] != studentPoints[b] ? studentPoints[a] > studentPoints[b] : a < b; });\n\n    return vector<int>(students.begin(), students.begin() + k);\n}",
    "output": "#include <algorithm>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\nstd::vector<int> TopKStudents(const std::vector<std::string> &positiveFeedback,\n                              const std::vector<std::string> &negativeFeedback,\n                              const std::vector<std::string> &reports,\n                              const std::vector<int> &studentIds,\n                              int k)\n{\n    std::unordered_map<int, int> student_points;\n    for(size_t i= 0; i < reports.size(); ++i)\n    {\n        int positive_count= 0, negative_count= 0;\n        for(const auto &positive : positiveFeedback)\n        {\n            size_t positive_index= reports[i].find(positive);\n            while(positive_index != std::string::npos)\n            {\n                ++positive_count;\n                positive_index= reports[i].find(positive, positive_index + positive.length());\n            }\n        }\n        for(const auto &negative : negativeFeedback)\n        {\n            size_t negative_index= reports[i].find(negative);\n            while(negative_index != std::string::npos)\n            {\n                ++negative_count;\n                negative_index= reports[i].find(negative, negative_index + negative.length());\n            }\n        }\n        student_points[studentIds[i]]+= 3 * positive_count - negative_count;\n    }\n\n    std::vector<int> students(studentIds.begin(), studentIds.end());\n    std::sort(students.begin(), students.end(), [&student_points](int a, int b)\n              { return student_points[a] != student_points[b] ? student_points[a] > student_points[b] : a < b; });\n\n    return std::vector<int>(students.begin(), students.begin() + k);\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "int calculateMinimumPossibleMax(int divisor1, int divisor2, int uniqueCount1, int uniqueCount2)\n{\n    return (divisor1 - 1) * uniqueCount1 + (divisor2 - 1) * uniqueCount2 + 1;\n}",
    "output": "int CalculateMinimumPossibleMax(int divisor1, int divisor2, int uniqueCount1, int uniqueCount2)\n{\n    return (divisor1 - 1) * uniqueCount1 + (divisor2 - 1) * uniqueCount2 + 1;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\n// For std::min\nusing namespace std;\n\nint shortestDistance(vector<string> &words, string target, int startIndex)\n{\n    int totalWords = words.size();\n    int leftDistance = 0, rightDistance = 0, currentIndex = startIndex;\n    while(true)\n    {\n        if(words[currentIndex] == target)\n        {\n            return min(leftDistance, rightDistance);\n        }\n        leftDistance++;\n        rightDistance++;\n        currentIndex = (currentIndex + 1) % totalWords;\n        if(leftDistance == totalWords)\n        {\n            break;\n        }\n    }\n    return -1;\n}",
    "output": "#include <string>\n#include <vector>\n#include <algorithm>\n\nint ShortestDistance(std::vector<std::string> &words, std::string target, int startIndex)\n{\n    int total_words= words.size();\n    int left_distance= 0, right_distance= 0, current_index= startIndex;\n    while(true)\n    {\n        if(words[current_index] == target)\n        {\n            return std::min(left_distance, right_distance);\n        }\n        left_distance++;\n        right_distance++;\n        current_index= (current_index + 1) % total_words;\n        if(left_distance == total_words)\n        {\n            break;\n        }\n    }\n    return -1;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minMinutes(string inputString, int requiredCount)\n{\n    int stringLength = inputString.length();\n    vector<int> leftCharacterCounts(3, 0), rightCharacterCounts(3, 0);\n    for (int i = 0; i < stringLength; ++i)\n        rightCharacterCounts[inputString[i] - 'a']++;\n\n    int minimumMinutes = stringLength, totalCount = 0;\n    while (true)\n    {\n        int leftIndex = 0, rightIndex = stringLength - 1;\n        while (leftIndex < rightIndex && leftCharacterCounts[inputString[leftIndex] - 'a'] < requiredCount && rightCharacterCounts[inputString[rightIndex] - 'a'] < requiredCount)\n        {\n            int neededLeft = max(0, requiredCount - leftCharacterCounts[inputString[leftIndex] - 'a']);\n            int neededRight = max(0, requiredCount - rightCharacterCounts[inputString[rightIndex] - 'a']);\n            if (neededLeft <= neededRight)\n            {\n                totalCount += neededLeft;\n                leftCharacterCounts[inputString[leftIndex] - 'a'] += neededLeft; // Fixed increment\n                rightCharacterCounts[inputString[leftIndex] - 'a'] -= neededLeft; // Fixed decrement\n                leftIndex++;\n            }\n            else\n            {\n                totalCount += neededRight;\n                rightCharacterCounts[inputString[rightIndex] - 'a'] -= neededRight; // Fixed decrement\n                leftCharacterCounts[inputString[rightIndex] - 'a'] += neededRight; // Fixed increment\n                rightIndex--;\n            }\n        }\n        minimumMinutes = min(minimumMinutes, totalCount);\n        if (leftIndex + 1 < inputString.length())\n        {\n            totalCount -= leftCharacterCounts[inputString[leftIndex] - 'a'];\n            leftCharacterCounts[inputString[leftIndex] - 'a']--;\n            rightCharacterCounts[inputString[leftIndex + 1] - 'a']++;\n            leftIndex++;\n        }\n        else\n            break;\n    }\n    if (leftCharacterCounts[0] >= requiredCount && leftCharacterCounts[1] >= requiredCount && leftCharacterCounts[2] >= requiredCount)\n        return minimumMinutes;\n    return -1;\n}",
    "output": "#include <algorithm>\n#include <string>\n#include <vector>\n\nint MinMinutes(std::string inputString, int requiredCount)\n{\n    int string_length= inputString.length();\n    std::vector<int> left_character_counts(3, 0), right_character_counts(3, 0);\n    for(char character : inputString)\n        right_character_counts[character - 'a']++;\n\n    int minimum_minutes= string_length, total_count= 0;\n    while(true)\n    {\n        int left_index= 0, right_index= string_length - 1;\n        while(left_index < right_index && left_character_counts[inputString[left_index] - 'a'] < requiredCount && right_character_counts[inputString[right_index] - 'a'] < requiredCount)\n        {\n            int needed_left= std::max(0, requiredCount - left_character_counts[inputString[left_index] - 'a']);\n            int needed_right= std::max(0, requiredCount - right_character_counts[inputString[right_index] - 'a']);\n            if(needed_left <= needed_right)\n            {\n                total_count+= needed_left;\n                left_index++;\n                left_character_counts[inputString[left_index] - 'a']++;\n                right_character_counts[inputString[left_index] - 'a']--;\n            }\n            else\n            {\n                total_count+= needed_right;\n                right_index--;\n                right_character_counts[inputString[right_index] - 'a']--;\n                left_character_counts[inputString[right_index] - 'a']++;\n            }\n        }\n        minimum_minutes= std::min(minimum_minutes, total_count);\n        if(left_index + 1 < inputString.length())\n        {\n            total_count-= left_character_counts[inputString[left_index] - 'a'];\n            left_character_counts[inputString[left_index] - 'a']--;\n            right_character_counts[inputString[left_index + 1] - 'a']++;\n            left_index++;\n        }\n        else\n            break;\n    }\n    if(left_character_counts[0] >= requiredCount && left_character_counts[1] >= requiredCount && left_character_counts[2] >= requiredCount)\n        return minimum_minutes;\n    return -1;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMaxTastiness(vector<int> &prices, int numberOfItems)\n{\n    sort(prices.begin(), prices.end());\n    int maxTastiness= 0;\n    for(int i= 0; i < prices.size() - numberOfItems + 1; i++)\n    {\n        int minDifference= INT_MAX;\n        for(int j= i; j < i + numberOfItems - 1; j++)\n        {\n            minDifference= min(minDifference, prices[j + 1] - prices[j]);\n        }\n        maxTastiness= max(maxTastiness, minDifference);\n    }\n\n    return maxTastiness;\n}",
    "output": "#include <vector>\n#include <algorithm>\n#include <limits>\n\nint CalculateMaxTastiness(std::vector<int> &prices, int numberOfItems)\n{\n    std::sort(prices.begin(), prices.end());\n    int max_tastiness= 0;\n    for(int i= 0; i < prices.size() - numberOfItems + 1; i++)\n    {\n        int min_difference= std::numeric_limits<int>::max();\n        for(int j= i; j < i + numberOfItems - 1; j++)\n        {\n            min_difference= std::min(min_difference, prices[j + 1] - prices[j]);\n        }\n        max_tastiness= std::max(max_tastiness, min_difference);\n    }\n\n    return max_tastiness;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countPartitions(vector<int> &numbers, int target)\n{\n    long long totalSum = 0;\n    int size = numbers.size();\n    int modulus = 1000000007;\n\n    for (int i = 0; i < size; ++i)\n    {\n        totalSum += numbers[i];\n    }\n\n    if (totalSum < target * 2)\n    {\n        return 0;\n    }\n\n    vector<long long> dynamicProgramming(size + 1, 1);\n\n    for (int i = 1; i <= target - 1; i++)\n    {\n        for (int j = size - 1; j >= 1; j--)\n        {\n            dynamicProgramming[j] = (dynamicProgramming[j] * j + dynamicProgramming[j - 1]) % modulus;\n        }\n    }\n\n    long long result = 0;\n\n    for (int i = 0; i < size - 1; i++)\n    {\n        totalSum -= numbers[i];\n        if (totalSum >= target)\n        {\n            result = (result + dynamicProgramming[i + 1]) % modulus;\n        }\n    }\n\n    return (int)result;\n}",
    "output": "#include <vector>\n\nint CountPartitions(std::vector<int> &numbers, int target)\n{\n    long long total_sum= 0;\n    int size= numbers.size();\n    int modulus= 1000000007;\n\n    for(int number : numbers)\n    {\n        total_sum+= number;\n    }\n\n    if(total_sum < target * 2)\n    {\n        return 0;\n    }\n\n    std::vector<long long> dynamic_programming(size + 1, 1);\n\n    for(int i= 1; i <= target - 1; i++)\n    {\n        for(int j= size - 1; j >= 1; j--)\n        {\n            dynamic_programming[j]= (dynamic_programming[j] * j + dynamic_programming[j - 1]) % modulus;\n        }\n    }\n\n    long long result= 0;\n\n    for(int i= 0; i < size - 1; i++)\n    {\n        total_sum-= numbers[i];\n        if(total_sum >= target)\n        {\n            result= (result + dynamic_programming[i + 1]) % modulus;\n        }\n    }\n\n    return (int)result;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countKBigIndices(vector<int> &numbers, int threshold)\n{\n    int size= numbers.size();\n    vector<int> leftIndices(size, 0), rightIndices(size, 0);\n\n    for(int index= 1; index < size; ++index)\n    {\n        if(numbers[index] > numbers[index - 1])\n            leftIndices[index]= leftIndices[index - 1] + 1;\n\n        int reverseIndex= size - index - 1;\n        if(reverseIndex + 1 < size && numbers[reverseIndex] < numbers[reverseIndex + 1]) // Ensure we don't go out of bounds\n            rightIndices[reverseIndex]= rightIndices[reverseIndex + 1] + 1;\n    }\n\n    int totalCount= 0;\n    for(int index= 0; index < size; ++index)\n        if(leftIndices[index] >= threshold && rightIndices[index] >= threshold)\n            totalCount++;\n\n    return totalCount;\n}",
    "output": "#include <vector>\n\nint CountKBigIndices(std::vector<int> &numbers, int threshold)\n{\n    int size= numbers.size();\n    std::vector<int> left_indices(size, 0), right_indices(size, 0);\n\n    for(int index= 1; index < size; ++index)\n    {\n        if(numbers[index] > numbers[index - 1])\n            left_indices[index]= left_indices[index - 1] + 1;\n\n        int reverse_index= size - index - 1;\n        if(reverse_index + 1 < size && numbers[reverse_index] < numbers[reverse_index + 1])\n            right_indices[reverse_index]= right_indices[reverse_index + 1] + 1;\n    }\n\n    int total_count= 0;\n    for(int index= 0; index < size; ++index)\n        if(left_indices[index] >= threshold && right_indices[index] >= threshold)\n            total_count++;\n\n    return total_count;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "int countDigitsDividingNumber(int inputNumber)\n{\n    int divisorCount= 0, tempNumber= inputNumber;\n    while(tempNumber > 0)\n    {\n        int currentDigit= tempNumber % 10;\n        if(inputNumber % currentDigit == 0)\n        {\n            divisorCount++;\n        }\n        tempNumber/= 10;\n    }\n    return divisorCount;\n}",
    "output": "int CountDigitsDividingNumber(int inputNumber)\n{\n    int divisor_count= 0, temp_number= inputNumber;\n    while(temp_number > 0)\n    {\n        int current_digit= temp_number % 10;\n        if(inputNumber % current_digit == 0)\n        {\n            divisor_count++;\n        }\n        temp_number/= 10;\n    }\n    return divisor_count;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countDistinctPrimeFactors(const vector<int> &numbers)\n{\n    set<int> distinctPrimeFactors;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int number = numbers[i];\n        for (int divisor = 2; divisor * divisor <= number; ++divisor)\n        {\n            if (number % divisor == 0)\n            {\n                distinctPrimeFactors.insert(divisor);\n                distinctPrimeFactors.insert(number / divisor);\n            }\n        }\n    }\n    return distinctPrimeFactors.size();\n}",
    "output": "#include <set>\n\nint CountDistinctPrimeFactors(const std::vector<int> &numbers)\n{\n    std::set<int> distinct_prime_factors;\n    for(const int number : numbers)\n    {\n        for(int divisor= 2; divisor * divisor <= number; ++divisor)\n        {\n            if(number % divisor == 0)\n            {\n                distinct_prime_factors.insert(divisor);\n                distinct_prime_factors.insert(number / divisor);\n            }\n        }\n    }\n    return distinct_prime_factors.size();\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minPartitions(string numberString, int maxValue)\n{\n    int stringLength= numberString.size();\n    int partitionCount= 0, currentIndex= 0;\n\n    while(currentIndex < stringLength)\n    {\n        int currentValue= 0;\n        // Make sure the currentValue is below maxValue\n        while(currentIndex < stringLength && currentValue * 10 + (numberString[currentIndex] - '0') <= maxValue)\n        {\n            currentValue= currentValue * 10 + (numberString[currentIndex] - '0');\n            currentIndex++;\n        }\n\n        if(currentValue == 0)\n            return -1;\n        partitionCount++;\n    }\n\n    return partitionCount;\n}",
    "output": "#include <string>\n\nint MinPartitions(std::string numberString, int maxValue)\n{\n    int string_length= numberString.size();\n    int partition_count= 0, current_index= 0;\n\n    while(current_index < string_length)\n    {\n        int current_value= 0;\n        // Make sure the currentValue is below maxValue\n        while(current_index < string_length && current_value * 10 + (numberString[current_index] - '0') <= maxValue)\n        {\n            current_value= current_value * 10 + (numberString[current_index] - '0');\n            current_index++;\n        }\n\n        if(current_value == 0)\n            return -1;\n        partition_count++;\n    }\n\n    return partition_count;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPrime(int number)\n{\n    if(number <= 1)\n        return false;\n    for(int divisor= 2; divisor * divisor <= number; ++divisor)\n    {\n        if(number % divisor == 0)\n            return false;\n    }\n    return true;\n}\n\nvector<int> closestPrimePair(int rangeStart, int rangeEnd)\n{\n    int minimumDistance= rangeEnd - rangeStart + 1;\n    vector<int> result= {-1, -1};\n    for(int currentNumber= rangeStart; currentNumber <= rangeEnd; ++currentNumber)\n    {\n        if(isPrime(currentNumber))\n        {\n            for(int nextNumber= currentNumber + 1; nextNumber <= rangeEnd; ++nextNumber)\n            {\n                if(isPrime(nextNumber) && nextNumber - currentNumber < minimumDistance)\n                {\n                    minimumDistance= nextNumber - currentNumber;\n                    result= {currentNumber, nextNumber};\n                }\n            }\n        }\n    }\n    return result;\n}",
    "output": "#include <vector>\n\nbool IsPrime(int number)\n{\n    if(number <= 1)\n        return false;\n    for(int divisor= 2; divisor * divisor <= number; ++divisor)\n    {\n        if(number % divisor == 0)\n            return false;\n    }\n    return true;\n}\n\nstd::vector<int> ClosestPrimePair(int rangeStart, int rangeEnd)\n{\n    int minimum_distance= rangeEnd - rangeStart + 1;\n    std::vector<int> result= {-1, -1};\n    for(int current_number= rangeStart; current_number <= rangeEnd; ++current_number)\n    {\n        if(IsPrime(current_number))\n        {\n            for(int next_number= current_number + 1; next_number <= rangeEnd; ++next_number)\n            {\n                if(IsPrime(next_number) && next_number - current_number < minimum_distance)\n                {\n                    minimum_distance= next_number - current_number;\n                    result= {current_number, next_number};\n                }\n            }\n        }\n    }\n    return result;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxFrequencyScore(vector<int> &numbers, int k)\n{\n    int size= numbers.size();\n    int rightIndex= 0, currentCount= 0, maxScore= 0;\n    long long currentScore= 0;\n    unordered_map<int, int> frequencyMap;\n\n    for(int leftIndex= 0; leftIndex < size; ++leftIndex)\n    {\n        while(rightIndex < size && currentCount < k)\n        {\n            currentScore= (currentScore + (long long)numbers[rightIndex] * frequencyMap[numbers[rightIndex]]) % 1000000007;\n            frequencyMap[numbers[rightIndex]]++;\n            currentCount++;\n            rightIndex++;\n        }\n\n        maxScore= max(maxScore, (int)currentScore);\n\n        if(currentCount == k)\n        {\n            currentScore-= numbers[leftIndex] * (frequencyMap[numbers[leftIndex]] - 1);\n            frequencyMap[numbers[leftIndex]]--;\n            currentCount--;\n        }\n    }\n\n    return maxScore;\n}",
    "output": "#include <unordered_map>\n#include <vector>\n\nint MaxFrequencyScore(std::vector<int> &numbers, int k)\n{\n    int size= numbers.size();\n    int right_index= 0, current_count= 0, max_score= 0;\n    long long current_score= 0;\n    std::unordered_map<int, int> frequency_map;\n\n    for(int left_index= 0; left_index < size; ++left_index)\n    {\n        while(right_index < size && current_count < k)\n        {\n            current_score= (current_score + (long long)numbers[right_index] * frequency_map[numbers[right_index]]) % 1000000007;\n            frequency_map[numbers[right_index]]++;\n            current_count++;\n            right_index++;\n        }\n\n        max_score= std::max(max_score, (int)current_score);\n\n        if(current_count == k)\n        {\n            current_score-= numbers[left_index] * (frequency_map[numbers[left_index]] - 1);\n            frequency_map[numbers[left_index]]--;\n            current_count--;\n        }\n    }\n\n    return max_score;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring getBoxCategory(int boxLength, int boxWidth, int boxHeight, int boxMass)\n{\n    bool isBulky= boxLength >= 10000 || boxWidth >= 10000 || boxHeight >= 10000 || (long)boxLength * boxWidth * boxHeight >= 1000000000;\n    bool isHeavy= boxMass >= 100;\n\n    if(isBulky && isHeavy)\n        return \"Both \";\n    if(isBulky)\n        return \"Bulky \";\n    if(isHeavy)\n        return \"Heavy \";\n    return \"Neither \";\n}",
    "output": "#include <string>\n\nstd::string GetBoxCategory(int boxLength, int boxWidth, int boxHeight, int boxMass)\n{\n    bool is_bulky= boxLength >= 10000 || boxWidth >= 10000 || boxHeight >= 10000 || (long)boxLength * boxWidth * boxHeight >= 1000000000;\n    bool is_heavy= boxMass >= 100;\n\n    if(is_bulky && is_heavy)\n        return \"Both \";\n    if(is_bulky)\n        return \"Bulky \";\n    if(is_heavy)\n        return \"Heavy \";\n    return \"Neither \";\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass DataStream\n{\n  public:\n    DataStream(int targetValue, int sequenceLength) : targetValue(targetValue), sequenceLength(sequenceLength) {}\n\n    bool consec(int num)\n    {\n        dataStream.push_back(num);\n        if(dataStream.size() > sequenceLength)\n            dataStream.pop_front();\n\n        return dataStream.size() == sequenceLength && count(dataStream.begin(), dataStream.end(), targetValue) == sequenceLength;\n    }\n\n  private:\n    int targetValue;\n    int sequenceLength;\n    deque<int> dataStream;\n};",
    "output": "#include <deque>\n\nclass DataStream\n{\n  public:\n    DataStream(int targetValue, int sequenceLength) : targetValue(targetValue), sequenceLength(sequenceLength) {}\n\n    bool Consec(int num)\n    {\n        data_stream.push_back(num);\n        if(data_stream.size() > sequenceLength)\n            data_stream.pop_front();\n\n        return data_stream.size() == sequenceLength && count(data_stream.begin(), data_stream.end(), targetValue) == sequenceLength;\n    }\n\n  private:\n    int targetValue;\n    int sequenceLength;\n    std::deque<int> data_stream;\n};"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateXorBeauty(vector<int> &inputNumbers)\n{\n    int numberOfElements = inputNumbers.size();\n    int maximumXorValue = 1024; // Maximum value for bitwise operations\n    vector<int> frequencyCounter(maximumXorValue, 0);\n\n    for (int i = 0; i < numberOfElements; ++i)\n    {\n        frequencyCounter[inputNumbers[i] % maximumXorValue]++;\n    }\n\n    int xorBeautyResult = 0;\n    for (int i = 0; i < maximumXorValue; i++)\n    {\n        for (int j = i; j < maximumXorValue; j++)\n        {\n            int commonBits = (i | j) & (~(i ^ j));\n            if (commonBits < maximumXorValue && commonBits >= j)\n            {\n                int countCombinations = frequencyCounter[i] * frequencyCounter[j] * (i == j ? 1 : 2);\n                if (commonBits != i && commonBits != j)\n                {\n                    countCombinations *= frequencyCounter[commonBits];\n                }\n                xorBeautyResult ^= countCombinations;\n            }\n        }\n    }\n\n    return xorBeautyResult;\n}",
    "output": "#include <vector>\n\nint CalculateXorBeauty(std::vector<int> &inputNumbers)\n{\n    int number_of_elements= inputNumbers.size();\n    int maximum_xor_value= 1024; // Maximum value for bitwise operations\n    std::vector<int> frequency_counter(maximum_xor_value, 0);\n\n    for(int current_number : inputNumbers)\n    {\n        frequency_counter[current_number % maximum_xor_value]++;\n    }\n\n    int xor_beauty_result= 0;\n    for(int i= 0; i < maximum_xor_value; i++)\n    {\n        for(int j= i; j < maximum_xor_value; j++)\n        {\n            int common_bits= (i | j) & (~(i ^ j));\n            if(common_bits < maximum_xor_value && common_bits >= j)\n            {\n                int count_combinations= frequency_counter[i] * frequency_counter[j] * (i == j ? 1 : 2);\n                if(common_bits != i && common_bits != j)\n                {\n                    count_combinations*= frequency_counter[common_bits];\n                }\n                xor_beauty_result^= count_combinations;\n            }\n        }\n    }\n\n    return xor_beauty_result;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMaxMinPower(vector<int> &stationPowers, int range, int additionalPower)\n{\n    int numberOfStations = stationPowers.size();\n    vector<int> totalPower(numberOfStations);\n    for(int currentStation = 0; currentStation < numberOfStations; currentStation++)\n    {\n        for(int nearbyStation = max(0, currentStation - range); nearbyStation <= min(numberOfStations - 1, currentStation + range); nearbyStation++)\n        {\n            totalPower[nearbyStation] += stationPowers[currentStation];\n        }\n    }\n\n    int sumOfK = 0, minimumPower = INT_MAX;\n    for(int currentIndex = range; currentIndex < numberOfStations - range; currentIndex++)\n    {\n        sumOfK += stationPowers[currentIndex];\n        minimumPower = min(minimumPower, totalPower[currentIndex]);\n    }\n\n    for(int j = 0, i = numberOfStations - 2 * range; j < 2 * range; j++, i--)\n    {\n        sumOfK -= stationPowers[i + range + 1];\n        minimumPower -= stationPowers[j];\n        minimumPower += sumOfK;\n        minimumPower += additionalPower;\n        minimumPower = min(minimumPower, totalPower[j]);\n    }\n\n    return minimumPower;\n}",
    "output": "#include <vector>\n#include <algorithm>\n#include <climits>\n\nint CalculateMaxMinPower(std::vector<int> &stationPowers, int range, int additionalPower)\n{\n    int number_of_stations= stationPowers.size();\n    std::vector<int> total_power(number_of_stations);\n    for(int current_station= 0; current_station < number_of_stations; current_station++)\n    {\n        for(int nearby_station= std::max(0, current_station - range); nearby_station <= std::min(number_of_stations - 1, current_station + range); nearby_station++)\n        {\n            total_power[nearby_station]+= stationPowers[current_station];\n        }\n    }\n\n    int sum_of_k= 0, minimum_power= INT_MAX;\n    for(int current_index= range; current_index < number_of_stations - range; current_index++)\n    {\n        sum_of_k+= stationPowers[current_index];\n        minimum_power= std::min(minimum_power, total_power[current_index]);\n    }\n\n    for(int j= 0, i= number_of_stations - 2 * range; j < 2 * range; j++, i--)\n    {\n        sum_of_k-= stationPowers[i + range + 1];\n        minimum_power-= stationPowers[j];\n        minimum_power+= sum_of_k;\n        minimum_power+= additionalPower;\n        minimum_power= std::min(minimum_power, total_power[j]);\n    }\n\n    return minimum_power;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxPositiveNegativeCount(const vector<int> &numbers)\n{\n    int positiveCount= upper_bound(numbers.begin(), numbers.end(), -1) - numbers.begin();\n    int negativeCount= numbers.size() - positiveCount;\n    return max(positiveCount, negativeCount);\n}",
    "output": "#include <vector>\n#include <algorithm>\n\nint MaxPositiveNegativeCount(const std::vector<int> &numbers)\n{\n    int positive_count = std::upper_bound(numbers.begin(), numbers.end(), -1) - numbers.begin();\n    int negative_count = numbers.size() - positive_count;\n    return std::max(positive_count, negative_count);\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxScore(const vector<int> &numbers, int numberOfPicks)\n{\n    priority_queue<int> maxHeap(numbers.begin(), numbers.end());\n    int totalScore= 0;\n\n    for(int i= 0; i < numberOfPicks; i++)\n    {\n        int currentNumber= maxHeap.top();\n        maxHeap.pop();\n        totalScore+= currentNumber;\n        maxHeap.push(currentNumber / 3);\n    }\n\n    return totalScore;\n}",
    "output": "#include <queue>\n#include <vector>\n\nint MaxScore(const std::vector<int> &numbers, int numberOfPicks)\n{\n    std::priority_queue<int> max_heap(numbers.begin(), numbers.end());\n    int total_score= 0;\n\n    for(int i= 0; i < numberOfPicks; i++)\n    {\n        int current_number= max_heap.top();\n        max_heap.pop();\n        total_score+= current_number;\n        max_heap.push(current_number / 3);\n    }\n\n    return total_score;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool compare(const string &firstWord, const string &secondWord)\n{\n    array<int, 26> letterCountsFirst = {0}, letterCountsSecond = {0};\n    for (int i = 0; i < firstWord.size(); ++i)\n        letterCountsFirst[firstWord[i] - 'a']++;\n    for (int i = 0; i < secondWord.size(); ++i)\n        letterCountsSecond[secondWord[i] - 'a']++;\n    for (int index = 0; index < 26; ++index)\n    {\n        if (letterCountsFirst[index] && letterCountsSecond[index])\n            return true;\n    }\n    return false;\n}\n\nbool swapEqualDistinct(const string &firstWord, const string &secondWord)\n{\n    bool hasCommonLetter = compare(firstWord, secondWord);\n    return hasCommonLetter && firstWord.size() == secondWord.size();\n}",
    "output": "bool Compare(const std::string &firstWord, const std::string &secondWord)\n{\n    std::array<int, 26> letter_counts_first= {0}, letter_counts_second= {0};\n    for(char character : firstWord)\n        letter_counts_first[character - 'a']++;\n    for(char character : secondWord)\n        letter_counts_second[character - 'a']++;\n    for(int index= 0; index < 26; ++index)\n    {\n        if(letter_counts_first[index] && letter_counts_second[index])\n            return true;\n    }\n    return false;\n}\n\nbool SwapEqualDistinct(const std::string &firstWord, const std::string &secondWord)\n{\n    bool has_common_letter= Compare(firstWord, secondWord);\n    return has_common_letter && firstWord.size() == secondWord.size();\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint getLastMoment(int totalMoments, int numElements, vector<vector<int>> &elementTimes)\n{\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> leftQueue, rightQueue;\n    for(int index= 0; index < numElements; index++)\n    {\n        leftQueue.push({elementTimes[index][0] + elementTimes[index][2], index});\n    }\n\n    while(totalMoments)\n    {\n        while(!rightQueue.empty() && rightQueue.top().first <= leftQueue.top().first)\n        {\n            auto rightTopElement= rightQueue.top();\n            rightQueue.pop();\n            leftQueue.push({rightTopElement.first + elementTimes[rightTopElement.second][0] + elementTimes[rightTopElement.second][2], rightTopElement.second});\n        }\n        auto leftTopElement= leftQueue.top();\n        leftQueue.pop();\n        elementTimes[leftTopElement.second][2]+= elementTimes[leftTopElement.second][3] + elementTimes[leftTopElement.second][0] + elementTimes[leftTopElement.second][1];\n        rightQueue.push({leftTopElement.first + elementTimes[leftTopElement.second][1], leftTopElement.second});\n        totalMoments--;\n    }\n\n    int lastMoment= -1;\n    while(!rightQueue.empty())\n    {\n        lastMoment= max(lastMoment, elementTimes[rightQueue.top().second][2]);\n        rightQueue.pop();\n    }\n    return lastMoment;\n}",
    "output": "#include <algorithm>\n#include <queue>\n#include <vector>\n\nint GetLastMoment(int totalMoments, int numElements, std::vector<std::vector<int>> &elementTimes)\n{\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> left_queue, right_queue;\n    for(int index= 0; index < numElements; index++)\n    {\n        left_queue.push({elementTimes[index][0] + elementTimes[index][2], index});\n    }\n\n    while(totalMoments)\n    {\n        while(!right_queue.empty() && right_queue.top().first <= left_queue.top().first)\n        {\n            auto right_top_element= right_queue.top();\n            right_queue.pop();\n            left_queue.push({right_top_element.first + elementTimes[right_top_element.second][0] + elementTimes[right_top_element.second][2], right_top_element.second});\n        }\n        auto left_top_element= left_queue.top();\n        left_queue.pop();\n        elementTimes[left_top_element.second][2]+= elementTimes[left_top_element.second][3] + elementTimes[left_top_element.second][0] + elementTimes[left_top_element.second][1];\n        right_queue.push({left_top_element.first + elementTimes[left_top_element.second][1], left_top_element.second});\n        totalMoments--;\n    }\n\n    int last_moment= -1;\n    while(!right_queue.empty())\n    {\n        last_moment= std::max(last_moment, elementTimes[right_queue.top().second][2]);\n        right_queue.pop();\n    }\n    return last_moment;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\n// for std::max\nusing namespace std;\n\nint countGoodStrings(int minLength, int maxLength, int oneGroupSize, int zeroGroupSize, int modulo = 1000000007)\n{\n    int maxCount = maxLength / oneGroupSize + maxLength / zeroGroupSize;\n\n    vector<long long> dynamicProgramming(maxCount + 1);\n    dynamicProgramming[0] = 1;\n\n    for (int index = 1; index <= maxCount; index++)\n        dynamicProgramming[index] = (dynamicProgramming[index - 1] * (index % oneGroupSize == 0 || index % zeroGroupSize == 0)) % modulo;\n\n    long long result = 0;\n    for (int index = 0; index <= maxCount; index++)\n    {\n        result = (result + dynamicProgramming[minLength / oneGroupSize + minLength / zeroGroupSize - index] - \n            (minLength - 1) / oneGroupSize - (minLength - 1) / zeroGroupSize + index < 0 ? 0\n            : dynamicProgramming[(minLength - 1) / oneGroupSize + (minLength - 1) / zeroGroupSize - index]) % modulo;\n    }\n\n    return result;\n}",
    "output": "#include <vector>\n#include <algorithm>\n\nint CountGoodStrings(int minLength, int maxLength, int oneGroupSize, int zeroGroupSize, int modulo= 1000000007)\n{\n    int max_count= maxLength / oneGroupSize + maxLength / zeroGroupSize;\n\n    std::vector<long long> dynamic_programming(max_count + 1);\n    dynamic_programming[0]= 1;\n\n    for(int index= 1; index <= max_count; index++)\n        dynamic_programming[index]= (dynamic_programming[index - 1] * (index % oneGroupSize == 0 || index % zeroGroupSize == 0)) % modulo;\n\n    long long result= 0;\n    for(int index= 0; index <= max_count; index++)\n    {\n        result= (result + dynamic_programming[minLength / oneGroupSize + minLength / zeroGroupSize - index] - (minLength - 1) / oneGroupSize - (minLength - 1) / zeroGroupSize + index < 0 ? 0\n                                                                                                                                                                                          : dynamic_programming[(minLength - 1) / oneGroupSize + (minLength - 1) / zeroGroupSize - index]) %\n                modulo;\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> timeCrossingTheDoor(vector<int> &arrivalTimes, vector<int> &personState)\n{\n    int numberOfPersons= arrivalTimes.size();\n    vector<int> crossingTimes(numberOfPersons);\n    vector<int> lastSeenTimeAtDoor(2, -1);\n\n    for(int personIndex= 0, currentTime= 0; personIndex < numberOfPersons; ++personIndex, ++currentTime)\n    {\n        while(currentTime < arrivalTimes[personIndex])\n            currentTime++;\n\n        int direction= (lastSeenTimeAtDoor[1] != currentTime - 1) ? 1 : 0;\n\n        if(personState[personIndex] == direction)\n        {\n            lastSeenTimeAtDoor[personState[personIndex]]= currentTime;\n        }\n        else\n        {\n            while(personIndex + 1 < numberOfPersons && arrivalTimes[personIndex + 1] == currentTime && personState[personIndex + 1] != direction)\n                ++personIndex;\n\n            if(personIndex + 1 < numberOfPersons && arrivalTimes[personIndex + 1] == currentTime && personState[personIndex + 1] == direction)\n            {\n                lastSeenTimeAtDoor[personState[personIndex= personIndex + 1]]= currentTime;\n            }\n            else\n            {\n                currentTime--, personIndex--;\n            }\n        }\n        crossingTimes[personIndex]= lastSeenTimeAtDoor[personState[personIndex]];\n    }\n    return crossingTimes;\n}",
    "output": "#include <vector>\n\nstd::vector<int> TimeCrossingTheDoor(std::vector<int> &arrivalTimes, std::vector<int> &personState)\n{\n    int number_of_persons = arrivalTimes.size();\n    std::vector<int> crossing_times(number_of_persons);\n    std::vector<int> last_seen_time_at_door(2, -1);\n\n    for(int person_index = 0, current_time = 0; person_index < number_of_persons; ++person_index, ++current_time)\n    {\n        while(current_time < arrivalTimes[person_index])\n            current_time++;\n\n        int direction = (last_seen_time_at_door[1] != current_time - 1) ? 1 : 0;\n\n        if(personState[person_index] == direction)\n        {\n            last_seen_time_at_door[personState[person_index]] = current_time;\n        }\n        else\n        {\n            while(person_index + 1 < number_of_persons && arrivalTimes[person_index + 1] == current_time && personState[person_index + 1] != direction)\n                ++person_index;\n\n            if(person_index + 1 < number_of_persons && arrivalTimes[person_index + 1] == current_time && personState[person_index + 1] == direction)\n            {\n                last_seen_time_at_door[personState[person_index = person_index + 1]] = current_time;\n            }\n            else\n            {\n                current_time--, person_index--;\n            }\n        }\n        crossing_times[person_index] = last_seen_time_at_door[personState[person_index]];\n    }\n    return crossing_times;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\n// For abs function\nusing namespace std;\n\nint differenceBetweenElementAndDigitSum(vector<int> &numbers)\n{\n    int totalElementSum = 0, totalDigitSum = 0;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int currentNumber = numbers[i];\n        totalElementSum += currentNumber;\n        int tempNumber = currentNumber; // Create a temporary variable to hold the current number\n        while (tempNumber > 0)\n        {\n            totalDigitSum += tempNumber % 10;\n            tempNumber /= 10;\n        }\n    }\n    return abs(totalElementSum - totalDigitSum);\n}",
    "output": "#include <vector>\n#include <cstdlib> // For abs function\n\nint DifferenceBetweenElementAndDigitSum(std::vector<int> &numbers)\n{\n    int total_element_sum= 0, total_digit_sum= 0;\n    for(int current_number : numbers)\n    {\n        total_element_sum+= current_number;\n        int temp_number= current_number; // Create a temporary variable to hold the current number\n        while(temp_number > 0)\n        {\n            total_digit_sum+= temp_number % 10;\n            temp_number/= 10;\n        }\n    }\n    return std::abs(total_element_sum - total_digit_sum);\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> applyQueries(int matrixSize, vector<vector<int>> &queryList)\n{\n    vector<vector<int>> matrix(matrixSize, vector<int>(matrixSize, 0));\n\n    for (int i = 0; i < queryList.size(); ++i)\n    {\n        auto &query = queryList[i];\n        for (int row = query[0]; row <= query[2]; ++row)\n        {\n            for (int col = query[1]; col <= query[3]; ++col)\n            {\n                matrix[row][col]++;\n            }\n        }\n    }\n\n    return matrix;\n}",
    "output": "#include <vector>\n\nstd::vector<std::vector<int>> ApplyQueries(int matrixSize, std::vector<std::vector<int>> &queryList)\n{\n    std::vector<std::vector<int>> matrix(matrixSize, std::vector<int>(matrixSize, 0));\n\n    for(auto &query : queryList)\n    {\n        for(int row= query[0]; row <= query[2]; ++row)\n        {\n            for(int col= query[1]; col <= query[3]; ++col)\n            {\n                matrix[row][col]++;\n            }\n        }\n    }\n\n    return matrix;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countGoodSubarrays(vector<int> &numbers, int targetSum)\n{\n    unordered_map<int, int> prefixSumCount;\n    int totalGoodSubarrays = 0, currentPrefixSum = 0;\n\n    prefixSumCount[0] = 1;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int number = numbers[i];\n        currentPrefixSum += number - 1;\n        totalGoodSubarrays += prefixSumCount[currentPrefixSum - targetSum];\n        prefixSumCount[currentPrefixSum]++;\n    }\n\n    return totalGoodSubarrays;\n}",
    "output": "#include <vector>\n#include <unordered_map>\n\nint CountGoodSubarrays(std::vector<int> &numbers, int targetSum)\n{\n    std::unordered_map<int, int> prefix_sum_count;\n    int total_good_subarrays= 0, current_prefix_sum= 0;\n\n    prefix_sum_count[0]= 1;\n    for(int number : numbers)\n    {\n        current_prefix_sum+= number - 1;\n        total_good_subarrays+= prefix_sum_count[current_prefix_sum - targetSum];\n        prefix_sum_count[current_prefix_sum]++;\n    }\n\n    return total_good_subarrays;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adjacencyList;\nvector<int> nodePrices;\nvector<pair<vector<long long>, vector<long long>>> dynamicProgramming;\n\nvoid depthFirstSearch(int currentNode, int parentNode)\n{\n    dynamicProgramming[currentNode].first[0] = nodePrices[currentNode];\n    dynamicProgramming[currentNode].first[1] = 0;\n    dynamicProgramming[currentNode].second[0] = nodePrices[currentNode];\n    dynamicProgramming[currentNode].second[1] = 0;\n\n    for (int i = 0; i < adjacencyList[currentNode].size(); ++i)\n    {\n        int neighborNode = adjacencyList[currentNode][i];\n        if (neighborNode == parentNode)\n            continue;\n        depthFirstSearch(neighborNode, currentNode);\n        dynamicProgramming[currentNode].first.push_back(dynamicProgramming[neighborNode].first[0] + nodePrices[currentNode] - dynamicProgramming[neighborNode].second[0]);\n        dynamicProgramming[currentNode].first.push_back(dynamicProgramming[neighborNode].first[1]);\n        dynamicProgramming[currentNode].second.push_back(dynamicProgramming[neighborNode].second[0] + nodePrices[currentNode] - dynamicProgramming[neighborNode].first[0]);\n        dynamicProgramming[currentNode].second.push_back(dynamicProgramming[neighborNode].second[1]);\n\n        sort(dynamicProgramming[currentNode].first.begin(), dynamicProgramming[currentNode].first.end());\n        sort(dynamicProgramming[currentNode].second.begin(), dynamicProgramming[currentNode].second.end());\n    }\n}\n\nint getMaxCost(int numberOfNodes, vector<vector<int>> &edges, vector<int> &priceList)\n{\n    adjacencyList.resize(numberOfNodes);\n    nodePrices = priceList;\n    dynamicProgramming.resize(numberOfNodes, pair<vector<long long>, vector<long long>>(vector<long long>(2), vector<long long>(2)));\n\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        vector<int> &edge = edges[i];\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    depthFirstSearch(0, -1);\n\n    long long maximumCost = 0;\n    for (int i = 0; i < numberOfNodes; ++i)\n    {\n        maximumCost = max(maximumCost, dynamicProgramming[i].first.back() - dynamicProgramming[i].second.back());\n    }\n\n    return maximumCost;\n}",
    "output": "#include <algorithm>\n#include <vector>\n\nstd::vector<std::vector<int>> adjacency_list;\nstd::vector<int> node_prices;\nstd::vector<std::pair<std::vector<long long>, std::vector<long long>>> dynamic_programming;\n\nvoid DepthFirstSearch(int currentNode, int parentNode)\n{\n    dynamic_programming[currentNode].first[0]= node_prices[currentNode];\n    dynamic_programming[currentNode].first[1]= 0;\n    dynamic_programming[currentNode].second[0]= node_prices[currentNode];\n    dynamic_programming[currentNode].second[1]= 0;\n\n    for(int neighbor_node : adjacency_list[currentNode])\n    {\n        if(neighbor_node == parentNode)\n            continue;\n        DepthFirstSearch(neighbor_node, currentNode);\n        dynamic_programming[currentNode].first.push_back(dynamic_programming[neighbor_node].first[0] + node_prices[currentNode] - dynamic_programming[neighbor_node].second[0]);\n        dynamic_programming[currentNode].first.push_back(dynamic_programming[neighbor_node].first[1]);\n        dynamic_programming[currentNode].second.push_back(dynamic_programming[neighbor_node].second[0] + node_prices[currentNode] - dynamic_programming[neighbor_node].first[0]);\n        dynamic_programming[currentNode].second.push_back(dynamic_programming[neighbor_node].second[1]);\n\n        std::sort(dynamic_programming[currentNode].first.begin(), dynamic_programming[currentNode].first.end());\n        std::sort(dynamic_programming[currentNode].second.begin(), dynamic_programming[currentNode].second.end());\n    }\n}\n\nint GetMaxCost(int numberOfNodes, std::vector<std::vector<int>> &edges, std::vector<int> &priceList)\n{\n    adjacency_list.resize(numberOfNodes);\n    node_prices= priceList;\n    dynamic_programming.resize(numberOfNodes, std::pair<std::vector<long long>, std::vector<long long>>(std::vector<long long>(2), std::vector<long long>(2)));\n\n    for(std::vector<int> &edge : edges)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    DepthFirstSearch(0, -1);\n\n    long long maximum_cost= 0;\n    for(int i= 0; i < numberOfNodes; ++i)\n    {\n        maximum_cost= std::max(maximum_cost, dynamic_programming[i].first.back() - dynamic_programming[i].second.back());\n    }\n\n    return maximum_cost;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countOfGoodSubsequences(string inputString)\n{\n    vector<int> characterCount(26, 0);\n    long totalCount = 0;\n    const int modulo = 1000000007;\n\n    for (char currentChar : inputString)\n    {\n        characterCount[currentChar - 'a']++;\n    }\n\n    for (int i = 0; i < characterCount.size(); ++i)\n    {\n        int occurrence = characterCount[i];\n        totalCount = (totalCount + (1L << occurrence) - 1) % modulo;\n    }\n\n    return totalCount;\n}",
    "output": "#include <string>\n#include <vector>\n\nint CountOfGoodSubsequences(std::string inputString)\n{\n    std::vector<int> character_count(26, 0);\n    long total_count= 0;\n    const int modulo= 1000000007;\n\n    for(char currentChar : inputString)\n    {\n        character_count[currentChar - 'a']++;\n    }\n\n    for(int occurrence : character_count)\n    {\n        total_count= (total_count + (1L << occurrence) - 1) % modulo;\n    }\n\n    return total_count;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findMinimumCommonNumber(vector<int> &firstArray, vector<int> &secondArray)\n{\n    int firstIndex= 0, secondIndex= 0;\n    while(firstIndex < firstArray.size() && secondIndex < secondArray.size())\n    {\n        if(firstArray[firstIndex] == secondArray[secondIndex])\n        {\n            return firstArray[firstIndex];\n        }\n        else if(firstArray[firstIndex] < secondArray[secondIndex])\n        {\n            firstIndex++;\n        }\n        else\n        {\n            secondIndex++;\n        }\n    }\n    return -1;\n}",
    "output": "#include <vector>\n\nint FindMinimumCommonNumber(std::vector<int> &firstArray, std::vector<int> &secondArray)\n{\n    int first_index= 0, second_index= 0;\n    while(first_index < firstArray.size() && second_index < secondArray.size())\n    {\n        if(firstArray[first_index] == secondArray[second_index])\n        {\n            return firstArray[first_index];\n        }\n        else if(firstArray[first_index] < secondArray[second_index])\n        {\n            first_index++;\n        }\n        else\n        {\n            second_index++;\n        }\n    }\n    return -1;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\n// For abs function\nusing namespace std;\n\nint minChanges(vector<int> &firstArray, vector<int> &secondArray, int differenceFactor)\n{\n    int arraySize= firstArray.size();\n    int totalOperations= 0;\n    for(int index= 0; index < arraySize; ++index)\n    {\n        int difference= abs(firstArray[index] - secondArray[index]);\n        if(difference % differenceFactor != 0)\n            return -1;\n        totalOperations+= difference / differenceFactor;\n    }\n    return totalOperations;\n}",
    "output": "#include <vector>\n#include <cstdlib> // For abs function\n\nint MinChanges(std::vector<int> &firstArray, std::vector<int> &secondArray, int differenceFactor)\n{\n    int array_size= firstArray.size();\n    int total_operations= 0;\n    for(int index= 0; index < array_size; ++index)\n    {\n        int difference= std::abs(firstArray[index] - secondArray[index]);\n        if(difference % differenceFactor != 0)\n            return -1;\n        total_operations+= difference / differenceFactor;\n    }\n    return total_operations;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxScore(vector<int> &firstArray, vector<int> &secondArray, int maxElements)\n{\n    int arraySize = firstArray.size();\n    int maximumResult = 0;\n    int sumFirstArray = 0, minimumSecondArray = secondArray[0];\n    for(int startIndex = 0, endIndex = 0; endIndex < arraySize; ++endIndex)\n    {\n        sumFirstArray += firstArray[endIndex];\n        minimumSecondArray = min(minimumSecondArray, secondArray[endIndex]);\n        if(endIndex - startIndex + 1 > maxElements)\n            sumFirstArray -= firstArray[startIndex++];\n        if(endIndex + 1 >= maxElements)\n            maximumResult = max(maximumResult, sumFirstArray * minimumSecondArray);\n    }\n    return maximumResult;\n}",
    "output": "#include <vector>\n#include <algorithm>\n\nint MaxScore(std::vector<int> &firstArray, std::vector<int> &secondArray, int maxElements)\n{\n    int array_size= firstArray.size();\n    int maximum_result= 0;\n    int sum_first_array= 0, minimum_second_array= secondArray[0];\n    for(int start_index= 0, end_index= 0; end_index < array_size; ++end_index)\n    {\n        sum_first_array+= firstArray[end_index];\n        minimum_second_array= std::min(minimum_second_array, secondArray[end_index]);\n        if(end_index - start_index + 1 > maxElements)\n            sum_first_array-= firstArray[start_index++];\n        if(end_index + 1 >= maxElements)\n            maximum_result= std::max(maximum_result, sum_first_array * minimum_second_array);\n    }\n    return maximum_result;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "bool canReach(int targetX, int targetY)\n{\n    while(targetX > 1 && targetY > 1)\n    {\n        if(targetX < targetY)\n            swap(targetX, targetY);\n        targetX-= targetY;\n    }\n    return targetX == 1 || targetY == 1;\n}",
    "output": "bool CanReach(int targetX, int targetY)\n{\n    while(targetX > 1 && targetY > 1)\n    {\n        if(targetX < targetY)\n            swap(targetX, targetY);\n        targetX-= targetY;\n    }\n    return targetX == 1 || targetY == 1;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "int sumOfDigits(int inputNumber)\n{\n    int digitSum= 0;\n    bool isPositive= true;\n\n    while(inputNumber > 0)\n    {\n        int currentDigit= inputNumber % 10;\n        inputNumber/= 10;\n\n        if(isPositive)\n        {\n            digitSum+= currentDigit;\n        }\n        else\n        {\n            digitSum-= currentDigit;\n        }\n\n        isPositive= !isPositive;\n    }\n\n    return digitSum;\n}",
    "output": "int SumOfDigits(int inputNumber)\n{\n    int digit_sum= 0;\n    bool is_positive= true;\n\n    while(inputNumber > 0)\n    {\n        int current_digit= inputNumber % 10;\n        inputNumber/= 10;\n\n        if(is_positive)\n        {\n            digit_sum+= current_digit;\n        }\n        else\n        {\n            digit_sum-= current_digit;\n        }\n\n        is_positive= !is_positive;\n    }\n\n    return digit_sum;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> sortStudents(vector<vector<int>> &studentScores, int scoreIndex)\n{\n    sort(studentScores.begin(), studentScores.end(), [scoreIndex](const vector<int> &firstStudent, const vector<int> &secondStudent)\n         { return firstStudent[scoreIndex] > secondStudent[scoreIndex]; });\n    return studentScores;\n}",
    "output": "#include <algorithm>\n#include <vector>\n\nstd::vector<std::vector<int>> SortStudents(std::vector<std::vector<int>> &studentScores, int scoreIndex)\n{\n    std::sort(studentScores.begin(), studentScores.end(), [scoreIndex](const std::vector<int> &firstStudent, const std::vector<int> &secondStudent)\n         { return firstStudent[scoreIndex] > secondStudent[scoreIndex]; });\n    return studentScores;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canMakeEqual(string sourceString, string targetString)\n{\n    int sourceCountOnes= count(sourceString.begin(), sourceString.end(), '1');\n    int targetCountOnes= count(targetString.begin(), targetString.end(), '1');\n    return sourceCountOnes >= targetCountOnes;\n}",
    "output": "#include <string>\n#include <algorithm>\n\nbool CanMakeEqual(std::string sourceString, std::string targetString)\n{\n    int source_count_ones = std::count(sourceString.begin(), sourceString.end(), '1');\n    int target_count_ones = std::count(targetString.begin(), targetString.end(), '1');\n    return source_count_ones >= target_count_ones;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\n// For std::min\nusing namespace std;\n\nint getCost(int endIndex, vector<int> &frequencyCount, vector<int> &numberList)\n{\n    return frequencyCount[numberList[endIndex]] == 1 ? 1 : 0;\n}\n\nint minCost(vector<int> &numberList, int cost)\n{\n    int listSize= numberList.size(), infinity= 1e9 + 7;\n    vector<int> frequencyCount(1001, 0), dynamicProgramming(listSize + 1, 0); // frequencyCount for frequency, dynamicProgramming for dynamic programming\n\n    for(int startIndex= 0, endIndex= 0; endIndex < listSize; ++endIndex)\n    {\n        ++frequencyCount[numberList[endIndex]];\n\n        if(frequencyCount[numberList[endIndex]] == 2) // if occurrence is 2, change dynamicProgramming\n            dynamicProgramming[endIndex + 1]= dynamicProgramming[startIndex] + cost + (endIndex - startIndex + 1);\n        else if(frequencyCount[numberList[endIndex]] > 2) // if occurrence is more than 2\n            dynamicProgramming[endIndex + 1]= min(dynamicProgramming[endIndex], dynamicProgramming[endIndex - 1] - (frequencyCount[numberList[endIndex]] - 2));\n        else\n            dynamicProgramming[endIndex + 1]= dynamicProgramming[endIndex] + getCost(endIndex, frequencyCount, numberList) + cost;\n\n        while(startIndex < endIndex + 1 && frequencyCount[numberList[startIndex]] >= 2)\n        {\n            --frequencyCount[numberList[startIndex]];\n            ++startIndex; // update first pointer startIndex when numberList[startIndex] has occurred more than once\n        }\n    }\n\n    return dynamicProgramming[listSize];\n}",
    "output": "#include <vector>\n#include <algorithm>\n\nint MinCost(std::vector<int> &numberList, int cost)\n{\n    int list_size= numberList.size(), infinity= 1e9 + 7;\n    std::vector<int> frequency_count(1001, 0), dynamic_programming(list_size + 1, 0); // frequency_count for frequency, dynamic_programming for dynamic programming\n\n    for(int start_index= 0, end_index= 0; end_index < list_size; ++end_index)\n    {\n        ++frequency_count[numberList[end_index]];\n\n        if(frequency_count[numberList[end_index]] == 2) // if occurrence is 2, change dynamic_programming\n            dynamic_programming[end_index + 1]= dynamic_programming[start_index] + cost + (end_index - start_index + 1);\n        else if(frequency_count[numberList[end_index]] > 2) // if occurrence is more than 2\n            dynamic_programming[end_index + 1]= std::min(dynamic_programming[end_index], dynamic_programming[end_index - 1] - (frequency_count[numberList[end_index]] - 2));\n        else\n            dynamic_programming[end_index + 1]= dynamic_programming[end_index] + GetCost(end_index, frequency_count, numberList) + cost;\n\n        while(start_index < end_index + 1 && frequency_count[numberList[start_index]] >= 2)\n        {\n            --frequency_count[numberList[start_index]];\n            ++start_index; // update first pointer start_index when numberList[start_index] has occurred more than once\n        }\n    }\n\n    return dynamic_programming[list_size];\n}\n\nint GetCost(int endIndex, std::vector<int> &frequencyCount, std::vector<int> &numberList)\n{\n    return frequencyCount[numberList[endIndex]] == 1 ? 1 : 0;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble maxValue(vector<vector<int>> &items, int capacity)\n{\n    sort(items.begin(), items.end(), [](const vector<int> &a, const vector<int> &b)\n         { return (double)a[0] / a[1] > (double)b[0] / b[1]; });\n\n    double maxTotalPrice = 0;\n    for (int i = 0; i < items.size(); ++i)\n    {\n        const auto &item = items[i];\n        if (capacity >= item[1])\n        {\n            capacity -= item[1];\n            maxTotalPrice += item[0];\n        }\n        else\n        {\n            maxTotalPrice += (double)item[0] * capacity / item[1];\n            break;\n        }\n    }\n\n    return maxTotalPrice;\n}",
    "output": "#include <algorithm>\n#include <vector>\n\ndouble MaxValue(std::vector<std::vector<int>> &items, int capacity)\n{\n    std::sort(items.begin(), items.end(), [](const std::vector<int> &a, const std::vector<int> &b)\n         { return (double)a[0] / a[1] > (double)b[0] / b[1]; });\n\n    double max_total_price= 0;\n    for(const auto &item : items)\n    {\n        if(capacity >= item[1])\n        {\n            capacity-= item[1];\n            max_total_price+= item[0];\n        }\n        else\n        {\n            max_total_price+= (double)item[0] * capacity / item[1];\n            break;\n        }\n    }\n\n    return max_total_price;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "int distinctCount(int totalNumbers)\n{\n    return totalNumbers - 1;\n}",
    "output": "int DistinctCount(int totalNumbers)\n{\n    return totalNumbers - 1;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod= 1e9 + 7;\n\nint waysToCollide(int numberOfObjects)\n{\n    int powerOfTwo= 1;\n    for(int index= 0; index < numberOfObjects; index++)\n    {\n        powerOfTwo= (2LL * powerOfTwo) % mod;\n    }\n    return (powerOfTwo - numberOfObjects - 1 + mod) % mod;\n}",
    "output": "#include <iostream>\n\nconst int mod= 1e9 + 7;\n\nint WaysToCollide(int numberOfObjects)\n{\n    int power_of_two= 1;\n    for(int index= 0; index < numberOfObjects; index++)\n    {\n        power_of_two= (2LL * power_of_two) % mod;\n    }\n    return (power_of_two - numberOfObjects - 1 + mod) % mod;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maximizeScore(vector<int> &weightValues, int numberOfGroups)\n{\n    int totalWeights= weightValues.size();\n    vector<int> prefixSum(totalWeights + 1);\n    partial_sum(weightValues.begin(), weightValues.end(), prefixSum.begin() + 1);\n    vector<vector<int>> dynamicProgramming(totalWeights, vector<int>(numberOfGroups + 1));\n\n    for(int currentIndex= 0; currentIndex < totalWeights; currentIndex++)\n    {\n        for(int groupIndex= 1; groupIndex <= numberOfGroups; groupIndex++)\n        {\n            dynamicProgramming[currentIndex][groupIndex]= -1e9;\n        }\n    }\n\n    for(int currentIndex= 0; currentIndex < totalWeights; currentIndex++)\n    {\n        dynamicProgramming[currentIndex][1]= prefixSum[currentIndex + 1];\n        if(currentIndex > 0)\n        {\n            dynamicProgramming[currentIndex][currentIndex + 1]= prefixSum[currentIndex + 1] - prefixSum[1];\n        }\n        for(int groupIndex= 2; groupIndex <= min<int>(currentIndex + 1, numberOfGroups); groupIndex++)\n        {\n            for(int previousGroupSize= 1; previousGroupSize <= currentIndex - groupIndex + 2; previousGroupSize++)\n            {\n                dynamicProgramming[currentIndex][groupIndex]= max(dynamicProgramming[currentIndex][groupIndex],\n                                                                   dynamicProgramming[currentIndex - previousGroupSize][groupIndex - 1] + weightValues[currentIndex] + weightValues[currentIndex - previousGroupSize]);\n            }\n        }\n    }\n\n    return dynamicProgramming[totalWeights - 1][numberOfGroups] - dynamicProgramming[totalWeights - 1][1];\n}",
    "output": "#include <algorithm>\n#include <numeric>\n#include <vector>\n\nint MaximizeScore(std::vector<int> &weightValues, int numberOfGroups)\n{\n    int total_weights= weightValues.size();\n    std::vector<int> prefix_sum(total_weights + 1);\n    std::partial_sum(weightValues.begin(), weightValues.end(), prefix_sum.begin() + 1);\n    std::vector<std::vector<int>> dynamic_programming(total_weights, std::vector<int>(numberOfGroups + 1));\n\n    for(int current_index= 0; current_index < total_weights; current_index++)\n    {\n        for(int group_index= 1; group_index <= numberOfGroups; group_index++)\n        {\n            dynamic_programming[current_index][group_index]= -1e9;\n        }\n    }\n\n    for(int current_index= 0; current_index < total_weights; current_index++)\n    {\n        dynamic_programming[current_index][1]= prefix_sum[current_index + 1];\n        if(current_index > 0)\n        {\n            dynamic_programming[current_index][current_index + 1]= prefix_sum[current_index + 1] - prefix_sum[1];\n        }\n        for(int group_index= 2; group_index <= std::min<int>(current_index + 1, numberOfGroups); group_index++)\n        {\n            for(int previous_group_size= 1; previous_group_size <= current_index - group_index + 2; previous_group_size++)\n            {\n                dynamic_programming[current_index][group_index]= std::max(dynamic_programming[current_index][group_index],\n                                                                       dynamic_programming[current_index - previous_group_size][group_index - 1] + weightValues[current_index] + weightValues[current_index - previous_group_size]);\n            }\n        }\n    }\n\n    return dynamic_programming[total_weights - 1][numberOfGroups] - dynamic_programming[total_weights - 1][1];\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countIncreasingQuadruplets(vector<int> &numberList)\n{\n    int listSize= numberList.size(), quadrupletCount= 0;\n    for(int firstIndex= 0; firstIndex < listSize - 3; firstIndex++)\n    {\n        for(int secondIndex= firstIndex + 1; secondIndex < listSize - 2; secondIndex++)\n        {\n            for(int thirdIndex= secondIndex + 1; thirdIndex < listSize - 1; thirdIndex++)\n            {\n                if(numberList[firstIndex] < numberList[thirdIndex] && numberList[thirdIndex] < numberList[secondIndex])\n                {\n                    for(int fourthIndex= thirdIndex + 1; fourthIndex < listSize; fourthIndex++)\n                    {\n                        if(numberList[secondIndex] < numberList[fourthIndex])\n                        {\n                            quadrupletCount++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return quadrupletCount;\n}",
    "output": "#include <vector>\n\nint CountIncreasingQuadruplets(std::vector<int> &numberList)\n{\n    int list_size= numberList.size(), quadruplet_count= 0;\n    for(int first_index= 0; first_index < list_size - 3; first_index++)\n    {\n        for(int second_index= first_index + 1; second_index < list_size - 2; second_index++)\n        {\n            for(int third_index= second_index + 1; third_index < list_size - 1; third_index++)\n            {\n                if(numberList[first_index] < numberList[third_index] && numberList[third_index] < numberList[second_index])\n                {\n                    for(int fourth_index= third_index + 1; fourth_index < list_size; fourth_index++)\n                    {\n                        if(numberList[second_index] < numberList[fourth_index])\n                        {\n                            quadruplet_count++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return quadruplet_count;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> separateDigits(const vector<int> &inputNumbers)\n{\n    vector<int> resultDigits;\n    for (int i = 0; i < inputNumbers.size(); ++i)\n    {\n        int currentNumber = inputNumbers[i];\n        vector<int> extractedDigits;\n        while (currentNumber)\n        {\n            extractedDigits.insert(extractedDigits.begin(), currentNumber % 10);\n            currentNumber /= 10;\n        }\n        resultDigits.insert(resultDigits.end(), extractedDigits.begin(), extractedDigits.end());\n    }\n    return resultDigits;\n}",
    "output": "#include <vector>\n\nstd::vector<int> SeparateDigits(const std::vector<int> &inputNumbers)\n{\n    std::vector<int> result_digits;\n    for(auto current_number : inputNumbers)\n    {\n        std::vector<int> extracted_digits;\n        while(current_number)\n        {\n            extracted_digits.insert(extracted_digits.begin(), current_number % 10);\n            current_number/= 10;\n        }\n        result_digits.insert(result_digits.end(), extracted_digits.begin(), extracted_digits.end());\n    }\n    return result_digits;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxChosenIntegers(vector<int> &bannedIntegers, int totalIntegers, int maxSum)\n{\n    unordered_set<int> bannedSet(bannedIntegers.begin(), bannedIntegers.end());\n    int chosenCount= 0, currentSum= 0;\n    for(int integer= totalIntegers; integer >= 1 && maxSum - currentSum >= integer; --integer)\n    {\n        if(bannedSet.find(integer) == bannedSet.end())\n        {\n            currentSum+= integer;\n            ++chosenCount;\n        }\n    }\n    return chosenCount;\n}",
    "output": "#include <unordered_set>\n#include <vector>\n\nint MaxChosenIntegers(std::vector<int> &bannedIntegers, int totalIntegers, int maxSum)\n{\n    std::unordered_set<int> banned_set(bannedIntegers.begin(), bannedIntegers.end());\n    int chosen_count= 0, current_sum= 0;\n    for(int integer= totalIntegers; integer >= 1 && maxSum - current_sum >= integer; --integer)\n    {\n        if(banned_set.find(integer) == banned_set.end())\n        {\n            current_sum+= integer;\n            ++chosen_count;\n        }\n    }\n    return chosen_count;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxPrizes(vector<int> &prizePositions, int maxDistance)\n{\n    int totalPositions= prizePositions.size();\n    int maximumPrizes= 0;\n    for(int currentIndex= 0; currentIndex < totalPositions; ++currentIndex)\n    {\n        int leftSegmentEnd= prizePositions[currentIndex] + maxDistance;\n        int rightSegmentStart= upper_bound(prizePositions.begin(), prizePositions.end(), leftSegmentEnd) - prizePositions.begin();\n        int rightSegmentEnd= prizePositions[rightSegmentStart] + maxDistance;\n        maximumPrizes= max(maximumPrizes, int(upper_bound(prizePositions.begin(), prizePositions.end(), rightSegmentEnd) - lower_bound(prizePositions.begin(), prizePositions.end(), prizePositions[currentIndex])));\n    }\n    return maximumPrizes;\n}",
    "output": "#include <vector>\n#include <algorithm>\n\nint MaxPrizes(std::vector<int> &prizePositions, int maxDistance)\n{\n    int total_positions= prizePositions.size();\n    int maximum_prizes= 0;\n    for(int current_index= 0; current_index < total_positions; ++current_index)\n    {\n        int left_segment_end= prizePositions[current_index] + maxDistance;\n        int right_segment_start= std::upper_bound(prizePositions.begin(), prizePositions.end(), left_segment_end) - prizePositions.begin();\n        int right_segment_end= prizePositions[right_segment_start] + maxDistance;\n        maximum_prizes= std::max(maximum_prizes, int(std::upper_bound(prizePositions.begin(), prizePositions.end(), right_segment_end) - std::lower_bound(prizePositions.begin(), prizePositions.end(), prizePositions[current_index])));\n    }\n    return maximum_prizes;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canReach(vector<vector<int>> &grid, int currentRow, int currentCol)\n{\n    if(currentRow < 0 || currentCol < 0 || currentRow >= grid.size() || currentCol >= grid[0].size() || grid[currentRow][currentCol] == 0)\n        return false;\n\n    if(currentRow == grid.size() - 1 && currentCol == grid[0].size() - 1)\n        return true;\n\n    grid[currentRow][currentCol]= 0;\n\n    return canReach(grid, currentRow + 1, currentCol) || canReach(grid, currentRow, currentCol + 1);\n}\n\nbool canDisconnect(vector<vector<int>> &grid)\n{\n    int reachableCount= 0;\n\n    for(int currentRow= 1; currentRow < grid.size(); currentRow++)\n    {\n        for(int currentCol= 1; currentCol < grid[0].size(); currentCol++)\n        {\n            if(grid[currentRow][currentCol] == 1 && (canReach(grid, currentRow - 1, currentCol) || canReach(grid, currentRow, currentCol - 1)))\n            {\n                reachableCount++;\n                if(reachableCount > 1)\n                    return true;\n            }\n        }\n    }\n\n    return reachableCount <= 1;\n}",
    "output": "#include <vector>\n\nbool CanReach(std::vector<std::vector<int>> &grid, int currentRow, int currentCol)\n{\n    if(currentRow < 0 || currentCol < 0 || currentRow >= grid.size() || currentCol >= grid[0].size() || grid[currentRow][currentCol] == 0)\n        return false;\n\n    if(currentRow == grid.size() - 1 && currentCol == grid[0].size() - 1)\n        return true;\n\n    grid[currentRow][currentCol]= 0;\n\n    return CanReach(grid, currentRow + 1, currentCol) || CanReach(grid, currentRow, currentCol + 1);\n}\n\nbool CanDisconnect(std::vector<std::vector<int>> &grid)\n{\n    int reachable_count= 0;\n\n    for(int current_row= 1; current_row < grid.size(); current_row++)\n    {\n        for(int current_col= 1; current_col < grid[0].size(); current_col++)\n        {\n            if(grid[current_row][current_col] == 1 && (CanReach(grid, current_row - 1, current_col) || CanReach(grid, current_row, current_col - 1)))\n            {\n                reachable_count++;\n                if(reachable_count > 1)\n                    return true;\n            }\n        }\n    }\n\n    return reachable_count <= 1;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxChosenIntegers(vector<int> &bannedIntegers, int totalIntegers, long long maxAllowedSum)\n{\n    unordered_set<int> bannedSet(bannedIntegers.begin(), bannedIntegers.end());\n    int countChosenIntegers= 0;\n    long long currentChosenSum= 0;\n\n    for(int i= totalIntegers; i > 0 && currentChosenSum < maxAllowedSum; --i)\n    {\n        if(bannedSet.find(i) == bannedSet.end())\n        {\n            if(currentChosenSum + i <= maxAllowedSum)\n            {\n                currentChosenSum+= i;\n                countChosenIntegers++;\n            }\n            else\n            {\n                break;\n            }\n        }\n    }\n\n    return countChosenIntegers;\n}",
    "output": "#include <vector>\n#include <unordered_set>\n\nint MaxChosenIntegers(std::vector<int> &bannedIntegers, int totalIntegers, long long maxAllowedSum)\n{\n    std::unordered_set<int> banned_set(bannedIntegers.begin(), bannedIntegers.end());\n    int count_chosen_integers= 0;\n    long long current_chosen_sum= 0;\n\n    for(int i= totalIntegers; i > 0 && current_chosen_sum < maxAllowedSum; --i)\n    {\n        if(banned_set.find(i) == banned_set.end())\n        {\n            if(current_chosen_sum + i <= maxAllowedSum)\n            {\n                current_chosen_sum+= i;\n                count_chosen_integers++;\n            }\n            else\n            {\n                break;\n            }\n        }\n    }\n\n    return count_chosen_integers;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint giftsRemaining(vector<int> &giftValues, int numberOfIterations)\n{\n    for(int iteration = 0; iteration < numberOfIterations; iteration++)\n    {\n        sort(giftValues.begin(), giftValues.end());\n        int maxIndex = giftValues.size() - 1;\n        giftValues[maxIndex] -= static_cast<int>(sqrt(giftValues[maxIndex]));\n    }\n    int totalRemainingGifts = 0;\n    for(int j = 0; j < giftValues.size(); j++)\n        totalRemainingGifts += giftValues[j];\n    return totalRemainingGifts;\n}",
    "output": "#include <algorithm>\n#include <cmath>\n#include <vector>\n\nint GiftsRemaining(std::vector<int> &giftValues, int numberOfIterations)\n{\n    for(int iteration= 0; iteration < numberOfIterations; iteration++)\n    {\n        std::sort(giftValues.begin(), giftValues.end());\n        int max_index= giftValues.size() - 1;\n        giftValues[max_index]-= static_cast<int>(sqrt(giftValues[max_index]));\n    }\n    int total_remaining_gifts= 0;\n    for(int gift : giftValues)\n        total_remaining_gifts+= gift;\n    return total_remaining_gifts;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isVowel(char character)\n{\n    return character == 'a' || character == 'e' || character == 'i' || character == 'o' || character == 'u';\n}\n\nvector<int> countVowelStrings(vector<string> &wordList, vector<vector<int>> &queryRanges)\n{\n    vector<int> result;\n    for (int i = 0; i < queryRanges.size(); ++i)\n    {\n        auto &query = queryRanges[i];\n        int vowelStringCount = 0;\n        for (int index = query[0]; index <= query[1]; index++)\n        {\n            if (isVowel(wordList[index].front()) && isVowel(wordList[index].back()))\n            {\n                vowelStringCount++;\n            }\n        }\n        result.push_back(vowelStringCount);\n    }\n    return result;\n}",
    "output": "#include <string>\n#include <vector>\n\nbool IsVowel(char character)\n{\n    return character == 'a' || character == 'e' || character == 'i' || character == 'o' || character == 'u';\n}\n\nstd::vector<int> CountVowelStrings(std::vector<std::string> &wordList, std::vector<std::vector<int>> &queryRanges)\n{\n    std::vector<int> result;\n    for(auto &query : queryRanges)\n    {\n        int vowel_string_count= 0;\n        for(int index= query[0]; index <= query[1]; index++)\n        {\n            if(IsVowel(wordList[index].front()) && IsVowel(wordList[index].back()))\n            {\n                vowel_string_count++;\n            }\n        }\n        result.push_back(vowel_string_count);\n    }\n    return result;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findMinimumCapability(vector<int> &numberList, int requiredCount)\n{\n    int size= numberList.size(), left= 1, right= 1e9;\n    while(left < right)\n    {\n        int mid= left + (right - left) / 2, index= 0, count= 0;\n        for(int j= 0; j < size; ++j)\n        {\n            if(numberList[j] <= mid)\n            {\n                ++count;\n                index= j + 2;\n                while(index + 1 < size && (index == j + 1 || numberList[index] > mid))\n                    ++index;\n            }\n        }\n        if(count < requiredCount)\n            left= mid + 1;\n        else\n            right= mid;\n    }\n    return left;\n}",
    "output": "#include <vector>\n\nint FindMinimumCapability(std::vector<int> &numberList, int requiredCount)\n{\n    int size= numberList.size(), left= 1, right= 1e9;\n    while(left < right)\n    {\n        int mid= left + (right - left) / 2, index= 0, count= 0;\n        for(int j= 0; j < size; ++j)\n        {\n            if(numberList[j] <= mid)\n            {\n                ++count;\n                index= j + 2;\n                while(index + 1 < size && (index == j + 1 || numberList[index] > mid))\n                    ++index;\n            }\n        }\n        if(count < requiredCount)\n            left= mid + 1;\n        else\n            right= mid;\n    }\n    return left;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minCostToEqualBaskets(vector<int> &basket1, vector<int> &basket2)\n{\n    unordered_map<int, int> differenceCount;\n    for (int index = 0; index < basket1.size(); index++)\n    {\n        differenceCount[basket1[index] - basket2[index]]++;\n    }\n\n    int minimumCost = INT_MAX, currentCost = 0;\n    for (auto it = differenceCount.begin(); it != differenceCount.end(); ++it) // traditional for loop\n    {\n        const auto &entry = *it;\n        if (entry.second == differenceCount[-entry.first])\n        {\n            currentCost = 0;\n            for (int index = 0; index < basket1.size(); index++)\n            {\n                if (basket1[index] - basket2[index] == entry.first)\n                {\n                    currentCost += min(basket1[index], basket2[index]);\n                }\n            }\n            minimumCost = min(minimumCost, currentCost);\n        }\n    }\n\n    return minimumCost == INT_MAX ? -1 : minimumCost / 2;\n}",
    "output": "#include <vector>\n#include <unordered_map>\n#include <algorithm>\n#include <limits>\n\nint MinCostToEqualBaskets(std::vector<int> &basket1, std::vector<int> &basket2)\n{\n    std::unordered_map<int, int> difference_count;\n    for(int index= 0; index < basket1.size(); index++)\n    {\n        difference_count[basket1[index] - basket2[index]]++;\n    }\n\n    int minimum_cost= std::numeric_limits<int>::max(), current_cost= 0;\n    for(const auto &entry : difference_count)\n    {\n        if(entry.second == difference_count[-entry.first])\n        {\n            current_cost= 0;\n            for(int index= 0; index < basket1.size(); index++)\n            {\n                if(basket1[index] - basket2[index] == entry.first)\n                {\n                    current_cost+= std::min(basket1[index], basket2[index]);\n                }\n            }\n            minimum_cost= std::min(minimum_cost, current_cost);\n        }\n    }\n\n    return minimum_cost == std::numeric_limits<int>::max() ? -1 : minimum_cost / 2;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint concatenationValue(vector<int> &numberList)\n{\n    int concatenatedValue= 0;\n    while(!numberList.empty())\n    {\n        int size= numberList.size();\n        if(size == 1)\n        {\n            concatenatedValue+= numberList[0];\n            numberList.pop_back();\n        }\n        else\n        {\n            concatenatedValue+= stoi(to_string(numberList[0]) + to_string(numberList[size - 1]));\n            numberList.erase(numberList.begin());\n            numberList.pop_back();\n        }\n    }\n    return concatenatedValue;\n}",
    "output": "#include <vector>\n#include <string>\n\nint ConcatenationValue(std::vector<int> &numberList)\n{\n    int concatenated_value= 0;\n    while(!numberList.empty())\n    {\n        int size= numberList.size();\n        if(size == 1)\n        {\n            concatenated_value+= numberList[0];\n            numberList.pop_back();\n        }\n        else\n        {\n            concatenated_value+= std::stoi(std::to_string(numberList[0]) + std::to_string(numberList[size - 1]));\n            numberList.erase(numberList.begin());\n            numberList.pop_back();\n        }\n    }\n    return concatenated_value;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countFairPairs(vector<int> &numbers, int lowerBound, int upperBound)\n{\n    int size= numbers.size();\n    int fairPairCount= 0;\n    for(int indexI= 0; indexI < size; ++indexI)\n    {\n        for(int indexJ= indexI + 1; indexJ < size; ++indexJ)\n        {\n            if((lowerBound <= numbers[indexI] + numbers[indexJ]) && (numbers[indexI] + numbers[indexJ] <= upperBound))\n            {\n                fairPairCount++;\n            }\n        }\n    }\n    return fairPairCount;\n}",
    "output": "#include <vector>\n\nint CountFairPairs(std::vector<int> &numbers, int lowerBound, int upperBound)\n{\n    int size= numbers.size();\n    int fair_pair_count= 0;\n    for(int index_i= 0; index_i < size; ++index_i)\n    {\n        for(int index_j= index_i + 1; index_j < size; ++index_j)\n        {\n            if((lowerBound <= numbers[index_i] + numbers[index_j]) && (numbers[index_i] + numbers[index_j] <= upperBound))\n            {\n                fair_pair_count++;\n            }\n        }\n    }\n    return fair_pair_count;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\n// Include this for log2 function\n\nusing namespace std;\n\nvector<vector<int>> shortestSubstringQueries(const string &inputString, const vector<vector<int>> &queryPairs)\n{\n    int stringLength = inputString.length();\n    unordered_map<int, int> indexMap;\n\n    for(int currentIndex = 0, currentValue = 0, bitMask = 0; currentIndex < stringLength; currentIndex++)\n    {\n        bitMask |= 1 << (inputString[currentIndex] - '0');\n        currentValue = (currentValue << 1) | (inputString[currentIndex] - '0');\n\n        for(int bitPosition = 0; bitPosition <= 9 && currentIndex + 1 - (1 << bitPosition) >= 0; bitPosition++)\n        {\n            int newValue = currentValue & ((1 << (bitPosition + 1)) - 1);\n            if(indexMap.count(newValue) == 0)\n                indexMap[newValue] = currentIndex + 1 - (1 << bitPosition);\n        }\n    }\n\n    vector<vector<int>> result;\n    for(int i = 0; i < queryPairs.size(); ++i)\n    {\n        const auto &query = queryPairs[i];\n        int targetValue = query[0] ^ query[1];\n        if(indexMap.count(targetValue))\n            result.push_back({indexMap[targetValue], indexMap[targetValue] + static_cast<int>(log2(targetValue))});\n        else\n            result.push_back({-1, -1});\n    }\n\n    return result;\n}",
    "output": "#include <string>\n#include <unordered_map>\n#include <vector>\n\nstd::vector<std::vector<int>> ShortestSubstringQueries(const std::string &inputString, const std::vector<std::vector<int>> &queryPairs)\n{\n    int string_length= inputString.length();\n    std::unordered_map<int, int> index_map;\n\n    for(int current_index= 0, current_value= 0, bit_mask= 0; current_index < string_length; current_index++)\n    {\n        bit_mask|= 1 << (inputString[current_index] - '0');\n        current_value= (current_value << 1) | (inputString[current_index] - '0');\n\n        for(int bit_position= 0; bit_position <= 9 && current_index + 1 - (1 << bit_position) >= 0; bit_position++)\n        {\n            int new_value= current_value & ((1 << (bit_position + 1)) - 1);\n            if(index_map.count(new_value) == 0)\n                index_map[new_value]= current_index + 1 - (1 << bit_position);\n        }\n    }\n\n    std::vector<std::vector<int>> result;\n    for(const auto &query : queryPairs)\n    {\n        int target_value= query[0] ^ query[1];\n        if(index_map.count(target_value))\n            result.push_back({index_map[target_value], index_map[target_value] + static_cast<int>(log2(target_value))});\n        else\n            result.push_back({-1, -1});\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMinimumScore(string sourceString, string targetString)\n{\n    int sourceLength= sourceString.size(), targetLength= targetString.size();\n    vector<vector<int>> dynamicProgrammingTable(sourceLength + 1, vector<int>(targetLength + 1, 1e6));\n    dynamicProgrammingTable[0][0]= 0;\n    for(int sourceIndex= 0; sourceIndex < sourceLength; ++sourceIndex)\n        for(int targetIndex= 0; targetIndex < targetLength; ++targetIndex)\n            if(sourceString[sourceIndex] == targetString[targetIndex])\n                dynamicProgrammingTable[sourceIndex + 1][targetIndex + 1]= min(dynamicProgrammingTable[sourceIndex + 1][targetIndex + 1], dynamicProgrammingTable[sourceIndex][targetIndex]);\n            else\n                dynamicProgrammingTable[sourceIndex + 1][targetIndex]= min(dynamicProgrammingTable[sourceIndex + 1][targetIndex], dynamicProgrammingTable[sourceIndex][targetIndex] + 1);\n    int minimumScore= 1e6;\n    for(int sourceIndex= 0; sourceIndex < sourceLength; ++sourceIndex)\n        minimumScore= min(minimumScore, dynamicProgrammingTable[sourceIndex + 1][targetLength]);\n    return minimumScore;\n}",
    "output": "#include <string>\n#include <vector>\n#include <algorithm>\n\nint CalculateMinimumScore(std::string sourceString, std::string targetString)\n{\n    int source_length= sourceString.size(), target_length= targetString.size();\n    std::vector<std::vector<int>> dynamic_programming_table(source_length + 1, std::vector<int>(target_length + 1, 1e6));\n    dynamic_programming_table[0][0]= 0;\n    for(int source_index= 0; source_index < source_length; ++source_index)\n        for(int target_index= 0; target_index < target_length; ++target_index)\n            if(sourceString[source_index] == targetString[target_index])\n                dynamic_programming_table[source_index + 1][target_index + 1]= std::min(dynamic_programming_table[source_index + 1][target_index + 1], dynamic_programming_table[source_index][target_index]);\n            else\n                dynamic_programming_table[source_index + 1][target_index]= std::min(dynamic_programming_table[source_index + 1][target_index], dynamic_programming_table[source_index][target_index] + 1);\n    int minimum_score= 1e6;\n    for(int source_index= 0; source_index < source_length; ++source_index)\n        minimum_score= std::min(minimum_score, dynamic_programming_table[source_index + 1][target_length]);\n    return minimum_score;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateDifferenceMaxMin(int inputNumber)\n{\n    int maxRemapValue = 1, minRemapValue = 9;\n    string numberString = to_string(inputNumber);\n    for (int i = 0; i < numberString.size(); ++i)\n    {\n        char digitChar = numberString[i];\n        int digitValue = digitChar - '0';\n        maxRemapValue = max(maxRemapValue, 9 - digitValue);\n        if (digitValue != 0)\n        {\n            minRemapValue = min(minRemapValue, digitValue);\n        }\n    }\n    int maxCalculatedValue = inputNumber + maxRemapValue * (numberString.length() - count(numberString.begin(), numberString.end(), '9' - maxRemapValue));\n    int minCalculatedValue = inputNumber - minRemapValue * count(numberString.begin(), numberString.end(), minRemapValue + '0');\n    return maxCalculatedValue - minCalculatedValue;\n}",
    "output": "#include <string>\n#include <algorithm>\n\nint CalculateDifferenceMaxMin(int inputNumber)\n{\n    int max_remap_value= 1, min_remap_value= 9;\n    std::string number_string= std::to_string(inputNumber);\n    for(char digitChar : number_string)\n    {\n        int digit_value= digitChar - '0';\n        max_remap_value= std::max(max_remap_value, 9 - digit_value);\n        if(digit_value != 0)\n        {\n            min_remap_value= std::min(min_remap_value, digit_value);\n        }\n    }\n    int max_calculated_value= inputNumber + max_remap_value * (number_string.length() - std::count(number_string.begin(), number_string.end(), '9' - max_remap_value));\n    int min_calculated_value= inputNumber - min_remap_value * std::count(number_string.begin(), number_string.end(), min_remap_value + '0');\n    return max_calculated_value - min_calculated_value;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minScoreAfterChange(vector<int> &numbers)\n{\n    int size = numbers.size();\n    int firstMin = numbers[0], secondMin = numbers[1], lastMax = numbers[size - 1], secondLastMax = numbers[size - 2];\n\n    for(int index = 1; index < size - 1; index++)\n    {\n        firstMin = min(firstMin, numbers[index]);\n        secondMin = min(secondMin, numbers[index + 1]);\n        lastMax = max(lastMax, numbers[index]);\n        secondLastMax = max(secondLastMax, numbers[index - 1]);\n    }\n\n    int low = min(min(firstMin, lastMax), min(secondMin, secondLastMax));\n    int high = max(max(firstMin, lastMax), max(secondMin, secondLastMax));\n\n    return high - low;\n}",
    "output": "#include <algorithm>\n#include <vector>\n\nint MinScoreAfterChange(std::vector<int> &numbers)\n{\n    int size= numbers.size();\n    int first_min= numbers[0], second_min= numbers[1], last_max= numbers[size - 1], second_last_max= numbers[size - 2];\n\n    for(int index= 1; index < size - 1; index++)\n    {\n        first_min= std::min(first_min, numbers[index]);\n        second_min= std::min(second_min, numbers[index + 1]);\n        last_max= std::max(last_max, numbers[index]);\n        second_last_max= std::max(second_last_max, numbers[index - 1]);\n    }\n\n    int low= std::min(std::min(first_min, last_max), std::min(second_min, second_last_max));\n    int high= std::max(std::max(first_min, last_max), std::max(second_min, second_last_max));\n\n    return high - low;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findMinNonExpressibleInteger(vector<int> &sortedNumbers)\n{\n    int minimumNonExpressibleInteger = 1;\n    sort(sortedNumbers.begin(), sortedNumbers.end());\n    for (int i = 0; i < sortedNumbers.size(); ++i)\n    {\n        int currentNumber = sortedNumbers[i];\n        if (currentNumber > minimumNonExpressibleInteger)\n            break;\n        minimumNonExpressibleInteger += currentNumber;\n    }\n    return minimumNonExpressibleInteger;\n}",
    "output": "#include <vector>\n#include <algorithm>\n\nint FindMinNonExpressibleInteger(std::vector<int> &sortedNumbers)\n{\n    int minimum_non_expressible_integer= 1;\n    std::sort(sortedNumbers.begin(), sortedNumbers.end());\n    for(int current_number : sortedNumbers)\n    {\n        if(current_number > minimum_non_expressible_integer)\n            break;\n        minimum_non_expressible_integer += current_number;\n    }\n    return minimum_non_expressible_integer;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> solve(vector<int> &sourceArray, vector<int> &targetArray, vector<vector<int>> &queries)\n{\n    vector<int> result;\n    for (int i = 0; i < queries.size(); ++i)\n    {\n        auto &query = queries[i];\n        if (query[0] == 1)\n        {\n            for (int index = query[1]; index <= query[2]; index++)\n            {\n                sourceArray[index] ^= 1;\n            }\n        }\n        else if (query[0] == 2)\n        {\n            for (int index = 0; index < sourceArray.size(); index++)\n            {\n                targetArray[index] += sourceArray[index] * query[1];\n            }\n        }\n        else if (query[0] == 3)\n        {\n            int totalSum = 0;\n            for (int j = 0; j < targetArray.size(); ++j)\n            {\n                totalSum += targetArray[j];\n            }\n            result.push_back(totalSum);\n        }\n    }\n    return result;\n}",
    "output": "#include <vector>\n\nstd::vector<int> Solve(std::vector<int> &sourceArray, std::vector<int> &targetArray, std::vector<std::vector<int>> &queries)\n{\n    std::vector<int> result;\n    for(auto &query : queries)\n    {\n        if(query[0] == 1)\n        {\n            for(int index= query[1]; index <= query[2]; index++)\n            {\n                sourceArray[index] ^= 1;\n            }\n        }\n        else if(query[0] == 2)\n        {\n            for(int index= 0; index < sourceArray.size(); index++)\n            {\n                targetArray[index] += sourceArray[index] * query[1];\n            }\n        }\n        else if(query[0] == 3)\n        {\n            int total_sum = 0;\n            for(auto number : targetArray)\n            {\n                total_sum += number;\n            }\n            result.push_back(total_sum);\n        }\n    }\n    return result;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> mergeNumbers(vector<vector<int>> &numberList1, vector<vector<int>> &numberList2)\n{\n    map<int, int> mergedMap;\n    vector<vector<int>> mergedResult;\n\n    for (int i = 0; i < numberList1.size(); ++i)\n    {\n        const auto &currentPair = numberList1[i];\n        mergedMap[currentPair[0]] += currentPair[1];\n    }\n\n    for (int i = 0; i < numberList2.size(); ++i)\n    {\n        const auto &currentPair = numberList2[i];\n        mergedMap[currentPair[0]] += currentPair[1];\n    }\n\n    for (const auto &currentPair : mergedMap)\n    {\n        mergedResult.push_back({currentPair.first, currentPair.second});\n    }\n\n    return mergedResult;\n}",
    "output": "#include <map>\n#include <vector>\n\nstd::vector<std::vector<int>> MergeNumbers(std::vector<std::vector<int>> &numberList1, std::vector<std::vector<int>> &numberList2)\n{\n    std::map<int, int> merged_map;\n    std::vector<std::vector<int>> merged_result;\n\n    for(const auto &current_pair : numberList1)\n    {\n        merged_map[current_pair[0]]+= current_pair[1];\n    }\n\n    for(const auto &current_pair : numberList2)\n    {\n        merged_map[current_pair[0]]+= current_pair[1];\n    }\n\n    for(const auto &current_pair : merged_map)\n    {\n        merged_result.push_back({current_pair.first, current_pair.second});\n    }\n\n    return merged_result;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "int minOperations(int inputNumber)\n{\n    int totalOperations= 0;\n    while(inputNumber)\n    {\n        totalOperations+= inputNumber % 2;\n        inputNumber/= 2;\n    }\n    return totalOperations;\n}",
    "output": "int MinOperations(int inputNumber)\n{\n    int total_operations= 0;\n    while(inputNumber)\n    {\n        total_operations+= inputNumber % 2;\n        inputNumber/= 2;\n    }\n    return total_operations;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int modulo = 1e9 + 7;\n\nint countSquareFreeSubsets(vector<int> &inputNumbers)\n{\n    unordered_map<int, int> frequencyCounter;\n    for (int number : inputNumbers)\n    {\n        frequencyCounter[number]++;\n    }\n\n    vector<vector<long long>> dynamicProgramming(61, vector<long long>(1001));\n    dynamicProgramming[0][0] = 1;\n    int currentIndex = 0;\n    for (auto it = frequencyCounter.begin(); it != frequencyCounter.end(); ++it)\n    {\n        const int number = it->first;\n        const int frequency = it->second;\n        currentIndex++;\n        for (int squareCount = 0; squareCount <= 60; squareCount++)\n        {\n            for (int nonSquareCount = 0; nonSquareCount + frequency <= 1000; nonSquareCount++)\n            {\n                dynamicProgramming[currentIndex][nonSquareCount + frequency] += dynamicProgramming[currentIndex - 1][nonSquareCount] * ((1LL << frequency) - 1) % modulo;\n                dynamicProgramming[currentIndex][nonSquareCount + frequency] %= modulo;\n                dynamicProgramming[currentIndex][nonSquareCount] += dynamicProgramming[currentIndex - 1][nonSquareCount];\n                dynamicProgramming[currentIndex][nonSquareCount] %= modulo;\n\n                if ((squareCount / number) % 2 == 1)\n                {\n                    dynamicProgramming[currentIndex][nonSquareCount + frequency] -= dynamicProgramming[currentIndex - 1][nonSquareCount] * ((1LL << (frequency - 1)) - 1) % modulo;\n                    if (dynamicProgramming[currentIndex][nonSquareCount + frequency] < 0)\n                        dynamicProgramming[currentIndex][nonSquareCount + frequency] += modulo;\n                }\n            }\n        }\n    }\n    return dynamicProgramming[currentIndex][0];\n}",
    "output": "#include <unordered_map>\n#include <vector>\n\nconst int modulo= 1e9 + 7;\n\nint CountSquareFreeSubsets(std::vector<int> &inputNumbers)\n{\n    std::unordered_map<int, int> frequency_counter;\n    for(int number : inputNumbers)\n    {\n        frequency_counter[number]++;\n    }\n\n    std::vector<std::vector<long long>> dynamic_programming(61, std::vector<long long>(1001));\n    dynamic_programming[0][0]= 1;\n    int current_index= 0;\n    for(const auto &[number, frequency] : frequency_counter)\n    {\n        current_index++;\n        for(int square_count= 0; square_count <= 60; square_count++)\n        {\n            for(int non_square_count= 0; non_square_count + frequency <= 1000; non_square_count++)\n            {\n                dynamic_programming[current_index][non_square_count + frequency]+= dynamic_programming[current_index - 1][non_square_count] * ((1LL << frequency) - 1) % modulo;\n                dynamic_programming[current_index][non_square_count + frequency]%= modulo;\n                dynamic_programming[current_index][non_square_count]+= dynamic_programming[current_index - 1][non_square_count];\n                dynamic_programming[current_index][non_square_count]%= modulo;\n\n                if((square_count / number) % 2 == 1)\n                {\n                    dynamic_programming[current_index][non_square_count + frequency]-= dynamic_programming[current_index - 1][non_square_count] * ((1LL << (frequency - 1)) - 1) % modulo;\n                    if(dynamic_programming[current_index][non_square_count + frequency] < 0)\n                        dynamic_programming[current_index][non_square_count + frequency]+= modulo;\n                }\n            }\n        }\n    }\n    return dynamic_programming[current_index][0];\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring smallestWordForLCP(vector<vector<int>> &longestCommonPrefix)\n{\n    int matrixSize = longestCommonPrefix.size();\n    string resultWord(matrixSize, 'a');\n    for(int rowIndex = 1; rowIndex < matrixSize; ++rowIndex)\n        for(int colIndex = 1; colIndex < matrixSize; ++colIndex)\n        {\n            if(longestCommonPrefix[rowIndex][colIndex] > min(longestCommonPrefix[rowIndex - 1][colIndex], longestCommonPrefix[rowIndex][colIndex - 1]))\n            {\n                resultWord[rowIndex + longestCommonPrefix[rowIndex][colIndex] - 1] = max(resultWord[rowIndex + longestCommonPrefix[rowIndex][colIndex] - 1], (char)(resultWord[rowIndex - 1] + 1));\n            }\n            else if(longestCommonPrefix[rowIndex][colIndex] < min(longestCommonPrefix[rowIndex - 1][colIndex], longestCommonPrefix[rowIndex][colIndex - 1]))\n            {\n                return \"\";\n            }\n        }\n    return resultWord;\n}",
    "output": "#include <string>\n#include <vector>\n\nstd::string SmallestWordForLCP(std::vector<std::vector<int>> &longestCommonPrefix)\n{\n    int matrix_size= longestCommonPrefix.size();\n    std::string result_word(matrix_size, 'a');\n    for(int row_index= 1; row_index < matrix_size; ++row_index)\n        for(int col_index= 1; col_index < matrix_size; ++col_index)\n        {\n            if(longestCommonPrefix[row_index][col_index] > std::min(longestCommonPrefix[row_index - 1][col_index], longestCommonPrefix[row_index][col_index - 1]))\n            {\n                result_word[row_index + longestCommonPrefix[row_index][col_index] - 1]= std::max(result_word[row_index + longestCommonPrefix[row_index][col_index] - 1], (char)(result_word[row_index - 1] + 1));\n            }\n            else if(longestCommonPrefix[row_index][col_index] < std::min(longestCommonPrefix[row_index - 1][col_index], longestCommonPrefix[row_index][col_index - 1]))\n            {\n                return \"\";\n            }\n        }\n    return result_word;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> getAnswer(vector<int> &inputNumbers)\n{\n    int size= inputNumbers.size();\n    vector<int> leftSum(size, 0), rightSum(size, 0), result(size, 0);\n\n    for(int index= 1; index < size; index++)\n    {\n        leftSum[index]= leftSum[index - 1] + inputNumbers[index - 1];\n    }\n\n    for(int index= size - 2; index >= 0; index--)\n    {\n        rightSum[index]= rightSum[index + 1] + inputNumbers[index + 1];\n    }\n\n    for(int index= 0; index < size; index++)\n    {\n        result[index]= abs(leftSum[index] - rightSum[index]);\n    }\n\n    return result;\n}",
    "output": "#include <cstdlib>\n#include <vector>\n\nstd::vector<int> GetAnswer(std::vector<int> &inputNumbers)\n{\n    int size = inputNumbers.size();\n    std::vector<int> left_sum(size, 0), right_sum(size, 0), result(size, 0);\n\n    for(int index = 1; index < size; index++)\n    {\n        left_sum[index] = left_sum[index - 1] + inputNumbers[index - 1];\n    }\n\n    for(int index = size - 2; index >= 0; index--)\n    {\n        right_sum[index] = right_sum[index + 1] + inputNumbers[index + 1];\n    }\n\n    for(int index = 0; index < size; index++)\n    {\n        result[index] = std::abs(left_sum[index] - right_sum[index]);\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> divisibilityArray(string numberString, int divisor)\n{\n    vector<int> divisibilityResults(numberString.size());\n    int currentValue= 0;\n    for(size_t index= 0; index < numberString.length(); ++index)\n    {\n        currentValue= (currentValue * 10 + (numberString[index] - '0')) % divisor;\n        divisibilityResults[index]= (currentValue == 0) ? 1 : 0;\n    }\n    return divisibilityResults;\n}",
    "output": "#include <string>\n#include <vector>\n\nstd::vector<int> DivisibilityArray(std::string numberString, int divisor)\n{\n    std::vector<int> divisibility_results(numberString.size());\n    int current_value= 0;\n    for(size_t index= 0; index < numberString.length(); ++index)\n    {\n        current_value= (current_value * 10 + (numberString[index] - '0')) % divisor;\n        divisibility_results[index]= (current_value == 0) ? 1 : 0;\n    }\n    return divisibility_results;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minTime(vector<vector<int>> &grid)\n{\n    int rows= grid.size(), columns= grid[0].size();\n    vector<vector<int>> visited(rows, vector<int>(columns, 1000000));\n\n    const int directionX[]= {-1, 0, 1, 0};\n    const int directionY[]= {0, 1, 0, -1};\n\n    visited[0][0]= 0;\n\n    queue<pair<int, int>> positionQueue;\n    positionQueue.push({0, 0});\n\n    while(!positionQueue.empty())\n    {\n        auto [currentX, currentY]= positionQueue.front();\n        positionQueue.pop();\n\n        for(int i= 0; i < 4; i++)\n        {\n            int nextX= currentX + directionX[i];\n            int nextY= currentY + directionY[i];\n\n            if(nextX >= 0 && nextX < rows && nextY >= 0 && nextY < columns)\n            {\n                int time= max(grid[nextX][nextY], visited[currentX][currentY] + 1);\n                if(visited[nextX][nextY] > time)\n                {\n                    visited[nextX][nextY]= time;\n                    positionQueue.push({nextX, nextY});\n                }\n            }\n        }\n    }\n\n    return visited[rows - 1][columns - 1] == 1000000 ? -1 : visited[rows - 1][columns - 1];\n}",
    "output": "#include <queue>\n#include <vector>\n\nint MinTime(std::vector<std::vector<int>> &grid)\n{\n    int rows= grid.size(), columns= grid[0].size();\n    std::vector<std::vector<int>> visited(rows, std::vector<int>(columns, 1000000));\n\n    const int direction_x[]= {-1, 0, 1, 0};\n    const int direction_y[]= {0, 1, 0, -1};\n\n    visited[0][0]= 0;\n\n    std::queue<std::pair<int, int>> position_queue;\n    position_queue.push({0, 0});\n\n    while(!position_queue.empty())\n    {\n        auto [current_x, current_y]= position_queue.front();\n        position_queue.pop();\n\n        for(int i= 0; i < 4; i++)\n        {\n            int next_x= current_x + direction_x[i];\n            int next_y= current_y + direction_y[i];\n\n            if(next_x >= 0 && next_x < rows && next_y >= 0 && next_y < columns)\n            {\n                int time= std::max(grid[next_x][next_y], visited[current_x][current_y] + 1);\n                if(visited[next_x][next_y] > time)\n                {\n                    visited[next_x][next_y]= time;\n                    position_queue.push({next_x, next_y});\n                }\n            }\n        }\n    }\n\n    return visited[rows - 1][columns - 1] == 1000000 ? -1 : visited[rows - 1][columns - 1];\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMinSumOfTwoNumbers(string inputNumber)\n{\n    vector<int> digitCount(10, 0);\n    for (char digit : inputNumber)\n        digitCount[digit - '0']++;\n\n    int firstNumber = 0, secondNumber = 0;\n    for (int i = 1; i <= 9; i += 2)\n    {\n        int count = digitCount[i];\n        while (count--)\n            firstNumber = firstNumber * 10 + i;\n    }\n    for (int i = 0; i <= 9; i += 2)\n    {\n        int count = digitCount[i];\n        while (count--)\n            secondNumber = secondNumber * 10 + i;\n    }\n    return firstNumber + secondNumber;\n}",
    "output": "#include <string>\n#include <vector>\n\nint CalculateMinSumOfTwoNumbers(std::string inputNumber)\n{\n    std::vector<int> digit_count(10, 0);\n    for(char digit : inputNumber)\n        digit_count[digit - '0']++;\n\n    int first_number= 0, second_number= 0;\n    for(int i= 1; i <= 9; i+= 2)\n    {\n        int count= digit_count[i];\n        while(count--)\n            first_number= first_number * 10 + i;\n    }\n    for(int i= 0; i <= 9; i+= 2)\n    {\n        int count= digit_count[i];\n        while(count--)\n            second_number= second_number * 10 + i;\n    }\n    return first_number + second_number;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "int calculateColoredCells(int gridSize)\n{\n    return gridSize * gridSize + (gridSize - 1) * (gridSize - 1);\n}",
    "output": "int CalculateColoredCells(int gridSize)\n{\n    return gridSize * gridSize + (gridSize - 1) * (gridSize - 1);\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int modulo = 1e9 + 7;\n\nint totalWaysToSplitRanges(vector<vector<int>> &ranges)\n{\n    sort(ranges.begin(), ranges.end(), [](const vector<int> &firstRange, const vector<int> &secondRange)\n         { return firstRange[1] < secondRange[1]; });\n    int overlappingCount = 0, nonOverlappingCount = 1, previousEnd = -1;\n    for (int i = 0; i < ranges.size(); ++i)\n    {\n        const auto &currentRange = ranges[i];\n        if (currentRange[0] <= previousEnd)\n        {\n            overlappingCount++;\n        }\n        else\n        {\n            nonOverlappingCount++;\n        }\n        previousEnd = max(previousEnd, currentRange[1]);\n    }\n    long result = 1;\n    for (int i = 1; i <= overlappingCount; ++i)\n    {\n        result = (result * 2) % modulo;\n    }\n    return result;\n}",
    "output": "#include <algorithm>\n#include <vector>\n\nconst int modulo= 1e9 + 7;\n\nint TotalWaysToSplitRanges(std::vector<std::vector<int>> &ranges)\n{\n    std::sort(ranges.begin(), ranges.end(), [](const std::vector<int> &firstRange, const std::vector<int> &secondRange)\n              { return firstRange[1] < secondRange[1]; });\n    int overlapping_count= 0, non_overlapping_count= 1, previous_end= -1;\n    for(const auto &currentRange : ranges)\n    {\n        if(currentRange[0] <= previous_end)\n        {\n            overlapping_count++;\n        }\n        else\n        {\n            non_overlapping_count++;\n        }\n        previous_end= std::max(previous_end, currentRange[1]);\n    }\n    long result= 1;\n    for(int i= 1; i <= overlapping_count; ++i)\n    {\n        result= (result * 2) % modulo;\n    }\n    return result;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint possibleRoots(const vector<vector<int>> &edges, const vector<vector<int>> &guesses, int k)\n{\n    int nodeCount = edges.size() + 1;\n    vector<int> inDegree(nodeCount, 0);\n    unordered_set<int> guessParents;\n\n    for (int i = 0; i < guesses.size(); ++i)\n    {\n        guessParents.insert(guesses[i][0]);\n    }\n\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        inDegree[edges[i][1]]++;\n    }\n\n    int possibleRootsCount = 0;\n    for (int i = 0; i < nodeCount; ++i)\n    {\n        if (inDegree[i] == 0)\n        {\n            if (k == 0 || guessParents.find(i) != guessParents.end())\n            {\n                possibleRootsCount++;\n            }\n        }\n        else if (inDegree[i] == 1 && guesses.size() - k < inDegree[i])\n        {\n            possibleRootsCount++;\n        }\n    }\n    return possibleRootsCount;\n}",
    "output": "#include <unordered_set>\n#include <vector>\n\nint PossibleRoots(const std::vector<std::vector<int>> &edges, const std::vector<std::vector<int>> &guesses, int k)\n{\n    int node_count= edges.size() + 1;\n    std::vector<int> in_degree(node_count, 0);\n    std::unordered_set<int> guess_parents;\n\n    for(const auto &guess : guesses)\n    {\n        guess_parents.insert(guess[0]);\n    }\n\n    for(const auto &edge : edges)\n    {\n        in_degree[edge[1]]++;\n    }\n\n    int possible_roots_count= 0;\n    for(int i= 0; i < node_count; ++i)\n    {\n        if(in_degree[i] == 0)\n        {\n            if(k == 0 || guess_parents.find(i) != guess_parents.end())\n            {\n                possible_roots_count++;\n            }\n        }\n        else if(in_degree[i] == 1 && guesses.size() - k < in_degree[i])\n        {\n            possible_roots_count++;\n        }\n    }\n    return possible_roots_count;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "int calculatePillowPosition(int numberOfPillows, int time)\n{\n    time%= (2 * numberOfPillows - 2);\n    if(time <= numberOfPillows - 1)\n        return time + 1;\n    else\n        return 2 * numberOfPillows - time - 1;\n}",
    "output": "int CalculatePillowPosition(int numberOfPillows, int time)\n{\n    time %= (2 * numberOfPillows - 2);\n    if(time <= numberOfPillows - 1)\n        return time + 1;\n    else\n        return 2 * numberOfPillows - time - 1;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nint kthLargestLevelSum(TreeNode *rootNode, int k)\n{\n    vector<int> levelSums;\n    queue<TreeNode *> nodeQueue;\n    nodeQueue.push(rootNode);\n\n    while(!nodeQueue.empty())\n    {\n        int levelSum= 0;\n        int levelSize= nodeQueue.size();\n        for(int i= 0; i < levelSize; ++i)\n        {\n            TreeNode *currentNode= nodeQueue.front();\n            nodeQueue.pop();\n            levelSum+= currentNode->value;\n\n            if(currentNode->leftChild)\n                nodeQueue.push(currentNode->leftChild);\n            if(currentNode->rightChild)\n                nodeQueue.push(currentNode->rightChild);\n        }\n\n        levelSums.push_back(levelSum);\n    }\n\n    sort(levelSums.begin(), levelSums.end(), greater<int>());\n    return (k > levelSums.size() ? -1 : levelSums[k - 1]);\n}",
    "output": "#include <algorithm>\n#include <queue>\n#include <vector>\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nint KthLargestLevelSum(TreeNode *rootNode, int k)\n{\n    std::vector<int> level_sums;\n    std::queue<TreeNode *> node_queue;\n    node_queue.push(rootNode);\n\n    while(!node_queue.empty())\n    {\n        int level_sum= 0;\n        int level_size= node_queue.size();\n        for(int i= 0; i < level_size; ++i)\n        {\n            TreeNode *current_node= node_queue.front();\n            node_queue.pop();\n            level_sum+= current_node->value;\n\n            if(current_node->leftChild)\n                node_queue.push(current_node->leftChild);\n            if(current_node->rightChild)\n                node_queue.push(current_node->rightChild);\n        }\n\n        level_sums.push_back(level_sum);\n    }\n\n    std::sort(level_sums.begin(), level_sums.end(), std::greater<int>());\n    return (k > level_sums.size() ? -1 : level_sums[k - 1]);\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint gcd(int firstNumber, int secondNumber)\n{\n    return secondNumber == 0 ? firstNumber : gcd(secondNumber, firstNumber % secondNumber);\n}\n\nint findValidSplit(const vector<int> &numberList)\n{\n    int length= numberList.size();\n    vector<int> prefixProduct(length);\n    vector<int> suffixProduct(length);\n\n    prefixProduct[0]= numberList[0];\n    suffixProduct[length - 1]= numberList[length - 1];\n\n    for(int index= 1; index < length; ++index)\n        prefixProduct[index]= prefixProduct[index - 1] * numberList[index];\n\n    for(int index= length - 2; index >= 0; --index)\n        suffixProduct[index]= suffixProduct[index + 1] * numberList[index];\n\n    for(int index= 0; index < length - 1; ++index)\n    {\n        if(gcd(prefixProduct[index], suffixProduct[index + 1]) == 1)\n            return index;\n    }\n\n    return -1;\n}",
    "output": "#include <vector>\n\nint Gcd(int firstNumber, int secondNumber)\n{\n    return secondNumber == 0 ? firstNumber : Gcd(secondNumber, firstNumber % secondNumber);\n}\n\nint FindValidSplit(const std::vector<int> &numberList)\n{\n    int length= numberList.size();\n    std::vector<int> prefix_product(length);\n    std::vector<int> suffix_product(length);\n\n    prefix_product[0]= numberList[0];\n    suffix_product[length - 1]= numberList[length - 1];\n\n    for(int index= 1; index < length; ++index)\n        prefix_product[index]= prefix_product[index - 1] * numberList[index];\n\n    for(int index= length - 2; index >= 0; --index)\n        suffix_product[index]= suffix_product[index + 1] * numberList[index];\n\n    for(int index= 0; index < length - 1; ++index)\n    {\n        if(Gcd(prefix_product[index], suffix_product[index + 1]) == 1)\n            return index;\n    }\n\n    return -1;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int modulo = 1e9 + 7;\n\nint numberOfWays(int target, vector<vector<int>> &itemTypes)\n{\n    vector<int> dynamicProgramming(target + 1, 0);\n    dynamicProgramming[0] = 1;\n    for (int i = 0; i < itemTypes.size(); ++i)\n    {\n        auto &itemType = itemTypes[i];\n        int itemCount = itemType[0], itemMarks = itemType[1];\n        vector<int> tempDynamicProgramming(target + 1, 0);\n        for (int currentScore = 0; currentScore <= target; ++currentScore)\n        {\n            for (int itemUsed = 0; itemUsed <= itemCount && itemUsed * itemMarks + currentScore <= target; ++itemUsed)\n            {\n                tempDynamicProgramming[currentScore + itemUsed * itemMarks] = (tempDynamicProgramming[currentScore + itemUsed * itemMarks] + dynamicProgramming[currentScore]) % modulo;\n            }\n        }\n        dynamicProgramming = tempDynamicProgramming;\n    }\n    return dynamicProgramming[target];\n}",
    "output": "#include <vector>\n\nconst int modulo= 1e9 + 7;\n\nint NumberOfWays(int target, std::vector<std::vector<int>> &itemTypes)\n{\n    std::vector<int> dynamic_programming(target + 1, 0);\n    dynamic_programming[0]= 1;\n    for(auto &item_type : itemTypes)\n    {\n        int item_count= item_type[0], item_marks= item_type[1];\n        std::vector<int> temp_dynamic_programming(target + 1, 0);\n        for(int current_score= 0; current_score <= target; ++current_score)\n        {\n            for(int item_used= 0; item_used <= item_count && item_used * item_marks + current_score <= target; ++item_used)\n            {\n                temp_dynamic_programming[current_score + item_used * item_marks]= (temp_dynamic_programming[current_score + item_used * item_marks] + dynamic_programming[current_score]) % modulo;\n            }\n        }\n        dynamic_programming= temp_dynamic_programming;\n    }\n    return dynamic_programming[target];\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isVowel(char character)\n{\n    return character == 'a' || character == 'e' || character == 'i' || character == 'o' || character == 'u';\n}\n\nint countVowelStrings(vector<string> &words, int leftIndex, int rightIndex)\n{\n    int vowelCount= 0;\n    for(int index= leftIndex; index <= rightIndex; index++)\n    {\n        if(isVowel(words[index][0]) && isVowel(words[index][words[index].length() - 1]))\n        {\n            vowelCount++;\n        }\n    }\n    return vowelCount;\n}",
    "output": "#include <string>\n#include <vector>\n\nbool IsVowel(char character)\n{\n    return character == 'a' || character == 'e' || character == 'i' || character == 'o' || character == 'u';\n}\n\nint CountVowelStrings(std::vector<std::string> &words, int left_index, int right_index)\n{\n    int vowel_count= 0;\n    for(int index= left_index; index <= right_index; index++)\n    {\n        if(IsVowel(words[index][0]) && IsVowel(words[index][words[index].length() - 1]))\n        {\n            vowel_count++;\n        }\n    }\n    return vowel_count;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxScore(vector<int> &scores)\n{\n    sort(scores.begin(), scores.end());\n    int count= 0, totalPrefixSum= 0;\n    for(int index= 0; index < scores.size(); ++index)\n    {\n        if(totalPrefixSum + scores[index] > 0)\n        {\n            ++count;\n            totalPrefixSum+= scores[index];\n        }\n    }\n    return count;\n}",
    "output": "#include <vector>\n#include <algorithm>\n\nint MaxScore(std::vector<int> &scores)\n{\n    std::sort(scores.begin(), scores.end());\n    int count= 0, total_prefix_sum= 0;\n    for(int index= 0; index < scores.size(); ++index)\n    {\n        if(total_prefix_sum + scores[index] > 0)\n        {\n            ++count;\n            total_prefix_sum+= scores[index];\n        }\n    }\n    return count;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countBeautifulSubarrays(vector<int> &inputNumbers)\n{\n    vector<int> oddCount(20, 0);\n    vector<int> evenCount(20, 0);\n    evenCount[0] = 1;\n\n    for (int i = 0; i < inputNumbers.size(); ++i)\n    {\n        int currentNumber = inputNumbers[i];\n        bool isOdd = __builtin_parity(currentNumber);\n        for (int j = 19; j >= 0; j--)\n        {\n            int bitMask = 1 << j;\n            if (currentNumber & bitMask)\n            {\n                if (isOdd)\n                    swap(oddCount[j], evenCount[j]);\n                oddCount[j]++;\n            }\n            else\n            {\n                if (!isOdd)\n                    swap(oddCount[j], evenCount[j]);\n                evenCount[j]++;\n            }\n            currentNumber -= (currentNumber & bitMask);\n        }\n    }\n\n    long long result = 0;\n    for (int i = 0; i < 20; i++)\n        result += (long long)evenCount[i] * (evenCount[i] - 1) / 2;\n    return result;\n}",
    "output": "#include <vector>\n\nint CountBeautifulSubarrays(std::vector<int> &inputNumbers)\n{\n    std::vector<int> odd_count(20, 0);\n    std::vector<int> even_count(20, 0);\n    even_count[0] = 1;\n\n    for(int current_number : inputNumbers)\n    {\n        bool is_odd = __builtin_parity(current_number);\n        for(int i = 19; i >= 0; i--)\n        {\n            int bit_mask = 1 << i;\n            if(current_number & bit_mask)\n            {\n                if(is_odd)\n                    std::swap(odd_count[i], even_count[i]);\n                odd_count[i]++;\n            }\n            else\n            {\n                if(!is_odd)\n                    std::swap(odd_count[i], even_count[i]);\n                even_count[i]++;\n            }\n            current_number -= (current_number & bit_mask);\n        }\n    }\n\n    long long result = 0;\n    for(int i = 0; i < 20; i++)\n        result += (long long)even_count[i] * (even_count[i] - 1) / 2;\n    return result;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minTimeOn(vector<vector<int>> &taskList)\n{\n    vector<vector<int>> timeIntervals;\n    for (int i = 0; i < taskList.size(); ++i)\n    {\n        const auto &task = taskList[i];\n        timeIntervals.push_back({task[1] + 1, task[2]});\n    }\n    sort(timeIntervals.begin(), timeIntervals.end());\n\n    vector<int> dynamicProgramming(2001, 0);\n    for (int i = 0; i < timeIntervals.size(); ++i)\n    {\n        const auto &interval = timeIntervals[i];\n        for (int time = 2000; time >= interval[0]; --time)\n        {\n            dynamicProgramming[time] = max(dynamicProgramming[time], dynamicProgramming[time - interval[1]] + interval[1]);\n        }\n    }\n    return dynamicProgramming.back();\n}",
    "output": "#include <algorithm>\n#include <vector>\n\nint MinTimeOn(std::vector<std::vector<int>> &taskList)\n{\n    std::vector<std::vector<int>> time_intervals;\n    for(const auto &task : taskList)\n    {\n        time_intervals.push_back({task[1] + 1, task[2]});\n    }\n    std::sort(time_intervals.begin(), time_intervals.end());\n\n    std::vector<int> dynamic_programming(2001, 0);\n    for(const auto &interval : time_intervals)\n    {\n        for(int time= 2000; time >= interval[0]; --time)\n        {\n            dynamic_programming[time]= std::max(dynamic_programming[time], dynamic_programming[time - interval[1]] + interval[1]);\n        }\n    }\n    return dynamic_programming.back();\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass TodoList\n{\n  public:\n    struct Task\n    {\n        int id;\n        string description;\n        int dueDate;\n        vector<string> tags;\n        bool isCompleted;\n\n        Task(int taskId, const string &taskDesc, int taskDueDate, const vector<string> &taskTags)\n            : id(taskId), description(taskDesc), dueDate(taskDueDate), tags(taskTags), isCompleted(false) {}\n    };\n\n    TodoList() : taskId(1) {}\n\n    int addTask(int userId, string taskDescription, int dueDate, vector<string> tags)\n    {\n        tasks[userId].emplace_back(taskId, taskDescription, dueDate, tags);\n        return taskId++;\n    }\n\n    vector<string> getAllTasks(int userId)\n    {\n        vector<string> result;\n        vector<Task> &userTasks = tasks[userId];\n\n        sort(userTasks.begin(), userTasks.end(), [](const Task &a, const Task &b)\n             { return a.dueDate < b.dueDate; });\n\n        for (size_t i = 0; i < userTasks.size(); ++i)\n        {\n            const auto &task = userTasks[i];\n            if (!task.isCompleted)\n            {\n                result.push_back(task.description);\n            }\n        }\n\n        return result;\n    }\n\n    vector<string> getTasksForTag(int userId, string tag)\n    {\n        vector<string> result;\n        vector<Task> &userTasks = tasks[userId];\n\n        sort(userTasks.begin(), userTasks.end(), [](const Task &a, const Task &b)\n             { return a.dueDate < b.dueDate; });\n\n        for (size_t i = 0; i < userTasks.size(); ++i)\n        {\n            const auto &task = userTasks[i];\n            if (!task.isCompleted && find(task.tags.begin(), task.tags.end(), tag) != task.tags.end())\n            {\n                result.push_back(task.description);\n            }\n        }\n\n        return result;\n    }\n\n    void completeTask(int userId, int taskId)\n    {\n        vector<Task> &userTasks = tasks[userId];\n        for (size_t i = 0; i < userTasks.size(); ++i)\n        {\n            auto &task = userTasks[i];\n            if (task.id == taskId)\n            {\n                task.isCompleted = true;\n                break;\n            }\n        }\n    }\n\n  private:\n    int taskId;\n    map<int, vector<Task>> tasks;\n};",
    "output": "#include <algorithm>\n#include <map>\n#include <string>\n#include <vector>\n\nclass TodoList\n{\n  public:\n    struct Task\n    {\n        int id;\n        std::string description;\n        int dueDate;\n        std::vector<std::string> tags;\n        bool isCompleted;\n\n        Task(int taskId, const std::string &taskDesc, int taskDueDate, const std::vector<std::string> &taskTags)\n            : id(taskId), description(taskDesc), dueDate(taskDueDate), tags(taskTags), isCompleted(false) {}\n    };\n\n    TodoList() : task_id(1) {}\n\n    int AddTask(int userId, std::string taskDescription, int dueDate, std::vector<std::string> tags)\n    {\n        tasks[userId].emplace_back(task_id, taskDescription, dueDate, tags);\n        return task_id++;\n    }\n\n    std::vector<std::string> GetAllTasks(int userId)\n    {\n\n        std::vector<std::string> result;\n        std::vector<Task> &user_tasks= tasks[userId];\n\n        std::sort(user_tasks.begin(), user_tasks.end(), [](const Task &a, const Task &b)\n                  { return a.dueDate < b.dueDate; });\n\n        for(const auto &task : user_tasks)\n        {\n            if(!task.isCompleted)\n            {\n                result.push_back(task.description);\n            }\n        }\n\n        return result;\n    }\n\n    std::vector<std::string> GetTasksForTag(int userId, std::string tag)\n    {\n        std::vector<std::string> result;\n        std::vector<Task> &user_tasks= tasks[userId];\n\n        std::sort(user_tasks.begin(), user_tasks.end(), [](const Task &a, const Task &b)\n                  { return a.dueDate < b.dueDate; });\n\n        for(const auto &task : user_tasks)\n        {\n            if(!task.isCompleted && std::find(task.tags.begin(), task.tags.end(), tag) != task.tags.end())\n            {\n                result.push_back(task.description);\n            }\n        }\n\n        return result;\n    }\n\n    void CompleteTask(int userId, int taskId)\n    {\n        std::vector<Task> &user_tasks= tasks[userId];\n        for(auto &task : user_tasks)\n        {\n            if(task.id == taskId)\n            {\n                task.isCompleted= true;\n                break;\n            }\n        }\n    }\n\n  private:\n    int task_id;\n    std::map<int, std::vector<Task>> tasks;\n};"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "int maximumChildrenWithEightDollars(int totalMoney, int totalChildren)\n{\n    if(totalMoney < totalChildren * 1 || totalMoney > totalChildren * 8)\n        return -1;\n    int maxEights= (totalMoney - totalChildren) / 7;\n    return maxEights >= totalChildren ? totalChildren : maxEights;\n}",
    "output": "int MaximumChildrenWithEightDollars(int totalMoney, int totalChildren)\n{\n    if(totalMoney < totalChildren * 1 || totalMoney > totalChildren * 8)\n        return -1;\n    int max_eights= (totalMoney - totalChildren) / 7;\n    return max_eights >= totalChildren ? totalChildren : max_eights;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMaxGreatness(vector<int> &numberList)\n{\n    sort(numberList.begin(), numberList.end());\n    int totalGreatness= 0;\n    for(int index= 1; index < numberList.size(); ++index)\n    {\n        if(numberList[index - 1] < numberList[index])\n        {\n            swap(numberList[index - 1], numberList[index]);\n            ++totalGreatness;\n        }\n    }\n    return totalGreatness;\n}",
    "output": "#include <vector>\n#include <algorithm>\n\nint CalculateMaxGreatness(std::vector<int> &numberList)\n{\n    std::sort(numberList.begin(), numberList.end());\n    int total_greatness= 0;\n    for(int index= 1; index < numberList.size(); ++index)\n    {\n        if(numberList[index - 1] < numberList[index])\n        {\n            std::swap(numberList[index - 1], numberList[index]);\n            ++total_greatness;\n        }\n    }\n    return total_greatness;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateScore(vector<int> &scoreList)\n{\n    int scoreCount= scoreList.size();\n    vector<int> dp(scoreCount + 2, 0);\n\n    for(int index= 0; index < scoreCount; ++index)\n    {\n        dp[index + 2]= max(dp[index + 1], dp[index] + scoreList[index]);\n    }\n\n    return dp[scoreCount + 1];\n}",
    "output": "#include <vector>\n\nint CalculateScore(std::vector<int> &scoreList)\n{\n    int score_count= scoreList.size();\n    std::vector<int> dp(score_count + 2, 0);\n\n    for(int index= 0; index < score_count; ++index)\n    {\n        dp[index + 2]= std::max(dp[index + 1], dp[index] + scoreList[index]);\n    }\n\n    return dp[score_count + 1];\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minTimeToRepair(vector<int> &repairRanks, int totalCars)\n{\n    sort(repairRanks.begin(), repairRanks.end());\n    int lowerBound = 0, upperBound = 100 * totalCars * totalCars;\n    while (lowerBound < upperBound)\n    {\n        int midPoint = lowerBound + (upperBound - lowerBound) / 2;\n        int totalCarsRepaired = 0;\n        for (int i = 0; i < repairRanks.size(); ++i)\n        {\n            int rank = repairRanks[i];\n            int carsRepaired = min(totalCars, midPoint / (rank * rank));\n            totalCarsRepaired += carsRepaired;\n            if (totalCarsRepaired >= totalCars)\n                break;\n        }\n        if (totalCarsRepaired >= totalCars)\n            upperBound = midPoint;\n        else\n            lowerBound = midPoint + 1;\n    }\n    return lowerBound;\n}",
    "output": "#include <algorithm>\n#include <vector>\n\nint MinTimeToRepair(std::vector<int> &repairRanks, int totalCars)\n{\n    std::sort(repairRanks.begin(), repairRanks.end());\n    int lower_bound= 0, upper_bound= 100 * totalCars * totalCars;\n    while(lower_bound < upper_bound)\n    {\n        int mid_point= lower_bound + (upper_bound - lower_bound) / 2;\n        int total_cars_repaired= 0;\n        for(int rank : repairRanks)\n        {\n            int cars_repaired= std::min(totalCars, mid_point / (rank * rank));\n            total_cars_repaired+= cars_repaired;\n            if(total_cars_repaired >= totalCars)\n                break;\n        }\n        if(total_cars_repaired >= totalCars)\n            upper_bound= mid_point;\n        else\n            lower_bound= mid_point + 1;\n    }\n    return lower_bound;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countEvenOddIndices(int inputNumber)\n{\n    vector<int> count(2, 0);\n    int currentIndex= 0;\n    while(inputNumber > 0)\n    {\n        if(inputNumber % 2)\n            count[currentIndex % 2]+= 1;\n        inputNumber/= 2;\n        currentIndex+= 1;\n    }\n    return count;\n}",
    "output": "#include <vector>\n\nstd::vector<int> CountEvenOddIndices(int inputNumber)\n{\n    std::vector<int> count(2, 0);\n    int current_index= 0;\n    while(inputNumber > 0)\n    {\n        if(inputNumber % 2)\n            count[current_index % 2]+= 1;\n        inputNumber/= 2;\n        current_index+= 1;\n    }\n    return count;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isValidMove(int currentRow, int currentCol, int nextValue, int gridSize)\n{\n    return (currentRow + 1 < gridSize && currentCol + 2 < gridSize && nextValue == gridSize * (currentRow + 1) + (currentCol + 2)) ||\n           (currentRow + 1 < gridSize && currentCol - 2 >= 0 && nextValue == gridSize * (currentRow + 1) + (currentCol - 2)) ||\n           (currentRow + 2 < gridSize && currentCol + 1 < gridSize && nextValue == gridSize * (currentRow + 2) + (currentCol + 1)) ||\n           (currentRow + 2 < gridSize && currentCol - 1 >= 0 && nextValue == gridSize * (currentRow + 2) + (currentCol - 1));\n}\n\nbool validPath(vector<vector<int>> &grid)\n{\n    int gridSize= grid.size();\n    for(int rowIndex= 0; rowIndex < gridSize; rowIndex++)\n    {\n        for(int colIndex= 0; colIndex < gridSize; colIndex++)\n        {\n            int currentValue= grid[rowIndex][colIndex];\n            if(currentValue != gridSize * gridSize - 1 && !isValidMove(rowIndex, colIndex, currentValue + 1, gridSize))\n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
    "output": "#include <vector>\n\nbool IsValidMove(int currentRow, int currentCol, int nextValue, int gridSize)\n{\n    return (currentRow + 1 < gridSize && currentCol + 2 < gridSize && nextValue == gridSize * (currentRow + 1) + (currentCol + 2)) ||\n           (currentRow + 1 < gridSize && currentCol - 2 >= 0 && nextValue == gridSize * (currentRow + 1) + (currentCol - 2)) ||\n           (currentRow + 2 < gridSize && currentCol + 1 < gridSize && nextValue == gridSize * (currentRow + 2) + (currentCol + 1)) ||\n           (currentRow + 2 < gridSize && currentCol - 1 >= 0 && nextValue == gridSize * (currentRow + 2) + (currentCol - 1));\n}\n\nbool ValidPath(std::vector<std::vector<int>> &grid)\n{\n    int grid_size= grid.size();\n    for(int row_index= 0; row_index < grid_size; row_index++)\n    {\n        for(int col_index= 0; col_index < grid_size; col_index++)\n        {\n            int current_value= grid[row_index][col_index];\n            if(current_value != grid_size * grid_size - 1 && !IsValidMove(row_index, col_index, current_value + 1, grid_size))\n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countBeautifulSubsets(vector<int> &numberList, int differenceThreshold)\n{\n    sort(numberList.begin(), numberList.end());\n    int totalCount= 0;\n    vector<int> dynamicProgramming(numberList.size(), 1);\n    for(int currentIndex= 0; currentIndex < numberList.size(); currentIndex++)\n    {\n        for(int previousIndex= 0, leftPointer= 0, rightPointer= -1; previousIndex < currentIndex; previousIndex++)\n        {\n            while(leftPointer < previousIndex && numberList[previousIndex] - numberList[leftPointer] >= differenceThreshold)\n                leftPointer++;\n            while(rightPointer + 1 < previousIndex && numberList[rightPointer + 1] - numberList[previousIndex] < differenceThreshold)\n                rightPointer++;\n            if(leftPointer <= rightPointer)\n                dynamicProgramming[previousIndex]-= dynamicProgramming[leftPointer - 1];\n            dynamicProgramming[previousIndex]+= dynamicProgramming[previousIndex - 1] + 1;\n            totalCount+= dynamicProgramming[previousIndex];\n        }\n    }\n    return totalCount;\n}",
    "output": "#include <algorithm>\n#include <vector>\n\nint CountBeautifulSubsets(std::vector<int> &numberList, int differenceThreshold)\n{\n    std::sort(numberList.begin(), numberList.end());\n    int total_count= 0;\n    std::vector<int> dynamic_programming(numberList.size(), 1);\n    for(int current_index= 0; current_index < numberList.size(); current_index++)\n    {\n        for(int previous_index= 0, left_pointer= 0, right_pointer= -1; previous_index < current_index; previous_index++)\n        {\n            while(left_pointer < previous_index && numberList[previous_index] - numberList[left_pointer] >= differenceThreshold)\n                left_pointer++;\n            while(right_pointer + 1 < previous_index && numberList[right_pointer + 1] - numberList[previous_index] < differenceThreshold)\n                right_pointer++;\n            if(left_pointer <= right_pointer)\n                dynamic_programming[previous_index]-= dynamic_programming[left_pointer - 1];\n            dynamic_programming[previous_index]+= dynamic_programming[previous_index - 1] + 1;\n            total_count+= dynamic_programming[previous_index];\n        }\n    }\n    return total_count;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMaximumMex(vector<int> &numbers, int incrementValue)\n{\n    unordered_set<int> numberSet(numbers.begin(), numbers.end());\n\n    for(int i= 0; i <= 100000; i++)\n    {\n        if(!numberSet.count(i))\n            numberSet.insert(i + incrementValue);\n    }\n\n    int minimumExcludedValue= 0;\n    while(numberSet.count(minimumExcludedValue))\n        minimumExcludedValue++;\n\n    return minimumExcludedValue;\n}",
    "output": "int CalculateMaximumMex(std::vector<int> &numbers, int incrementValue)\n{\n    std::unordered_set<int> number_set(numbers.begin(), numbers.end());\n\n    for(int i= 0; i <= 100000; i++)\n    {\n        if(!number_set.count(i))\n            number_set.insert(i + incrementValue);\n    }\n\n    int minimum_excluded_value= 0;\n    while(number_set.count(minimum_excluded_value))\n        minimum_excluded_value++;\n\n    return minimum_excluded_value;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &nums)\n{\n    int minimumPrefixSum = 0;\n    int currentPrefixSum = 0;\n    for (int i = 0; i < nums.size(); ++i)\n    {\n        int currentNumber = nums[i];\n        currentPrefixSum += currentNumber;\n        minimumPrefixSum = min(minimumPrefixSum, currentPrefixSum);\n    }\n    return minimumPrefixSum < 0 ? -minimumPrefixSum : 0;\n}",
    "output": "#include <vector>\n#include <algorithm>\n\nint MinOperations(std::vector<int> &nums)\n{\n    int minimum_prefix_sum= 0;\n    int current_prefix_sum= 0;\n    for(int current_number : nums)\n    {\n        current_prefix_sum+= current_number;\n        minimum_prefix_sum= std::min(minimum_prefix_sum, current_prefix_sum);\n    }\n    return minimum_prefix_sum < 0 ? -minimum_prefix_sum : 0;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "int maxSum(int numberOfOnes, int numberOfZeros, int numberOfNegativeOnes, int limit)\n{\n    int maximumSum= 0;\n    for(int i= 0; i <= limit; ++i)\n    {\n        int onesCount= min(i, numberOfOnes);\n        int negativeOnesCount= min(limit - i, numberOfNegativeOnes);\n        maximumSum= max(maximumSum, onesCount - negativeOnesCount);\n    }\n    return maximumSum;\n}",
    "output": "int MaxSum(int numberOfOnes, int numberOfZeros, int numberOfNegativeOnes, int limit)\n{\n    int maximum_sum= 0;\n    for(int i= 0; i <= limit; ++i)\n    {\n        int ones_count= min(i, numberOfOnes);\n        int negative_ones_count= min(limit - i, numberOfNegativeOnes);\n        maximum_sum= max(maximum_sum, ones_count - negative_ones_count);\n    }\n    return maximum_sum;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool strictlyIncreasingArray(vector<int> &numberArray)\n{\n    for(int currentIndex= 0; currentIndex < numberArray.size() - 1; ++currentIndex)\n    {\n        numberArray[currentIndex]-= currentIndex;\n        if(numberArray[currentIndex] >= numberArray[currentIndex + 1])\n        {\n            return false;\n        }\n    }\n    return true;\n}",
    "output": "#include <vector>\n\nbool StrictlyIncreasingArray(std::vector<int> &numberArray)\n{\n    for(int current_index= 0; current_index < numberArray.size() - 1; ++current_index)\n    {\n        numberArray[current_index]-= current_index;\n        if(numberArray[current_index] >= numberArray[current_index + 1])\n        {\n            return false;\n        }\n    }\n    return true;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> minOperations(vector<int> &numbers, vector<int> &queries)\n{\n    vector<int> operationsCount;\n    for (int i = 0; i < queries.size(); ++i)\n    {\n        int query = queries[i];\n        int totalOperations = 0;\n        for (int j = 0; j < numbers.size(); ++j)\n        {\n            int number = numbers[j];\n            totalOperations += abs(number - query);\n        }\n        operationsCount.push_back(totalOperations);\n    }\n    return operationsCount;\n}",
    "output": "#include <vector>\n#include <cstdlib> // for abs function\n\nstd::vector<int> MinOperations(std::vector<int> &numbers, std::vector<int> &queries)\n{\n    std::vector<int> operations_count;\n    for(int query : queries)\n    {\n        int total_operations = 0;\n        for(int number : numbers)\n        {\n            total_operations += std::abs(number - query);\n        }\n        operations_count.push_back(total_operations);\n    }\n    return operations_count;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\npair<int, int> depthFirstSearch(const vector<vector<int>> &adjacencyList, const vector<int> &coinValues, int currentNode, int parentNode)\n{\n    int totalCoins = coinValues[currentNode], totalDistance = 0;\n    for (int i = 0; i < adjacencyList[currentNode].size(); ++i)\n    {\n        int neighborNode = adjacencyList[currentNode][i];\n        if (neighborNode != parentNode)\n        {\n            auto result = depthFirstSearch(adjacencyList, coinValues, neighborNode, currentNode);\n            totalCoins += result.first;\n            totalDistance += 2 * result.first + result.second;\n        }\n    }\n    return {totalCoins, totalDistance};\n}\n\nint minEdgesToCollectCoins(const vector<int> &coinValues, const vector<vector<int>> &edges)\n{\n    int numberOfNodes = coinValues.size();\n    vector<vector<int>> adjacencyList(numberOfNodes);\n    for (const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n    return depthFirstSearch(adjacencyList, coinValues, 0, -1).second / 2;\n}",
    "output": "#include <utility>\n#include <vector>\n\nstd::pair<int, int> DepthFirstSearch(const std::vector<std::vector<int>> &adjacencyList, const std::vector<int> &coinValues, int currentNode, int parentNode)\n{\n    int total_coins= coinValues[currentNode], total_distance= 0;\n    for(int neighbor_node : adjacencyList[currentNode])\n    {\n        if(neighbor_node != parentNode)\n        {\n            auto result= DepthFirstSearch(adjacencyList, coinValues, neighbor_node, currentNode);\n            total_coins+= result.first;\n            total_distance+= 2 * result.first + result.second;\n        }\n    }\n    return {total_coins, total_distance};\n}\n\nint MinEdgesToCollectCoins(const std::vector<int> &coinValues, const std::vector<std::vector<int>> &edges)\n{\n    int number_of_nodes= coinValues.size();\n    std::vector<std::vector<int>> adjacencyList(number_of_nodes);\n    for(const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n    return DepthFirstSearch(adjacencyList, coinValues, 0, -1).second / 2;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minTimeToEatGrains(vector<int> &hens, vector<int> &grains)\n{\n    sort(hens.begin(), hens.end());\n    sort(grains.begin(), grains.end());\n    int minTime = 0, maxTime = 1e9;\n\n    while (minTime < maxTime)\n    {\n        int midTime = minTime + (maxTime - minTime) / 2;\n        bool canEat = true;\n        int henIndex = 0;\n\n        for (int j = 0; j < grains.size(); ++j)\n        {\n            int grain = grains[j];\n\n            if (henIndex >= hens.size())\n            {\n                canEat = false;\n                break;\n            }\n\n            while (henIndex < hens.size() && hens[henIndex] < grain - midTime)\n            {\n                ++henIndex;\n            }\n\n            if (henIndex >= hens.size() || hens[henIndex] > grain + midTime)\n            {\n                canEat = false;\n                break;\n            }\n\n            ++henIndex;\n        }\n\n        if (canEat)\n        {\n            maxTime = midTime;\n        }\n        else\n        {\n            minTime = midTime + 1;\n        }\n    }\n\n    return minTime;\n}",
    "output": "#include <algorithm>\n#include <vector>\n\nint MinTimeToEatGrains(std::vector<int> &hens, std::vector<int> &grains)\n{\n    std::sort(hens.begin(), hens.end());\n    std::sort(grains.begin(), grains.end());\n    int min_time= 0, max_time= 1e9;\n\n    while(min_time < max_time)\n    {\n        int mid_time= min_time + (max_time - min_time) / 2;\n        bool can_eat= true;\n        int hen_index= 0;\n\n        for(int grain : grains)\n        {\n            if(hen_index >= hens.size())\n            {\n                can_eat= false;\n                break;\n            }\n\n            while(hen_index < hens.size() && hens[hen_index] < grain - mid_time)\n            {\n                ++hen_index;\n            }\n\n            if(hen_index >= hens.size() || hens[hen_index] > grain + mid_time)\n            {\n                can_eat= false;\n                break;\n            }\n\n            ++hen_index;\n        }\n\n        if(can_eat)\n        {\n            max_time= mid_time;\n        }\n        else\n        {\n            min_time= mid_time + 1;\n        }\n    }\n\n    return min_time;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findSmallestNumberWithAtLeastOneDigitFromEachArray(vector<int> &firstArray, vector<int> &secondArray)\n{\n    int minFirstArray = *min_element(firstArray.begin(), firstArray.end());\n    int minSecondArray = *min_element(secondArray.begin(), secondArray.end());\n    for (int i = 0; i < firstArray.size(); ++i)\n    {\n        int numberFromFirstArray = firstArray[i];\n        for (int j = 0; j < secondArray.size(); ++j)\n        {\n            int numberFromSecondArray = secondArray[j];\n            if (numberFromFirstArray == numberFromSecondArray)\n            {\n                return numberFromFirstArray;\n            }\n        }\n    }\n    return minFirstArray * 10 + minSecondArray;\n}",
    "output": "#include <vector>\n#include <algorithm>\n\nint FindSmallestNumberWithAtLeastOneDigitFromEachArray(std::vector<int> &firstArray, std::vector<int> &secondArray)\n{\n    int min_first_array = *std::min_element(firstArray.begin(), firstArray.end());\n    int min_second_array = *std::min_element(secondArray.begin(), secondArray.end());\n    for(int number_from_first_array : firstArray)\n    {\n        for(int number_from_second_array : secondArray)\n        {\n            if(number_from_first_array == number_from_second_array)\n            {\n                return number_from_first_array;\n            }\n        }\n    }\n    return min_first_array * 10 + min_second_array;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxValueSubstring(string inputString, string charList, vector<int> values)\n{\n    unordered_map<char, int> charValues;\n\n    for(int index = 0; index < charList.length(); index++)\n    {\n        charValues[charList[index]] = values[index];\n    }\n\n    int maxCost = 0;\n    int currentCost = 0;\n\n    for (int i = 0; i < inputString.length(); ++i)\n    {\n        char currentChar = inputString[i];\n        int charValue = charValues.count(currentChar) ? charValues[currentChar] : static_cast<int>(currentChar - 'a' + 1);\n\n        currentCost = max(0, currentCost + charValue);\n        maxCost = max(maxCost, currentCost);\n    }\n\n    return maxCost;\n}",
    "output": "int MaxValueSubstring(std::string inputString, std::string charList, std::vector<int> values)\n{\n    std::unordered_map<char, int> charValues;\n\n    for(int index= 0; index < charList.length(); index++)\n    {\n        charValues[charList[index]]= values[index];\n    }\n\n    int max_cost= 0;\n    int current_cost= 0;\n\n    for(char currentChar : inputString)\n    {\n        int char_value= charValues.count(currentChar) ? charValues[currentChar] : static_cast<int>(currentChar - 'a' + 1);\n\n        current_cost= std::max(0, current_cost + char_value);\n        max_cost= std::max(max_cost, current_cost);\n    }\n\n    return max_cost;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &array, int subarraySize)\n{\n    int arraySize= array.size(), minimumCost= INT_MAX;\n    vector<int> prefixSum(arraySize + 1);\n\n    for(int index= 1; index <= arraySize; index++)\n    {\n        prefixSum[index]= prefixSum[index - 1] + array[index - 1];\n    }\n\n    for(int startIndex= 1; startIndex <= arraySize - subarraySize + 1; startIndex++)\n    {\n        int targetValue= (prefixSum[startIndex - 1] + prefixSum[arraySize] - prefixSum[startIndex + subarraySize - 1] + arraySize / subarraySize - 1) / (arraySize / subarraySize);\n        int currentCost= 0;\n        for(int elementIndex= startIndex; elementIndex < startIndex + subarraySize; elementIndex++)\n        {\n            currentCost+= abs(array[elementIndex - 1] - targetValue);\n        }\n        minimumCost= min(minimumCost, currentCost);\n    }\n    return minimumCost;\n}",
    "output": "#include <vector>\n#include <limits>\n#include <cmath>\n\nint MinOperations(std::vector<int> &array, int subarraySize)\n{\n    int array_size= array.size(), minimum_cost= std::numeric_limits<int>::max();\n    std::vector<int> prefix_sum(array_size + 1);\n\n    for(int index= 1; index <= array_size; index++)\n    {\n        prefix_sum[index]= prefix_sum[index - 1] + array[index - 1];\n    }\n\n    for(int start_index= 1; start_index <= array_size - subarraySize + 1; start_index++)\n    {\n        int target_value= (prefix_sum[start_index - 1] + prefix_sum[array_size] - prefix_sum[start_index + subarraySize - 1] + array_size / subarraySize - 1) / (array_size / subarraySize);\n        int current_cost= 0;\n        for(int element_index= start_index; element_index < start_index + subarraySize; element_index++)\n        {\n            current_cost+= std::abs(array[element_index - 1] - target_value);\n        }\n        minimum_cost= std::min(minimum_cost, current_cost);\n    }\n    return minimum_cost;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestCycleLength(int nodeCount, vector<vector<int>> &edges)\n{\n    vector<vector<int>> adjacencyList(nodeCount);\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        const vector<int> &edge = edges[i];\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    int minimumCycleLength = nodeCount + 1;\n    for (int startNode = 0; startNode < nodeCount; ++startNode)\n    {\n        vector<int> distance(nodeCount, nodeCount + 1);\n        distance[startNode] = 0;\n        queue<int> nodeQueue;\n        nodeQueue.push(startNode);\n\n        while (!nodeQueue.empty())\n        {\n            int currentNode = nodeQueue.front();\n            nodeQueue.pop();\n            for (int j = 0; j < adjacencyList[currentNode].size(); ++j)\n            {\n                int neighbor = adjacencyList[currentNode][j];\n                if (distance[neighbor] == nodeCount + 1)\n                {\n                    distance[neighbor] = distance[currentNode] + 1;\n                    nodeQueue.push(neighbor);\n                }\n                else if (distance[neighbor] >= distance[currentNode] - 1)\n                {\n                    minimumCycleLength = min(minimumCycleLength, distance[currentNode] + distance[neighbor] + 1);\n                }\n            }\n        }\n    }\n\n    return minimumCycleLength == nodeCount + 1 ? -1 : minimumCycleLength;\n}",
    "output": "#include <queue>\n#include <vector>\n\nstd::vector<std::vector<int>> ShortestCycleLength(int nodeCount, std::vector<std::vector<int>> &edges)\n{\n    std::vector<std::vector<int>> adjacency_list(nodeCount);\n    for(const std::vector<int> &edge : edges)\n    {\n        adjacency_list[edge[0]].push_back(edge[1]);\n        adjacency_list[edge[1]].push_back(edge[0]);\n    }\n\n    int minimum_cycle_length= nodeCount + 1;\n    for(int start_node= 0; start_node < nodeCount; ++start_node)\n    {\n        std::vector<int> distance(nodeCount, nodeCount + 1);\n        distance[start_node]= 0;\n        std::queue<int> node_queue;\n        node_queue.push(start_node);\n\n        while(!node_queue.empty())\n        {\n            int current_node= node_queue.front();\n            node_queue.pop();\n            for(int neighbor : adjacency_list[current_node])\n            {\n                if(distance[neighbor] == nodeCount + 1)\n                {\n                    distance[neighbor]= distance[current_node] + 1;\n                    node_queue.push(neighbor);\n                }\n                else if(distance[neighbor] >= distance[current_node] - 1)\n                {\n                    minimum_cycle_length= std::min(minimum_cycle_length, distance[current_node] + distance[neighbor] + 1);\n                }\n            }\n        }\n    }\n\n    return minimum_cycle_length == nodeCount + 1 ? -1 : minimum_cycle_length;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint longestBalancedSubstring(string binaryString)\n{\n    int maxLength= 0;\n    int zeroCount= 0;\n    int oneCount= 0;\n\n    for(int index= 0; index < binaryString.size(); ++index)\n    {\n        if(binaryString[index] == '0')\n        {\n            zeroCount++;\n        }\n        else\n        {\n            oneCount++;\n        }\n        if(zeroCount == oneCount)\n        {\n            maxLength= max(maxLength, zeroCount * 2);\n        }\n        else if(zeroCount > oneCount)\n        {\n            zeroCount= oneCount= 0;\n        }\n    }\n\n    zeroCount= oneCount= 0;\n    for(int index= binaryString.size() - 1; index >= 0; --index)\n    {\n        if(binaryString[index] == '0')\n        {\n            zeroCount++;\n        }\n        else\n        {\n            oneCount++;\n        }\n        if(zeroCount == oneCount)\n        {\n            maxLength= max(maxLength, zeroCount * 2);\n        }\n        else if(zeroCount < oneCount)\n        {\n            zeroCount= oneCount= 0;\n        }\n    }\n\n    return maxLength;\n}",
    "output": "#include <string>\n#include <algorithm>\n\nint LongestBalancedSubstring(std::string binaryString)\n{\n    int max_length= 0;\n    int zero_count= 0;\n    int one_count= 0;\n\n    for(int index= 0; index < binaryString.size(); ++index)\n    {\n        if(binaryString[index] == '0')\n        {\n            zero_count++;\n        }\n        else\n        {\n            one_count++;\n        }\n        if(zero_count == one_count)\n        {\n            max_length= std::max(max_length, zero_count * 2);\n        }\n        else if(zero_count > one_count)\n        {\n            zero_count= one_count= 0;\n        }\n    }\n\n    zero_count= one_count= 0;\n    for(int index= binaryString.size() - 1; index >= 0; --index)\n    {\n        if(binaryString[index] == '0')\n        {\n            zero_count++;\n        }\n        else\n        {\n            one_count++;\n        }\n        if(zero_count == one_count)\n        {\n            max_length= std::max(max_length, zero_count * 2);\n        }\n        else if(zero_count < one_count)\n        {\n            zero_count= one_count= 0;\n        }\n    }\n\n    return max_length;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> distinctRowsFrom(vector<int> &inputNumbers)\n{\n    vector<unordered_set<int>> uniqueRows;\n\n    for (int i = 0; i < inputNumbers.size(); ++i)\n    {\n        int currentNumber = inputNumbers[i];\n        bool isInserted = false;\n        for (int j = 0; j < uniqueRows.size(); ++j)\n        {\n            auto &row = uniqueRows[j];\n            if (row.find(currentNumber) == row.end())\n            {\n                row.insert(currentNumber);\n                isInserted = true;\n                break;\n            }\n        }\n\n        if (!isInserted)\n            uniqueRows.push_back({currentNumber});\n    }\n\n    vector<vector<int>> result;\n    for (int k = 0; k < uniqueRows.size(); ++k)\n    {\n        auto &row = uniqueRows[k];\n        result.emplace_back(row.begin(), row.end());\n    }\n\n    return result;\n}",
    "output": "#include <unordered_set>\n#include <vector>\n\nstd::vector<std::vector<int>> DistinctRowsFrom(std::vector<int> &inputNumbers)\n{\n    std::vector<std::unordered_set<int>> unique_rows;\n\n    for(int current_number : inputNumbers)\n    {\n        bool is_inserted= false;\n        for(auto &row : unique_rows)\n        {\n            if(row.find(current_number) == row.end())\n            {\n                row.insert(current_number);\n                is_inserted= true;\n                break;\n            }\n        }\n\n        if(!is_inserted)\n            unique_rows.push_back({current_number});\n    }\n\n    std::vector<std::vector<int>> result;\n    for(auto &row : unique_rows)\n    {\n        result.emplace_back(row.begin(), row.end());\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxPoints(const vector<int> &firstMouseRewards, const vector<int> &secondMouseRewards, int k)\n{\n    vector<pair<int, int>> rewardGap(firstMouseRewards.size());\n    for(size_t index= 0; index < firstMouseRewards.size(); ++index)\n    {\n        rewardGap[index]= {secondMouseRewards[index] - firstMouseRewards[index], index};\n    }\n    sort(rewardGap.rbegin(), rewardGap.rend());\n    int totalFirstMousePoints= 0;\n    int totalSecondMousePoints= 0;\n    for(int i= 0; i < k; ++i)\n    {\n        totalFirstMousePoints+= firstMouseRewards[rewardGap[i].second];\n    }\n    for(int i= k; i < firstMouseRewards.size(); ++i)\n    {\n        totalSecondMousePoints+= secondMouseRewards[rewardGap[i].second];\n    }\n    return totalFirstMousePoints + totalSecondMousePoints;\n}",
    "output": "#include <algorithm>\n#include <vector>\n\nint MaxPoints(const std::vector<int> &firstMouseRewards, const std::vector<int> &secondMouseRewards, int k)\n{\n    std::vector<std::pair<int, int>> reward_gap(firstMouseRewards.size());\n    for(size_t index= 0; index < firstMouseRewards.size(); ++index)\n    {\n        reward_gap[index]= {secondMouseRewards[index] - firstMouseRewards[index], index};\n    }\n    std::sort(reward_gap.rbegin(), reward_gap.rend());\n    int total_first_mouse_points= 0;\n    int total_second_mouse_points= 0;\n    for(int i= 0; i < k; ++i)\n    {\n        total_first_mouse_points+= firstMouseRewards[reward_gap[i].second];\n    }\n    for(int i= k; i < firstMouseRewards.size(); ++i)\n    {\n        total_second_mouse_points+= secondMouseRewards[reward_gap[i].second];\n    }\n    return total_first_mouse_points + total_second_mouse_points;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) not use universal header #include <bits/stdc++.h> 2) prefix all identifiers from the standard namespace with an 'std::' prefix 3) use range-based for loops wherever possible 4) use 'nullptr' for empty pointer 5) use UpperCamelCase for function names 6) use snake_case for local variable names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> reachPosition(int totalPositions, int targetPosition, vector<int> &bannedPositions, int stepSize)\n{\n    set<int> bannedSet(bannedPositions.begin(), bannedPositions.end());\n    vector<int> result(totalPositions, 0);\n\n    for(int currentPosition= 0; currentPosition < totalPositions; ++currentPosition)\n    {\n        if(bannedSet.find(currentPosition) != bannedSet.end() || currentPosition == targetPosition)\n        {\n            result[currentPosition]= -1;\n            continue;\n        }\n\n        int stepsRequired= 0;\n        int distance= abs(targetPosition - currentPosition) / stepSize;\n        if((abs(targetPosition - currentPosition) % stepSize == 0) && ((distance & 1) == (((totalPositions - 1) & 1) ^ (stepSize & 1))))\n        {\n            stepsRequired= distance;\n        }\n        else\n        {\n            stepsRequired= -1;\n        }\n\n        result[currentPosition]= stepsRequired;\n    }\n\n    result[targetPosition]= 0;\n    return result;\n}",
    "output": "#include <set>\n#include <vector>\n\nstd::vector<int> ReachPosition(int totalPositions, int targetPosition, std::vector<int> &bannedPositions, int stepSize)\n{\n    std::set<int> banned_set(bannedPositions.begin(), bannedPositions.end());\n    std::vector<int> result(totalPositions, 0);\n\n    for(int current_position= 0; current_position < totalPositions; ++current_position)\n    {\n        if(banned_set.find(current_position) != banned_set.end() || current_position == targetPosition)\n        {\n            result[current_position]= -1;\n            continue;\n        }\n\n        int steps_required= 0;\n        int distance= abs(targetPosition - current_position) / stepSize;\n        if((abs(targetPosition - current_position) % stepSize == 0) && ((distance & 1) == (((totalPositions - 1) & 1) ^ (stepSize & 1))))\n        {\n            steps_required= distance;\n        }\n        else\n        {\n            steps_required= -1;\n        }\n\n        result[current_position]= steps_required;\n    }\n\n    result[targetPosition]= 0;\n    return result;\n}"
  }
]