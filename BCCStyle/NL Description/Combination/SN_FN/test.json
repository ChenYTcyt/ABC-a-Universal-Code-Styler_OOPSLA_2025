[
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring findOddWord(vector<string> &wordList)\n{\n    auto calculateDifferenceArray = [](const string &currentWord)\n    {\n        vector<int> differenceArray;\n        for(size_t index = 1; index < currentWord.size(); index++)\n        {\n            differenceArray.push_back(currentWord[index] - currentWord[index - 1]);\n        }\n        return differenceArray;\n    };\n\n    vector<vector<int>> differenceArrays;\n    for (int i = 0; i < wordList.size(); ++i)\n    {\n        const auto &currentWord = wordList[i];\n        differenceArrays.push_back(calculateDifferenceArray(currentWord));\n    }\n\n    int oddArrayIndex = -1;\n    for (int index = 1; index < differenceArrays.size(); index++)\n    {\n        int matchCount = 0;\n        for (int j = 0; j < differenceArrays[index].size(); j++)\n        {\n            if (differenceArrays[0][j] == differenceArrays[index][j])\n            {\n                matchCount++;\n            }\n        }\n\n        if (matchCount == 0)\n        {\n            oddArrayIndex = index;\n            break;\n        }\n    }\n\n    return wordList[oddArrayIndex];\n}",
    "output": "#include <bits/stdc++.h>\nstd::string FindOddWord(std::vector<std::string> &wordList)\n{\n    auto CalculateDifferenceArray= [](const std::string &currentWord)\n    {\n        std::vector<int> differenceArray;\n        for(size_t index= 1; index < currentWord.size(); index++)\n        {\n            differenceArray.push_back(currentWord[index] - currentWord[index - 1]);\n        }\n        return differenceArray;\n    };\n\n    std::vector<std::vector<int>> differenceArrays;\n    for(size_t i = 0; i < wordList.size(); ++i)\n    {\n        differenceArrays.push_back(CalculateDifferenceArray(wordList[i]));\n    }\n\n    int oddArrayIndex= -1;\n    for(int index= 1; index < differenceArrays.size(); index++)\n    {\n        int matchCount= 0;\n        for(int j= 0; j < differenceArrays[index].size(); j++)\n        {\n            if(differenceArrays[0][j] == differenceArrays[index][j])\n            {\n                matchCount++;\n            }\n        }\n\n        if(matchCount == 0)\n        {\n            oddArrayIndex= index;\n            break;\n        }\n    }\n\n    return wordList[oddArrayIndex];\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countDifferences(const string &sourceWord, const string &targetWord)\n{\n    int differenceCount = 0;\n    for(int index = 0; index < sourceWord.size(); ++index)\n    {\n        if(sourceWord[index] != targetWord[index])\n        {\n            ++differenceCount;\n        }\n    }\n    return differenceCount;\n}\n\nvector<string> findMatchingWords(const vector<string> &queryWords, const vector<string> &dictionaryWords)\n{\n    vector<string> matchedWords;\n    for (int i = 0; i < queryWords.size(); ++i)\n    {\n        const string &query = queryWords[i];\n        for (int j = 0; j < dictionaryWords.size(); ++j)\n        {\n            const string &dictionaryWord = dictionaryWords[j];\n            if (countDifferences(query, dictionaryWord) <= 2)\n            {\n                matchedWords.push_back(query);\n                break;\n            }\n        }\n    }\n    return matchedWords;\n}",
    "output": "#include <bits/stdc++.h>\nint CountDifferences(const std::string &sourceWord, const std::string &targetWord)\n{\n    int differenceCount = 0;\n    for (int index = 0; index < sourceWord.size(); ++index)\n    {\n        if (sourceWord[index] != targetWord[index])\n        {\n            ++differenceCount;\n        }\n    }\n    return differenceCount;\n}\n\nstd::vector<std::string> FindMatchingWords(const std::vector<std::string> &queryWords, const std::vector<std::string> &dictionaryWords)\n{\n    std::vector<std::string> matchedWords;\n    for (int i = 0; i < queryWords.size(); ++i)\n    {\n        const std::string &query = queryWords[i];\n        for (int j = 0; j < dictionaryWords.size(); ++j)\n        {\n            const std::string &dictionaryWord = dictionaryWords[j];\n            if (CountDifferences(query, dictionaryWord) <= 2)\n            {\n                matchedWords.push_back(query);\n                break;\n            }\n        }\n    }\n    return matchedWords;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findMinSeededValue(vector<int> &numbers, int space)\n{\n    unordered_map<int, int> remainderCount;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int number = numbers[i];\n        remainderCount[number % space]++;\n    }\n    return max_element(remainderCount.begin(), remainderCount.end(), [](const auto &a, const auto &b)\n                       { return a.second < b.second || (a.second == b.second && a.first > b.first); })\n        ->first;\n}",
    "output": "#include <bits/stdc++.h>\nint FindMinSeededValue(std::vector<int> &numbers, int space)\n{\n    std::unordered_map<int, int> remainderCount;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int number = numbers[i];\n        remainderCount[number % space]++;\n    }\n    return std::max_element(remainderCount.begin(), remainderCount.end(), [](const auto &a, const auto &b)\n                            { return a.second < b.second || (a.second == b.second && a.first > b.first); })\n        ->first;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> findSecondGreater(const vector<int> &inputNumbers)\n{\n    int totalNumbers= inputNumbers.size();\n    vector<int> result(totalNumbers, -1);\n    for(int currentIndex= 0; currentIndex < totalNumbers; currentIndex++)\n    {\n        for(int nextIndex= currentIndex + 1, secondGreaterIndex= -1; nextIndex < totalNumbers; nextIndex++)\n        {\n            if(inputNumbers[nextIndex] > inputNumbers[currentIndex])\n            {\n                if(secondGreaterIndex == -1)\n                {\n                    secondGreaterIndex= nextIndex;\n                }\n                else\n                {\n                    result[currentIndex]= inputNumbers[nextIndex];\n                    break;\n                }\n            }\n        }\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> FindSecondGreater(const std::vector<int> &inputNumbers)\n{\n    int totalNumbers = inputNumbers.size();\n    std::vector<int> result(totalNumbers, -1);\n    for(int currentIndex = 0; currentIndex < totalNumbers; currentIndex++)\n    {\n        for(int nextIndex = currentIndex + 1, secondGreaterIndex = -1; nextIndex < totalNumbers; nextIndex++)\n        {\n            if(inputNumbers[nextIndex] > inputNumbers[currentIndex])\n            {\n                if(secondGreaterIndex == -1)\n                {\n                    secondGreaterIndex = nextIndex;\n                }\n                else\n                {\n                    result[currentIndex] = inputNumbers[nextIndex];\n                    break;\n                }\n            }\n        }\n    }\n    return result;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint averageEvenDivisibleByThree(const vector<int> &numbers)\n{\n    int totalSum = 0;\n    int count = 0;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int number = numbers[i];\n        if (number % 2 == 0 && number % 3 == 0)\n        {\n            totalSum += number;\n            count++;\n        }\n    }\n    return count == 0 ? 0 : totalSum / count;\n}",
    "output": "int AverageEvenDivisibleByThree(const std::vector<int> &numbers)\n{\n    int totalSum = 0;\n    int count = 0;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int number = numbers[i];\n        if (number % 2 == 0 && number % 3 == 0)\n        {\n            totalSum += number;\n            count++;\n        }\n    }\n    return count == 0 ? 0 : totalSum / count;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<string>> getHighestPopularity(vector<string> &creatorNames, vector<string> &videoIds, vector<int> &viewCounts)\n{\n    unordered_map<string, int> creatorPopularity;\n    unordered_map<string, pair<string, int>> mostViewedVideos;\n    for(int index = 0; index < creatorNames.size(); index++)\n    {\n        creatorPopularity[creatorNames[index]] += viewCounts[index];\n        if(!mostViewedVideos.count(creatorNames[index]) || viewCounts[index] > mostViewedVideos[creatorNames[index]].second || (viewCounts[index] == mostViewedVideos[creatorNames[index]].second && videoIds[index] < mostViewedVideos[creatorNames[index]].first))\n        {\n            mostViewedVideos[creatorNames[index]] = {videoIds[index], viewCounts[index]};\n        }\n    }\n\n    int maxPopularity = 0;\n    for(auto it = creatorPopularity.begin(); it != creatorPopularity.end(); ++it)\n    {\n        maxPopularity = max(maxPopularity, it->second);\n    }\n\n    vector<vector<string>> result;\n    for(auto it = creatorPopularity.begin(); it != creatorPopularity.end(); ++it)\n    {\n        if(it->second == maxPopularity)\n        {\n            result.push_back({it->first, mostViewedVideos[it->first].first});\n        }\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<std::string>> GetHighestPopularity(std::vector<std::string> &creatorNames, std::vector<std::string> &videoIds, std::vector<int> &viewCounts)\n{\n    std::unordered_map<std::string, int> creatorPopularity;\n    std::unordered_map<std::string, std::pair<std::string, int>> mostViewedVideos;\n    for(int index = 0; index < creatorNames.size(); index++)\n    {\n        creatorPopularity[creatorNames[index]] += viewCounts[index];\n        if(!mostViewedVideos.count(creatorNames[index]) || viewCounts[index] > mostViewedVideos[creatorNames[index]].second || (viewCounts[index] == mostViewedVideos[creatorNames[index]].second && videoIds[index] < mostViewedVideos[creatorNames[index]].first))\n        {\n            mostViewedVideos[creatorNames[index]] = {videoIds[index], viewCounts[index]};\n        }\n    }\n\n    int maxPopularity = 0;\n    for(auto it = creatorPopularity.begin(); it != creatorPopularity.end(); ++it)\n    {\n        maxPopularity = std::max(maxPopularity, it->second);\n    }\n\n    std::vector<std::vector<std::string>> result;\n    for(auto it = creatorPopularity.begin(); it != creatorPopularity.end(); ++it)\n    {\n        if(it->second == maxPopularity)\n        {\n            result.push_back({it->first, mostViewedVideos[it->first].first});\n        }\n    }\n    return result;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "int digitSum(int number)\n{\n    int totalSum= 0;\n    while(number)\n    {\n        totalSum+= number % 10;\n        number/= 10;\n    }\n    return totalSum;\n}\n\nint minimumBeautiful(int baseNumber, int targetSum)\n{\n    int increment= 0;\n    while(digitSum(baseNumber + increment) > targetSum)\n    {\n        ++increment;\n    }\n    return increment;\n}",
    "output": "int DigitSum(int number)\n{\n    int totalSum= 0;\n    while(number)\n    {\n        totalSum+= number % 10;\n        number/= 10;\n    }\n    return totalSum;\n}\n\nint MinimumBeautiful(int baseNumber, int targetSum)\n{\n    int increment= 0;\n    while(DigitSum(baseNumber + increment) > targetSum)\n    {\n        ++increment;\n    }\n    return increment;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nclass Solution\n{\n  public:\n    vector<int> removeSubtrees(TreeNode *rootNode, vector<int> &queries)\n    {\n        vector<int> answer(queries.size());\n\n        for(int i= 0; i < queries.size(); ++i)\n        {\n            removeSubtree(rootNode, queries[i]);\n            answer[i]= findHeight(rootNode);\n        }\n\n        return answer;\n    }\n\n    void removeSubtree(TreeNode *currentNode, int value)\n    {\n        if(currentNode == NULL)\n            return;\n\n        if(currentNode->leftChild && currentNode->leftChild->value == value)\n            currentNode->leftChild= NULL;\n        else\n            removeSubtree(currentNode->leftChild, value);\n\n        if(currentNode->rightChild && currentNode->rightChild->value == value)\n            currentNode->rightChild= NULL;\n        else\n            removeSubtree(currentNode->rightChild, value);\n    }\n\n    int findHeight(TreeNode *currentNode)\n    {\n        if(currentNode == NULL)\n            return -1;\n\n        return 1 + max(findHeight(currentNode->leftChild), findHeight(currentNode->rightChild));\n    }\n};",
    "output": "#include <bits/stdc++.h>\n// Definition for a binary tree node.\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nclass Solution\n{\n  public:\n    std::vector<int> RemoveSubtrees(TreeNode *rootNode, std::vector<int> &queries)\n    {\n        std::vector<int> answer(queries.size());\n\n        for(int i= 0; i < queries.size(); ++i)\n        {\n            RemoveSubtree(rootNode, queries[i]);\n            answer[i]= FindHeight(rootNode);\n        }\n\n        return answer;\n    }\n\n    void RemoveSubtree(TreeNode *currentNode, int value)\n    {\n        if(currentNode == NULL)\n            return;\n\n        if(currentNode->leftChild && currentNode->leftChild->value == value)\n            currentNode->leftChild= NULL;\n        else\n            RemoveSubtree(currentNode->leftChild, value);\n\n        if(currentNode->rightChild && currentNode->rightChild->value == value)\n            currentNode->rightChild= NULL;\n        else\n            RemoveSubtree(currentNode->rightChild, value);\n    }\n\n    int FindHeight(TreeNode *currentNode)\n    {\n        if(currentNode == NULL)\n            return -1;\n\n        return 1 + std::max(FindHeight(currentNode->leftChild), FindHeight(currentNode->rightChild));\n    }\n};"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &numberList)\n{\n    int size= numberList.size();\n    int indexOfZero= -1;\n\n    for(int index= 0; index < size; index++)\n    {\n        if(numberList[index] == 0)\n        {\n            indexOfZero= index;\n            break;\n        }\n    }\n\n    int countIncrements= 0, countDecrements= 0;\n\n    for(int index= 1; index < size; index++)\n    {\n        if(abs(numberList[index] - numberList[index - 1]) != 1)\n        {\n            countIncrements+= abs(numberList[index] - numberList[index - 1]) - 1;\n        }\n    }\n\n    for(int index= indexOfZero + 1; index < size; index++)\n    {\n        if(numberList[index] < numberList[index - 1])\n        {\n            countDecrements++;\n        }\n    }\n\n    return min(countIncrements, countDecrements);\n}",
    "output": "#include <bits/stdc++.h>\n// for abs\n // for min\n\nint MinOperations(std::vector<int> &numberList)\n{\n    int size= numberList.size();\n    int indexOfZero= -1;\n\n    for(int index= 0; index < size; index++)\n    {\n        if(numberList[index] == 0)\n        {\n            indexOfZero= index;\n            break;\n        }\n    }\n\n    int countIncrements= 0, countDecrements= 0;\n\n    for(int index= 1; index < size; index++)\n    {\n        if(std::abs(numberList[index] - numberList[index - 1]) != 1)\n        {\n            countIncrements+= std::abs(numberList[index] - numberList[index - 1]) - 1;\n        }\n    }\n\n    for(int index= indexOfZero + 1; index < size; index++)\n    {\n        if(numberList[index] < numberList[index - 1])\n        {\n            countDecrements++;\n        }\n    }\n\n    return std::min(countIncrements, countDecrements);\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> performOps(vector<int> &numberList)\n{\n    int listSize= numberList.size();\n    for(int currentIndex= 0; currentIndex < listSize - 1; ++currentIndex)\n    {\n        if(numberList[currentIndex] == numberList[currentIndex + 1])\n        {\n            numberList[currentIndex]*= 2;\n            numberList[currentIndex + 1]= 0;\n        }\n    }\n    int nonZeroCount= 0;\n    for(int currentIndex= 0; currentIndex < listSize; ++currentIndex)\n    {\n        if(numberList[currentIndex] != 0)\n        {\n            numberList[nonZeroCount++]= numberList[currentIndex];\n        }\n    }\n    while(nonZeroCount < listSize)\n    {\n        numberList[nonZeroCount++]= 0;\n    }\n    return numberList;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> PerformOps(std::vector<int> &numberList)\n{\n    int listSize= numberList.size();\n    for(int currentIndex= 0; currentIndex < listSize - 1; ++currentIndex)\n    {\n        if(numberList[currentIndex] == numberList[currentIndex + 1])\n        {\n            numberList[currentIndex]*= 2;\n            numberList[currentIndex + 1]= 0;\n        }\n    }\n    int nonZeroCount= 0;\n    for(int currentIndex= 0; currentIndex < listSize; ++currentIndex)\n    {\n        if(numberList[currentIndex] != 0)\n        {\n            numberList[nonZeroCount++]= numberList[currentIndex];\n        }\n    }\n    while(nonZeroCount < listSize)\n    {\n        numberList[nonZeroCount++]= 0;\n    }\n    return numberList;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxSubarraySumWithDistinctElements(vector<int> &numbers, int windowSize)\n{\n    int maxSum = 0, currentWindowSum = 0;\n    unordered_map<int, int> frequencyMap;\n\n    for (int index = 0; index < numbers.size(); index++)\n    {\n        frequencyMap[numbers[index]]++;\n        currentWindowSum += numbers[index];\n        if (index >= windowSize)\n        {\n            frequencyMap[numbers[index - windowSize]]--;\n            currentWindowSum -= numbers[index - windowSize];\n        }\n        if (index >= windowSize - 1)\n        {\n            bool isDistinct = true;\n            // Modify the range-based for loop to a traditional for loop\n            for (int i = 0; i < frequencyMap.size(); ++i)\n            {\n                auto it = frequencyMap.begin();\n                advance(it, i);\n                if (it->second > 1)\n                {\n                    isDistinct = false;\n                    break;\n                }\n            }\n            if (isDistinct)\n            {\n                maxSum = max(maxSum, currentWindowSum);\n            }\n        }\n    }\n    return maxSum;\n}",
    "output": "#include <bits/stdc++.h>\nint MaxSubarraySumWithDistinctElements(std::vector<int> &numbers, int windowSize)\n{\n    int maxSum = 0, currentWindowSum = 0;\n    std::unordered_map<int, int> frequencyMap;\n\n    for (int index = 0; index < numbers.size(); index++)\n    {\n        frequencyMap[numbers[index]]++;\n        currentWindowSum += numbers[index];\n        if (index >= windowSize)\n        {\n            frequencyMap[numbers[index - windowSize]]--;\n            currentWindowSum -= numbers[index - windowSize];\n        }\n        if (index >= windowSize - 1)\n        {\n            bool isDistinct = true;\n            for (auto it = frequencyMap.begin(); it != frequencyMap.end(); ++it)\n            {\n                if (it->second > 1)\n                {\n                    isDistinct = false;\n                    break;\n                }\n            }\n            if (isDistinct)\n            {\n                maxSum = std::max(maxSum, currentWindowSum);\n            }\n        }\n    }\n    return maxSum;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint hireWorkers(vector<int> &workerCosts, int numberOfWorkers, int candidateLimit)\n{\n    int totalCosts= workerCosts.size();\n    vector<pair<int, int>> workers;\n    for(int i= 0; i < totalCosts; ++i)\n        workers.emplace_back(workerCosts[i], i);\n    sort(workers.begin(), workers.end());\n\n    int totalCost= 0;\n    for(int i= 0; i < numberOfWorkers; ++i)\n    {\n        if(min(workers[i].second, totalCosts - workers[i].second - 1) < candidateLimit)\n            totalCost+= workers[i].first;\n    }\n    return totalCost;\n}",
    "output": "#include <bits/stdc++.h>\nint HireWorkers(std::vector<int> &workerCosts, int numberOfWorkers, int candidateLimit)\n{\n    int totalCosts= workerCosts.size();\n    std::vector<std::pair<int, int>> workers;\n    for(int i= 0; i < totalCosts; ++i)\n        workers.emplace_back(workerCosts[i], i);\n    std::sort(workers.begin(), workers.end());\n\n    int totalCost= 0;\n    for(int i= 0; i < numberOfWorkers; ++i)\n    {\n        if(std::min(workers[i].second, totalCosts - workers[i].second - 1) < candidateLimit)\n            totalCost+= workers[i].first;\n    }\n    return totalCost;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\n// for abs\nusing namespace std;\n\nint calculateMinimumTotalDistance(vector<int> &robotPositions, vector<vector<int>> &factoryLocations)\n{\n    sort(robotPositions.begin(), robotPositions.end());\n    sort(factoryLocations.begin(), factoryLocations.end());\n\n    int totalDistance = 0, robotIndex = 0;\n    for (int i = 0; i < factoryLocations.size(); ++i)\n    {\n        const auto &factory = factoryLocations[i];\n        int availableCapacity = factory[1];\n        while (availableCapacity-- > 0 && robotIndex < robotPositions.size())\n        {\n            totalDistance += abs(factory[0] - robotPositions[robotIndex]);\n            robotIndex++;\n        }\n    }\n\n    return totalDistance;\n}",
    "output": "#include <bits/stdc++.h>\n// for std::abs\n\nint CalculateMinimumTotalDistance(std::vector<int> &robotPositions, std::vector<std::vector<int>> &factoryLocations)\n{\n    std::sort(robotPositions.begin(), robotPositions.end());\n    std::sort(factoryLocations.begin(), factoryLocations.end());\n\n    int totalDistance = 0, robotIndex = 0;\n    for (int i = 0; i < factoryLocations.size(); ++i)\n    {\n        const auto &factory = factoryLocations[i];\n        int availableCapacity = factory[1];\n        while (availableCapacity-- > 0 && robotIndex < robotPositions.size())\n        {\n            totalDistance += std::abs(factory[0] - robotPositions[robotIndex]);\n            robotIndex++;\n        }\n    }\n\n    return totalDistance;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minValidSubarrays(vector<int> &numberList)\n{\n    int subarrayCount= 0;\n    for(int currentIndex= 0; currentIndex < numberList.size(); currentIndex++)\n    {\n        while(currentIndex < numberList.size() && gcd(numberList[currentIndex], numberList.back()) == 1)\n        {\n            currentIndex++;\n        }\n        if(currentIndex < numberList.size())\n        {\n            subarrayCount++;\n            numberList.pop_back();\n        }\n    }\n    return subarrayCount > 0 ? subarrayCount : -1;\n}",
    "output": "#include <bits/stdc++.h>\nint MinValidSubarrays(vector<int> &numberList)\n{\n    int subarrayCount= 0;\n    for(int currentIndex= 0; currentIndex < numberList.size(); currentIndex++)\n    {\n        while(currentIndex < numberList.size() && std::gcd(numberList[currentIndex], numberList.back()) == 1)\n        {\n            currentIndex++;\n        }\n        if(currentIndex < numberList.size())\n        {\n            subarrayCount++;\n            numberList.pop_back();\n        }\n    }\n    return subarrayCount > 0 ? subarrayCount : -1;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint distinctAverages(vector<int> &numberList)\n{\n    set<double> uniqueAverages;\n    sort(numberList.begin(), numberList.end());\n    int listSize= numberList.size();\n    for(int index= 0; index < listSize / 2; index++)\n    {\n        uniqueAverages.insert((numberList[index] + numberList[listSize - 1 - index]) / 2.0);\n    }\n    return uniqueAverages.size();\n}",
    "output": "#include <bits/stdc++.h>\nint DistinctAverages(std::vector<int> &numberList)\n{\n    std::set<double> uniqueAverages;\n    std::sort(numberList.begin(), numberList.end());\n    int listSize = numberList.size();\n    for(int index = 0; index < listSize / 2; index++)\n    {\n        uniqueAverages.insert((numberList[index] + numberList[listSize - 1 - index]) / 2.0);\n    }\n    return uniqueAverages.size();\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "int modulusPower(long base, int exponent, int modulus)\n{\n    long result= 1;\n    while(exponent > 0)\n    {\n        if(exponent % 2 == 1)\n        {\n            result= (result * base) % modulus;\n        }\n        base= (base * base) % modulus;\n        exponent/= 2;\n    }\n    return (int)result;\n}\n\nint countGoodStrings(int minLength, int maxLength, int zeroCount, int oneCount)\n{\n    long modulus= 1000000007;\n    return (((modulusPower(2, maxLength, modulus) - modulusPower(2, minLength - 1, modulus) + 1) * (zeroCount + 1)) % modulus * (oneCount + 1)) % modulus;\n}",
    "output": "int ModulusPower(long base, int exponent, int modulus)\n{\n    long result= 1;\n    while(exponent > 0)\n    {\n        if(exponent % 2 == 1)\n        {\n            result= (result * base) % modulus;\n        }\n        base= (base * base) % modulus;\n        exponent/= 2;\n    }\n    return (int)result;\n}\n\nint CountGoodStrings(int minLength, int maxLength, int zeroCount, int oneCount)\n{\n    long modulus= 1000000007;\n    return (((ModulusPower(2, maxLength, modulus) - ModulusPower(2, minLength - 1, modulus) + 1) * (zeroCount + 1)) % modulus * (oneCount + 1)) % modulus;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid depthFirstSearch(int currentNode, int parentNode, int bobTime, int currentTime, int &aliceIncome, int &maximumIncome, vector<int> &amounts, unordered_map<int, vector<int>> &tree)\n{\n    if(currentTime < bobTime || amounts[currentNode] >= 0)\n    {\n        aliceIncome += amounts[currentNode];\n    }\n    else\n    {\n        aliceIncome += amounts[currentNode] / 2;\n    }\n    amounts[currentNode] = 0;\n    bool isLeafNode = true;\n    for(int j = 0; j < tree[currentNode].size(); ++j)\n    {\n        int childNode = tree[currentNode][j];\n        if(childNode != parentNode)\n        {\n            isLeafNode = false;\n            int temporaryIncome = aliceIncome;\n            depthFirstSearch(childNode, currentNode, bobTime, currentTime + 1, temporaryIncome, maximumIncome, amounts, tree);\n        }\n    }\n    if(isLeafNode)\n    {\n        maximumIncome = max(maximumIncome, aliceIncome);\n    }\n}\n\nint calculateMaxNetIncome(vector<vector<int>> &edges, int bobTime, vector<int> &amounts)\n{\n    unordered_map<int, vector<int>> tree;\n    for(const auto &edge : edges)\n    {\n        tree[edge[0]].emplace_back(edge[1]);\n        tree[edge[1]].emplace_back(edge[0]);\n    }\n    int maximumIncome = -100000;\n    int aliceIncome = 0;\n    depthFirstSearch(0, -1, bobTime, 0, aliceIncome, maximumIncome, amounts, tree);\n    return maximumIncome;\n}",
    "output": "#include <bits/stdc++.h>\nvoid DepthFirstSearch(int currentNode, int parentNode, int bobTime, int currentTime, int &aliceIncome, int &maximumIncome, std::vector<int> &amounts, std::unordered_map<int, std::vector<int>> &tree)\n{\n    if(currentTime < bobTime || amounts[currentNode] >= 0)\n    {\n        aliceIncome += amounts[currentNode];\n    }\n    else\n    {\n        aliceIncome += amounts[currentNode] / 2;\n    }\n    amounts[currentNode] = 0;\n    bool isLeafNode = true;\n\n    // Changing the range-based for loop to a traditional for loop.\n    for (size_t i = 0; i < tree[currentNode].size(); ++i)\n    {\n        int childNode = tree[currentNode][i];\n        if(childNode != parentNode)\n        {\n            isLeafNode = false;\n            int temporaryIncome = aliceIncome;\n            DepthFirstSearch(childNode, currentNode, bobTime, currentTime + 1, temporaryIncome, maximumIncome, amounts, tree);\n        }\n    }\n    if(isLeafNode)\n    {\n        maximumIncome = std::max(maximumIncome, aliceIncome);\n    }\n}\n\nint CalculateMaxNetIncome(std::vector<std::vector<int>> &edges, int bobTime, std::vector<int> &amounts)\n{\n    std::unordered_map<int, std::vector<int>> tree;\n    for(const auto &edge : edges)\n    {\n        tree[edge[0]].emplace_back(edge[1]);\n        tree[edge[1]].emplace_back(edge[0]);\n    }\n    int maximumIncome = -100000;\n    int aliceIncome = 0;\n    DepthFirstSearch(0, -1, bobTime, 0, aliceIncome, maximumIncome, amounts, tree);\n    return maximumIncome;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> splitMessage(string inputMessage, int characterLimit)\n{\n    int messageLength= inputMessage.size();\n    int extraCharacters= (characterLimit - 3) * (messageLength / (characterLimit - 3)) - messageLength;\n    int fullParts= messageLength / (characterLimit - 3);\n    if((messageLength + fullParts + extraCharacters) % (characterLimit - 2) != 0)\n        return {};\n    int numberOfParts= (messageLength + fullParts + extraCharacters) / (characterLimit - 2);\n    vector<string> messageParts;\n    for(int currentIndex= 0, partIndex= 1, characterCount= 0; currentIndex < messageLength || partIndex <= numberOfParts;)\n    {\n        string tempPart;\n        while(characterCount < characterLimit - 3)\n        {\n            characterCount++;\n            tempPart+= inputMessage[currentIndex++];\n            if(currentIndex == messageLength)\n                break;\n        }\n        characterCount= 0;\n        tempPart+= to_string(partIndex) + \"/\" + to_string(numberOfParts) + \" \";\n        partIndex++;\n        messageParts.push_back(tempPart);\n    }\n    return messageParts;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::string> SplitMessage(std::string inputMessage, int characterLimit)\n{\n    int messageLength= inputMessage.size();\n    int extraCharacters= (characterLimit - 3) * (messageLength / (characterLimit - 3)) - messageLength;\n    int fullParts= messageLength / (characterLimit - 3);\n    if((messageLength + fullParts + extraCharacters) % (characterLimit - 2) != 0)\n        return {};\n    int numberOfParts= (messageLength + fullParts + extraCharacters) / (characterLimit - 2);\n    std::vector<std::string> messageParts;\n    for(int currentIndex= 0, partIndex= 1, characterCount= 0; currentIndex < messageLength || partIndex <= numberOfParts;)\n    {\n        std::string tempPart;\n        while(characterCount < characterLimit - 3)\n        {\n            characterCount++;\n            tempPart+= inputMessage[currentIndex++];\n            if(currentIndex == messageLength)\n                break;\n        }\n        characterCount= 0;\n        tempPart+= std::to_string(partIndex) + \"/\" + std::to_string(numberOfParts) + \" \";\n        partIndex++;\n        messageParts.push_back(tempPart);\n    }\n    return messageParts;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<double> convertTemperature(double celsiusTemperature)\n{\n    double kelvinTemperature = celsiusTemperature + 273.15;\n    double fahrenheitTemperature = celsiusTemperature * 1.80 + 32.00;\n    return {kelvinTemperature, fahrenheitTemperature};\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<double> ConvertTemperature(double celsiusTemperature)\n{\n    double kelvinTemperature= celsiusTemperature + 273.15;\n    double fahrenheitTemperature= celsiusTemperature * 1.80 + 32.00;\n    return {kelvinTemperature, fahrenheitTemperature};\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint lcm(int firstNumber, int secondNumber)\n{\n    int currentMultiple= firstNumber;\n    while((currentMultiple % secondNumber) != 0)\n    {\n        currentMultiple+= firstNumber;\n    }\n    return currentMultiple;\n}\n\nint countLcmSubarrays(vector<int> &numberArray, int targetLcm)\n{\n    int subarrayCount= 0;\n    for(int startIndex= 0; startIndex < numberArray.size(); startIndex++)\n    {\n        int currentLcm= numberArray[startIndex];\n        for(int endIndex= startIndex; endIndex < numberArray.size(); endIndex++)\n        {\n            currentLcm= lcm(currentLcm, numberArray[endIndex]);\n            if(currentLcm == targetLcm)\n            {\n                subarrayCount++;\n            }\n        }\n    }\n    return subarrayCount;\n}",
    "output": "#include <bits/stdc++.h>\nint Lcm(int firstNumber, int secondNumber)\n{\n    int currentMultiple= firstNumber;\n    while((currentMultiple % secondNumber) != 0)\n    {\n        currentMultiple+= firstNumber;\n    }\n    return currentMultiple;\n}\n\nint CountLcmSubarrays(std::vector<int> &numberArray, int targetLcm)\n{\n    int subarrayCount= 0;\n    for(int startIndex= 0; startIndex < numberArray.size(); startIndex++)\n    {\n        int currentLcm= numberArray[startIndex];\n        for(int endIndex= startIndex; endIndex < numberArray.size(); endIndex++)\n        {\n            currentLcm= Lcm(currentLcm, numberArray[endIndex]);\n            if(currentLcm == targetLcm)\n            {\n                subarrayCount++;\n            }\n        }\n    }\n    return subarrayCount;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nint calculateMinSwaps(TreeNode *rootNode)\n{\n    int swapCount= 0;\n    queue<pair<TreeNode *, int>> nodeQueue;\n    nodeQueue.push({rootNode, 0});\n\n    vector<int> levelValues;\n    int previousDepth= -1;\n\n    while(!nodeQueue.empty())\n    {\n        auto currentNode= nodeQueue.front();\n        nodeQueue.pop();\n        TreeNode *currentTreeNode= currentNode.first;\n        int currentDepth= currentNode.second;\n\n        if(previousDepth != currentDepth)\n        {\n            sort(levelValues.begin(), levelValues.end());\n            for(int i= 1; i < levelValues.size(); ++i)\n            {\n                swapCount+= abs(levelValues[i] - levelValues[i - 1]) - 1;\n            }\n            previousDepth= currentDepth;\n            levelValues.clear();\n        }\n        levelValues.push_back(currentTreeNode->value);\n\n        if(currentTreeNode->leftChild)\n            nodeQueue.push({currentTreeNode->leftChild, currentDepth + 1});\n        if(currentTreeNode->rightChild)\n            nodeQueue.push({currentTreeNode->rightChild, currentDepth + 1});\n    }\n\n    sort(levelValues.begin(), levelValues.end());\n    for(int i= 1; i < levelValues.size(); ++i)\n    {\n        swapCount+= abs(levelValues[i] - levelValues[i - 1]) - 1;\n    }\n\n    return swapCount;\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nint CalculateMinSwaps(TreeNode *rootNode)\n{\n    int swapCount= 0;\n    std::queue<std::pair<TreeNode *, int>> nodeQueue;\n    nodeQueue.push({rootNode, 0});\n\n    std::vector<int> levelValues;\n    int previousDepth= -1;\n\n    while(!nodeQueue.empty())\n    {\n        auto currentNode= nodeQueue.front();\n        nodeQueue.pop();\n        TreeNode *currentTreeNode= currentNode.first;\n        int currentDepth= currentNode.second;\n\n        if(previousDepth != currentDepth)\n        {\n            std::sort(levelValues.begin(), levelValues.end());\n            for(int i= 1; i < levelValues.size(); ++i)\n            {\n                swapCount+= std::abs(levelValues[i] - levelValues[i - 1]) - 1;\n            }\n            previousDepth= currentDepth;\n            levelValues.clear();\n        }\n        levelValues.push_back(currentTreeNode->value);\n\n        if(currentTreeNode->leftChild)\n            nodeQueue.push({currentTreeNode->leftChild, currentDepth + 1});\n        if(currentTreeNode->rightChild)\n            nodeQueue.push({currentTreeNode->rightChild, currentDepth + 1});\n    }\n\n    std::sort(levelValues.begin(), levelValues.end());\n    for(int i= 1; i < levelValues.size(); ++i)\n    {\n        swapCount+= std::abs(levelValues[i] - levelValues[i - 1]) - 1;\n    }\n\n    return swapCount;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countMaxPalindromicSubstrings(string inputString, int minLength)\n{\n    int stringLength= inputString.size();\n    if(stringLength < minLength)\n    {\n        return 0;\n    }\n    int palindromeCount= 0;\n    vector<vector<bool>> isPalindrome(stringLength, vector<bool>(stringLength, false));\n    for(int startIndex= stringLength - 1; startIndex >= 0; startIndex--)\n    {\n        for(int endIndex= startIndex; endIndex < stringLength; endIndex++)\n        {\n            if(startIndex == endIndex)\n            {\n                isPalindrome[startIndex][endIndex]= true;\n            }\n            else if(inputString[startIndex] == inputString[endIndex])\n            {\n                isPalindrome[startIndex][endIndex]= startIndex + 1 > endIndex - 1 || isPalindrome[startIndex + 1][endIndex - 1];\n            }\n            else\n            {\n                isPalindrome[startIndex][endIndex]= false;\n            }\n            if(endIndex - startIndex + 1 >= minLength && isPalindrome[startIndex][endIndex])\n            {\n                palindromeCount++;\n                startIndex= endIndex;\n                break;\n            }\n        }\n    }\n    return palindromeCount;\n}",
    "output": "#include <bits/stdc++.h>\nint CountMaxPalindromicSubstrings(std::string inputString, int minLength)\n{\n    int stringLength= inputString.size();\n    if(stringLength < minLength)\n    {\n        return 0;\n    }\n    int palindromeCount= 0;\n    std::vector<std::vector<bool>> isPalindrome(stringLength, std::vector<bool>(stringLength, false));\n    for(int startIndex= stringLength - 1; startIndex >= 0; startIndex--)\n    {\n        for(int endIndex= startIndex; endIndex < stringLength; endIndex++)\n        {\n            if(startIndex == endIndex)\n            {\n                isPalindrome[startIndex][endIndex]= true;\n            }\n            else if(inputString[startIndex] == inputString[endIndex])\n            {\n                isPalindrome[startIndex][endIndex]= startIndex + 1 > endIndex - 1 || isPalindrome[startIndex + 1][endIndex - 1];\n            }\n            else\n            {\n                isPalindrome[startIndex][endIndex]= false;\n            }\n            if(endIndex - startIndex + 1 >= minLength && isPalindrome[startIndex][endIndex])\n            {\n                palindromeCount++;\n                startIndex= endIndex;\n                break;\n            }\n        }\n    }\n    return palindromeCount;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> minTotalCost(int numberOfCities, vector<vector<int>> &roads, vector<int> &appleCosts, int k)\n{\n    vector<vector<pair<int, int>>> cityGraph(numberOfCities + 1);\n    for (int i = 0; i < roads.size(); ++i)\n    {\n        cityGraph[roads[i][0]].push_back({roads[i][1], roads[i][2]});\n        cityGraph[roads[i][1]].push_back({roads[i][0], roads[i][2]});\n    }\n\n    vector<int> totalCosts(numberOfCities);\n    for (int startCity = 1; startCity <= numberOfCities; ++startCity)\n    {\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> minHeap;\n        vector<int> distance(numberOfCities + 1, 1e9);\n        distance[startCity] = 0;\n        minHeap.push({0, startCity});\n        while (!minHeap.empty())\n        {\n            int currentCity = minHeap.top().second;\n            int currentDistance = minHeap.top().first;\n            minHeap.pop();\n\n            if (currentDistance > distance[currentCity])\n                continue;\n\n            for (int j = 0; j < cityGraph[currentCity].size(); ++j)\n            {\n                int adjacentCity = cityGraph[currentCity][j].first;\n                int cost = currentDistance + cityGraph[currentCity][j].second + (currentCity != startCity ? cityGraph[currentCity][j].second * k : 0) + appleCosts[adjacentCity - 1];\n\n                if (cost < distance[adjacentCity])\n                {\n                    distance[adjacentCity] = cost;\n                    minHeap.push({cost, adjacentCity});\n                }\n            }\n        }\n\n        totalCosts[startCity - 1] = distance[startCity];\n    }\n    return totalCosts;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> MinTotalCost(int numberOfCities, std::vector<std::vector<int>> &roads, std::vector<int> &appleCosts, int k)\n{\n    std::vector<std::vector<std::pair<int, int>>> cityGraph(numberOfCities + 1);\n    for (const auto &road : roads)\n    {\n        cityGraph[road[0]].push_back({road[1], road[2]});\n        cityGraph[road[1]].push_back({road[0], road[2]});\n    }\n\n    std::vector<int> totalCosts(numberOfCities);\n    for (int startCity = 1; startCity <= numberOfCities; ++startCity)\n    {\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> minHeap;\n        std::vector<int> distance(numberOfCities + 1, 1e9);\n        distance[startCity] = 0;\n        minHeap.push({0, startCity});\n        while (!minHeap.empty())\n        {\n            int currentCity = minHeap.top().second;\n            int currentDistance = minHeap.top().first;\n            minHeap.pop();\n\n            if (currentDistance > distance[currentCity])\n                continue;\n\n            for (int i = 0; i < cityGraph[currentCity].size(); ++i)\n            {\n                int adjacentCity = cityGraph[currentCity][i].first;\n                int cost = currentDistance + cityGraph[currentCity][i].second + (currentCity != startCity ? cityGraph[currentCity][i].second * k : 0) + appleCosts[adjacentCity - 1];\n\n                if (cost < distance[adjacentCity])\n                {\n                    distance[adjacentCity] = cost;\n                    minHeap.push({cost, adjacentCity});\n                }\n            }\n        }\n\n        totalCosts[startCity - 1] = distance[startCity];\n    }\n    return totalCosts;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countTriplets(vector<int> &numberList)\n{\n    int tripletCount= 0;\n    int listSize= numberList.size();\n\n    for(int firstIndex= 0; firstIndex < listSize; firstIndex++)\n    {\n        for(int secondIndex= firstIndex + 1; secondIndex < listSize; secondIndex++)\n        {\n            for(int thirdIndex= secondIndex + 1; thirdIndex < listSize; thirdIndex++)\n            {\n                if(numberList[firstIndex] != numberList[secondIndex] && numberList[firstIndex] != numberList[thirdIndex] && numberList[secondIndex] != numberList[thirdIndex])\n                {\n                    tripletCount++;\n                }\n            }\n        }\n    }\n\n    return tripletCount;\n}",
    "output": "#include <bits/stdc++.h>\nint CountTriplets(std::vector<int> &numberList)\n{\n    int tripletCount= 0;\n    int listSize= numberList.size();\n\n    for(int firstIndex= 0; firstIndex < listSize; firstIndex++)\n    {\n        for(int secondIndex= firstIndex + 1; secondIndex < listSize; secondIndex++)\n        {\n            for(int thirdIndex= secondIndex + 1; thirdIndex < listSize; thirdIndex++)\n            {\n                if(numberList[firstIndex] != numberList[secondIndex] && numberList[firstIndex] != numberList[thirdIndex] && numberList[secondIndex] != numberList[thirdIndex])\n                {\n                    tripletCount++;\n                }\n            }\n        }\n    }\n\n    return tripletCount;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nvector<vector<int>> findMinMax(TreeNode *root, vector<int> &queries)\n{\n    if(!root)\n    {\n        return {};\n    }\n\n    vector<vector<int>> result(queries.size(), vector<int>{-1, -1});\n    for(size_t index= 0; index < queries.size(); index++)\n    {\n        TreeNode *currentNode= root;\n        int currentQuery= queries[index];\n        while(currentNode)\n        {\n            if(currentNode->value < currentQuery)\n            {\n                result[index][0]= currentNode->value;\n                currentNode= currentNode->rightChild;\n            }\n            else\n            {\n                result[index][1]= currentNode->value;\n                if(currentNode->value == currentQuery)\n                {\n                    result[index][0]= currentQuery;\n                    break;\n                }\n                currentNode= currentNode->leftChild;\n            }\n        }\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n    TreeNode() : value(0), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x) : value(x), leftChild(NULL), rightChild(NULL) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : value(x), leftChild(left), rightChild(right) {}\n};\n\nstd::vector<std::vector<int>> FindMinMax(TreeNode *root, std::vector<int> &queries)\n{\n    if(!root)\n    {\n        return {};\n    }\n\n    std::vector<std::vector<int>> result(queries.size(), std::vector<int>{-1, -1});\n    for(size_t index= 0; index < queries.size(); index++)\n    {\n        TreeNode *currentNode= root;\n        int currentQuery= queries[index];\n        while(currentNode)\n        {\n            if(currentNode->value < currentQuery)\n            {\n                result[index][0]= currentNode->value;\n                currentNode= currentNode->rightChild;\n            }\n            else\n            {\n                result[index][1]= currentNode->value;\n                if(currentNode->value == currentQuery)\n                {\n                    result[index][0]= currentQuery;\n                    break;\n                }\n                currentNode= currentNode->leftChild;\n            }\n        }\n    }\n    return result;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMinimumFuel(vector<vector<int>> &roadConnections, int seatCapacity)\n{\n    int numberOfCities = roadConnections.size() + 1;\n    vector<vector<int>> cityGraph(numberOfCities);\n    for (const auto &road : roadConnections) // This can remain as a range-based for loop\n    {\n        cityGraph[road[0]].push_back(road[1]);\n        cityGraph[road[1]].push_back(road[0]);\n    }\n\n    vector<int> cityDistance(numberOfCities, -1);\n    queue<int> cityQueue;\n    cityQueue.push(0);\n    cityDistance[0] = 0;\n\n    while (!cityQueue.empty())\n    {\n        int currentCity = cityQueue.front();\n        cityQueue.pop();\n        for (int neighborCity : cityGraph[currentCity]) // This can remain as a range-based for loop\n        {\n            if (cityDistance[neighborCity] == -1)\n            {\n                cityDistance[neighborCity] = cityDistance[currentCity] + 1;\n                cityQueue.push(neighborCity);\n            }\n        }\n    }\n\n    int totalFuelRequired = 0;\n    for (int cityIndex = 1; cityIndex < numberOfCities; cityIndex++)\n    {\n        totalFuelRequired += (cityDistance[cityIndex] - 1) / (seatCapacity - 1) + 1;\n    }\n    return totalFuelRequired;\n}",
    "output": "#include <bits/stdc++.h>\nint CalculateMinimumFuel(std::vector<std::vector<int>> &roadConnections, int seatCapacity)\n{\n    int numberOfCities = roadConnections.size() + 1;\n    std::vector<std::vector<int>> cityGraph(numberOfCities);\n    for (auto &road : roadConnections)\n    {\n        cityGraph[road[0]].push_back(road[1]);\n        cityGraph[road[1]].push_back(road[0]);\n    }\n\n    std::vector<int> cityDistance(numberOfCities, -1);\n    std::queue<int> cityQueue;\n    cityQueue.push(0);\n    cityDistance[0] = 0;\n\n    while (!cityQueue.empty())\n    {\n        int currentCity = cityQueue.front();\n        cityQueue.pop();\n        for (int j = 0; j < cityGraph[currentCity].size(); ++j)\n        {\n            int neighborCity = cityGraph[currentCity][j];\n            if (cityDistance[neighborCity] == -1)\n            {\n                cityDistance[neighborCity] = cityDistance[currentCity] + 1;\n                cityQueue.push(neighborCity);\n            }\n        }\n    }\n\n    int totalFuelRequired = 0;\n    for (int cityIndex = 1; cityIndex < numberOfCities; cityIndex++)\n    {\n        totalFuelRequired += (cityDistance[cityIndex] - 1) / (seatCapacity - 1) + 1;\n    }\n    return totalFuelRequired;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint numBeautifulPartitions(const string &inputString, int partitionCount, int minimumLength)\n{\n    const int modulo= 1e9 + 7;\n    unordered_set<char> primeDigits= {'2', '3', '5', '7'};\n    int stringLength= inputString.length();\n    vector<vector<int>> dynamicProgramming(stringLength + 1, vector<int>(partitionCount + 1, 0));\n    dynamicProgramming[0][0]= 1;\n\n    for(int currentIndex= 1; currentIndex <= stringLength; ++currentIndex)\n    {\n        for(int currentPartitions= 1; currentPartitions <= partitionCount; ++currentPartitions)\n        {\n            for(int length= minimumLength; length <= currentIndex && currentIndex - length >= currentPartitions - 1; ++length)\n            {\n                if(primeDigits.count(inputString[currentIndex - length]) && !primeDigits.count(inputString[currentIndex - 1]))\n                {\n                    dynamicProgramming[currentIndex][currentPartitions]+= dynamicProgramming[currentIndex - length][currentPartitions - 1];\n                    if(dynamicProgramming[currentIndex][currentPartitions] >= modulo)\n                        dynamicProgramming[currentIndex][currentPartitions]-= modulo;\n                }\n            }\n        }\n    }\n\n    return dynamicProgramming[stringLength][partitionCount];\n}",
    "output": "#include <bits/stdc++.h>\nint NumBeautifulPartitions(const std::string &inputString, int partitionCount, int minimumLength)\n{\n    const int modulo= 1e9 + 7;\n    std::unordered_set<char> primeDigits= {'2', '3', '5', '7'};\n    int stringLength= inputString.length();\n    std::vector<std::vector<int>> dynamicProgramming(stringLength + 1, std::vector<int>(partitionCount + 1, 0));\n    dynamicProgramming[0][0]= 1;\n\n    for(int currentIndex= 1; currentIndex <= stringLength; ++currentIndex)\n    {\n        for(int currentPartitions= 1; currentPartitions <= partitionCount; ++currentPartitions)\n        {\n            for(int length= minimumLength; length <= currentIndex && currentIndex - length >= currentPartitions - 1; ++length)\n            {\n                if(primeDigits.count(inputString[currentIndex - length]) && !primeDigits.count(inputString[currentIndex - 1]))\n                {\n                    dynamicProgramming[currentIndex][currentPartitions]+= dynamicProgramming[currentIndex - length][currentPartitions - 1];\n                    if(dynamicProgramming[currentIndex][currentPartitions] >= modulo)\n                        dynamicProgramming[currentIndex][currentPartitions]-= modulo;\n                }\n            }\n        }\n    }\n\n    return dynamicProgramming[stringLength][partitionCount];\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint depthFirstSearch(int currentNode, int parentNode, vector<vector<int>> &adjacencyList, vector<int> &nodeValues, int &maximumXor)\n{\n    int currentXorSum = nodeValues[currentNode];\n\n    for (int i = 0; i < adjacencyList[currentNode].size(); ++i)\n    {\n        int childNode = adjacencyList[currentNode][i];\n        if (childNode != parentNode)\n        {\n            currentXorSum ^= depthFirstSearch(childNode, currentNode, adjacencyList, nodeValues, maximumXor);\n        }\n    }\n\n    maximumXor = max(maximumXor, currentXorSum);\n\n    return currentXorSum;\n}\n\nint maxXorSubtree(int totalNodes, vector<vector<int>> &edges, vector<int> &nodeValues)\n{\n    vector<vector<int>> adjacencyList(totalNodes);\n\n    for (const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1]);\n        adjacencyList[edge[1]].emplace_back(edge[0]);\n    }\n\n    int maximumXor = 0;\n    int rootXorSum = depthFirstSearch(0, -1, adjacencyList, nodeValues, maximumXor);\n\n    return rootXorSum ^ maximumXor;\n}",
    "output": "#include <bits/stdc++.h>\nstd::unordered_map<int, std::vector<int>> adjacencyList;\n\nint DepthFirstSearch(int currentNode, int parentNode, std::vector<std::vector<int>> &adjacencyList, std::vector<int> &nodeValues, int &maximumXor)\n{\n    int currentXorSum = nodeValues[currentNode];\n\n    for (int i = 0; i < adjacencyList[currentNode].size(); ++i)\n    {\n        int childNode = adjacencyList[currentNode][i];\n        if (childNode != parentNode)\n        {\n            currentXorSum ^= DepthFirstSearch(childNode, currentNode, adjacencyList, nodeValues, maximumXor);\n        }\n    }\n\n    maximumXor = std::max(maximumXor, currentXorSum);\n\n    return currentXorSum;\n}\n\nint MaxXorSubtree(int totalNodes, std::vector<std::vector<int>> &edges, std::vector<int> &nodeValues)\n{\n    std::vector<std::vector<int>> adjacencyList(totalNodes);\n\n    for (const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].emplace_back(edge[1]);\n        adjacencyList[edge[1]].emplace_back(edge[0]);\n    }\n\n    int maximumXor = 0;\n    int rootXorSum = DepthFirstSearch(0, -1, adjacencyList, nodeValues, maximumXor);\n\n    return rootXorSum ^ maximumXor;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "int minCuts(int number)\n{\n    if(number % 2 == 0)\n        return number / 2;\n    else\n        return number;\n}",
    "output": "int MinCuts(int number)\n{\n    if(number % 2 == 0)\n        return number / 2;\n    else\n        return number;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> createDifferenceMatrix(vector<vector<int>> &inputGrid)\n{\n    int rowCount= inputGrid.size(), columnCount= inputGrid[0].size();\n    vector<int> rowSum(rowCount, 0), columnSum(columnCount, 0);\n    vector<vector<int>> differenceMatrix(rowCount, vector<int>(columnCount));\n\n    for(int currentRowIndex= 0; currentRowIndex < rowCount; ++currentRowIndex)\n    {\n        for(int currentColIndex= 0; currentColIndex < columnCount; ++currentColIndex)\n        {\n            rowSum[currentRowIndex]+= inputGrid[currentRowIndex][currentColIndex];\n            columnSum[currentColIndex]+= inputGrid[currentRowIndex][currentColIndex];\n        }\n    }\n\n    for(int currentRowIndex= 0; currentRowIndex < rowCount; ++currentRowIndex)\n    {\n        for(int currentColIndex= 0; currentColIndex < columnCount; ++currentColIndex)\n        {\n            differenceMatrix[currentRowIndex][currentColIndex]= rowSum[currentRowIndex] + columnSum[currentColIndex] - (columnCount - rowSum[currentRowIndex]) - (rowCount - columnSum[currentColIndex]);\n        }\n    }\n\n    return differenceMatrix;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> CreateDifferenceMatrix(std::vector<std::vector<int>> &inputGrid)\n{\n    int rowCount= inputGrid.size(), columnCount= inputGrid[0].size();\n    std::vector<int> rowSum(rowCount, 0), columnSum(columnCount, 0);\n    std::vector<std::vector<int>> differenceMatrix(rowCount, std::vector<int>(columnCount));\n\n    for(int currentRowIndex= 0; currentRowIndex < rowCount; ++currentRowIndex)\n    {\n        for(int currentColIndex= 0; currentColIndex < columnCount; ++currentColIndex)\n        {\n            rowSum[currentRowIndex]+= inputGrid[currentRowIndex][currentColIndex];\n            columnSum[currentColIndex]+= inputGrid[currentRowIndex][currentColIndex];\n        }\n    }\n\n    for(int currentRowIndex= 0; currentRowIndex < rowCount; ++currentRowIndex)\n    {\n        for(int currentColIndex= 0; currentColIndex < columnCount; ++currentColIndex)\n        {\n            differenceMatrix[currentRowIndex][currentColIndex]= rowSum[currentRowIndex] + columnSum[currentColIndex] - (columnCount - rowSum[currentRowIndex]) - (rowCount - columnSum[currentColIndex]);\n        }\n    }\n\n    return differenceMatrix;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minPenalty(string customerSequence)\n{\n    int customerCount = customerSequence.length();\n    int openPenalty = 0, closedPenalty = 0;\n\n    for (int i = 0; i < customerCount; ++i)\n    {\n        char currentCustomer = customerSequence[i];\n        if (currentCustomer == 'N')\n            openPenalty++;\n        else\n            closedPenalty++;\n    }\n\n    int minimumPenalty = closedPenalty;\n    int currentPenalty = closedPenalty;\n\n    for (int index = 0; index < customerCount; index++)\n    {\n        if (customerSequence[index] == 'N')\n            currentPenalty--;\n        else\n            currentPenalty++;\n\n        minimumPenalty = min(minimumPenalty, currentPenalty);\n    }\n\n    return minimumPenalty;\n}",
    "output": "#include <bits/stdc++.h>\nint MinPenalty(std::string customerSequence)\n{\n    int customerCount = customerSequence.length();\n    int openPenalty = 0, closedPenalty = 0;\n\n    for (int i = 0; i < customerCount; i++)\n    {\n        char currentCustomer = customerSequence[i];\n        if (currentCustomer == 'N')\n            openPenalty++;\n        else\n            closedPenalty++;\n    }\n\n    int minimumPenalty = closedPenalty;\n    int currentPenalty = closedPenalty;\n\n    for (int index = 0; index < customerCount; index++)\n    {\n        if (customerSequence[index] == 'N')\n            currentPenalty--;\n        else\n            currentPenalty++;\n\n        minimumPenalty = std::min(minimumPenalty, currentPenalty);\n    }\n\n    return minimumPenalty;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countPalindromeSubsequences(string inputString, int modulus)\n{\n    int stringLength= inputString.size();\n    const int modulusValue= 1000000007;\n    vector<vector<int>> dpTable(10, vector<int>(stringLength, 0));\n    for(int i= 0; i < stringLength; ++i)\n        dpTable[inputString[i] - '0'][i]= 1;\n    for(int length= 1; length <= 4; ++length)\n    {\n        for(int digit= 0; digit < 10; ++digit)\n        {\n            for(int i= 0, j= length; j < stringLength; ++i, ++j)\n            {\n                dpTable[digit][j]= (dpTable[digit][j - 1] + (inputString[j] - '0' == digit)) % modulusValue;\n            }\n        }\n    }\n    long long totalCount= 0;\n    for(int firstDigit= 0; firstDigit < 10; ++firstDigit)\n    {\n        for(int secondDigit= 0; secondDigit < 10; ++secondDigit)\n        {\n            totalCount+= (1LL * dpTable[firstDigit][stringLength - 5] * dpTable[secondDigit][stringLength - 1]) % modulusValue;\n        }\n    }\n    return totalCount % modulusValue;\n}",
    "output": "#include <bits/stdc++.h>\nint CountPalindromeSubsequences(std::string inputString, int modulus)\n{\n    int stringLength= inputString.size();\n    const int modulusValue= 1000000007;\n    std::vector<std::vector<int>> dpTable(10, std::vector<int>(stringLength, 0));\n    for(int i= 0; i < stringLength; ++i)\n        dpTable[inputString[i] - '0'][i]= 1;\n    for(int length= 1; length <= 4; ++length)\n    {\n        for(int digit= 0; digit < 10; ++digit)\n        {\n            for(int i= 0, j= length; j < stringLength; ++i, ++j)\n            {\n                dpTable[digit][j]= (dpTable[digit][j - 1] + (inputString[j] - '0' == digit)) % modulusValue;\n            }\n        }\n    }\n    long long totalCount= 0;\n    for(int firstDigit= 0; firstDigit < 10; ++firstDigit)\n    {\n        for(int secondDigit= 0; secondDigit < 10; ++secondDigit)\n        {\n            totalCount+= (1LL * dpTable[firstDigit][stringLength - 5] * dpTable[secondDigit][stringLength - 1]) % modulusValue;\n        }\n    }\n    return totalCount % modulusValue;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "int findPivot(int totalNumbers)\n{\n    int totalSum= totalNumbers * (totalNumbers + 1) / 2;\n    int leftSum= 0;\n    for(int currentNumber= 1; currentNumber <= totalNumbers; ++currentNumber)\n    {\n        leftSum+= currentNumber;\n        if(2 * leftSum == totalSum)\n        {\n            return currentNumber;\n        }\n    }\n    return -1;\n}",
    "output": "int FindPivot(int totalNumbers)\n{\n    int totalSum= totalNumbers * (totalNumbers + 1) / 2;\n    int leftSum= 0;\n    for(int currentNumber= 1; currentNumber <= totalNumbers; ++currentNumber)\n    {\n        leftSum+= currentNumber;\n        if(2 * leftSum == totalSum)\n        {\n            return currentNumber;\n        }\n    }\n    return -1;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minAddition(string sourceString, string targetString)\n{\n    int sourceLength = sourceString.length();\n    int targetLength = targetString.length();\n    int sourceIndex = 0, targetIndex = 0;\n    while(sourceIndex < sourceLength && targetIndex < targetLength)\n    {\n        if(sourceString[sourceIndex] == targetString[targetIndex])\n        {\n            targetIndex++;\n        }\n        sourceIndex++;\n    }\n    return targetLength - targetIndex;\n}",
    "output": "int MinAddition(std::string sourceString, std::string targetString)\n{\n    int sourceLength= sourceString.length();\n    int targetLength= targetString.length();\n    int sourceIndex= 0, targetIndex= 0;\n    while(sourceIndex < sourceLength && targetIndex < targetLength)\n    {\n        if(sourceString[sourceIndex] == targetString[targetIndex])\n        {\n            targetIndex++;\n        }\n        sourceIndex++;\n    }\n    return targetLength - targetIndex;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "class ListNode\n{\n  public:\n    int value;\n    ListNode *next;\n};\n\nListNode *removeNodes(ListNode *head)\n{\n    if(!head)\n        return NULL;\n    ListNode *maxNode= head;\n    ListNode *currentNode= head;\n    ListNode *previousNode= NULL;\n\n    while(currentNode && currentNode->next)\n    {\n        if(currentNode->next->value > maxNode->value)\n        {\n            if(previousNode)\n                previousNode->next= currentNode->next;\n            else\n                head= currentNode->next;\n            maxNode= currentNode->next;\n        }\n        else\n        {\n            previousNode= currentNode;\n        }\n        currentNode= currentNode->next;\n    }\n    maxNode->next= removeNodes(maxNode->next);\n    return head;\n}",
    "output": "class ListNode\n{\n  public:\n    int value;\n    ListNode *next;\n};\n\nListNode *RemoveNodes(ListNode *head)\n{\n    if(!head)\n        return NULL;\n    ListNode *maxNode= head;\n    ListNode *currentNode= head;\n    ListNode *previousNode= NULL;\n\n    while(currentNode && currentNode->next)\n    {\n        if(currentNode->next->value > maxNode->value)\n        {\n            if(previousNode)\n                previousNode->next= currentNode->next;\n            else\n                head= currentNode->next;\n            maxNode= currentNode->next;\n        }\n        else\n        {\n            previousNode= currentNode;\n        }\n        currentNode= currentNode->next;\n    }\n    maxNode->next= RemoveNodes(maxNode->next);\n    return head;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countSubarraysWithMedian(vector<int> &numbers, int target)\n{\n    int resultCount = 0;\n    for(int startIndex = 0; startIndex < numbers.size(); ++startIndex)\n    {\n        int targetCount = 0;\n        vector<int> subarray;\n        for(int endIndex = startIndex; endIndex < numbers.size(); ++endIndex)\n        {\n            targetCount += (numbers[endIndex] == target);\n            subarray.insert(lower_bound(subarray.begin(), subarray.end(), numbers[endIndex]), numbers[endIndex]);\n            if((subarray.size() % 2 == 1) && (subarray[subarray.size() / 2] == target))\n            {\n                resultCount += targetCount;\n            }\n        }\n    }\n    return resultCount;\n}",
    "output": "int CountSubarraysWithMedian(std::vector<int> &numbers, int target)\n{\n    int resultCount= 0;\n    for(int startIndex= 0; startIndex < numbers.size(); ++startIndex)\n    {\n        int targetCount= 0;\n        std::vector<int> subarray;\n        for(int endIndex= startIndex; endIndex < numbers.size(); ++endIndex)\n        {\n            targetCount+= (numbers[endIndex] == target);\n            subarray.insert(lower_bound(subarray.begin(), subarray.end(), numbers[endIndex]), numbers[endIndex]);\n            if((subarray.size() % 2 == 1) && (subarray[subarray.size() / 2] == target))\n            {\n                resultCount+= targetCount;\n            }\n        }\n    }\n    return resultCount;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateRatioSubstringCount(string inputString, int firstNum, int secondNum)\n{\n    int zeroCount = 0, oneCount = 0;\n    map<int, int> frequencyMap;\n    int substringCount = 0;\n\n    frequencyMap[0] = 1;\n\n    for (int i = 0; i < inputString.size(); ++i)\n    {\n        char currentChar = inputString[i];\n        if (currentChar == '0')\n            zeroCount++;\n        else\n            oneCount++;\n\n        int currentDifference = zeroCount * secondNum - oneCount * firstNum;\n        substringCount += frequencyMap[currentDifference];\n        frequencyMap[currentDifference]++;\n    }\n    return substringCount;\n}",
    "output": "int CalculateRatioSubstringCount(std::string inputString, int firstNum, int secondNum)\n{\n    int zeroCount = 0, oneCount = 0;\n    std::map<int, int> frequencyMap;\n    int substringCount = 0;\n\n    frequencyMap[0] = 1;\n\n    for (int i = 0; i < inputString.size(); ++i)\n    {\n        char currentChar = inputString[i];\n        if (currentChar == '0')\n            zeroCount++;\n        else\n            oneCount++;\n\n        int currentDifference = zeroCount * secondNum - oneCount * firstNum;\n        substringCount += frequencyMap[currentDifference];\n        frequencyMap[currentDifference]++;\n    }\n    return substringCount;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isCircular(string sentence)\n{\n    stringstream stream(sentence);\n    string currentWord, previousWord;\n\n    while(stream >> currentWord)\n    {\n        if(!previousWord.empty() && previousWord.back() != currentWord.front())\n        {\n            return false;\n        }\n        previousWord = currentWord;\n    }\n\n    return currentWord.back() == sentence.front();\n}",
    "output": "bool IsCircular(std::string sentence)\n{\n    std::stringstream stream(sentence);\n    std::string currentWord, previousWord;\n\n    while(stream >> currentWord)\n    {\n        if(!previousWord.empty() && previousWord.back() != currentWord.front())\n        {\n            return false;\n        }\n        previousWord= currentWord;\n    }\n\n    return currentWord.back() == sentence.front();\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maximumChemistry(vector<int> &skillLevels)\n{\n    int totalSum = 0;\n    for (int i = 0; i < skillLevels.size(); ++i)\n    {\n        totalSum += skillLevels[i];\n    }\n    int targetSum = totalSum / 2;\n    if (totalSum % 2 == 1)\n        return -1;\n\n    unordered_map<int, int> dynamicProgrammingMap;\n    dynamicProgrammingMap[0] = 1;\n    int maxChemistry = 0;\n\n    for (int i = 0; i < skillLevels.size(); ++i)\n    {\n        int skill = skillLevels[i];\n        for (int j = targetSum - skill; j >= 0; j--)\n        {\n            if (dynamicProgrammingMap[j])\n            {\n                dynamicProgrammingMap[j + skill] += dynamicProgrammingMap[j];\n                if (j + skill == targetSum)\n                {\n                    maxChemistry += dynamicProgrammingMap[j] * skill;\n                }\n            }\n        }\n    }\n\n    return (maxChemistry > 0) ? maxChemistry : -1;\n}",
    "output": "#include <bits/stdc++.h>\nint MaximumChemistry(std::vector<int> &skillLevels)\n{\n    int totalSum = 0;\n    for (int i = 0; i < skillLevels.size(); ++i)\n    {\n        int skill = skillLevels[i];\n        totalSum += skill;\n    }\n    int targetSum = totalSum / 2;\n    if (totalSum % 2 == 1)\n        return -1;\n\n    std::unordered_map<int, int> dynamicProgrammingMap;\n    dynamicProgrammingMap[0] = 1;\n    int maxChemistry = 0;\n\n    for (int i = 0; i < skillLevels.size(); ++i)\n    {\n        int skill = skillLevels[i];\n        for (int j = targetSum - skill; j >= 0; j--)\n        {\n            if (dynamicProgrammingMap[j])\n            {\n                dynamicProgrammingMap[j + skill] += dynamicProgrammingMap[j];\n                if (j + skill == targetSum)\n                {\n                    maxChemistry += dynamicProgrammingMap[j] * skill;\n                }\n            }\n        }\n    }\n\n    return (maxChemistry > 0) ? maxChemistry : -1;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumScore(int totalCities, vector<vector<int>> &roads)\n{\n    vector<vector<pair<int, int>>> adjacencyList(totalCities + 1);\n    for (int i = 0; i < roads.size(); ++i)\n    {\n        adjacencyList[roads[i][0]].push_back({roads[i][1], roads[i][2]});\n        adjacencyList[roads[i][1]].push_back({roads[i][0], roads[i][2]});\n    }\n\n    const int infinity = 1e9;\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> priorityQueue;\n    priorityQueue.push({0, 1});\n\n    vector<int> minimumDistance(totalCities + 1, infinity);\n    while (!priorityQueue.empty())\n    {\n        int currentCity = priorityQueue.top().second;\n        int currentDistance = priorityQueue.top().first;\n        priorityQueue.pop();\n\n        if (currentCity == totalCities)\n        {\n            return currentDistance;\n        }\n\n        if (currentDistance < minimumDistance[currentCity])\n        {\n            minimumDistance[currentCity] = currentDistance;\n            for (int j = 0; j < adjacencyList[currentCity].size(); ++j)\n            {\n                const auto &neighbor = adjacencyList[currentCity][j];\n                int nextCity = neighbor.first;\n                int nextDistance = max(currentDistance, neighbor.second);\n                if (nextDistance < minimumDistance[nextCity])\n                {\n                    priorityQueue.push({nextDistance, nextCity});\n                }\n            }\n        }\n    }\n\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\n// for std::pair\n // for std::max\n\nint MinimumScore(int totalCities, std::vector<std::vector<int>> &roads)\n{\n    std::vector<std::vector<std::pair<int, int>>> adjacencyList(totalCities + 1);\n    for (int i = 0; i < roads.size(); ++i)\n    {\n        const auto &road = roads[i];\n        adjacencyList[road[0]].push_back({road[1], road[2]});\n        adjacencyList[road[1]].push_back({road[0], road[2]});\n    }\n\n    const int infinity = 1e9;\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<>> priorityQueue;\n    priorityQueue.push({0, 1});\n\n    std::vector<int> minimumDistance(totalCities + 1, infinity);\n    while (!priorityQueue.empty())\n    {\n        int currentCity = priorityQueue.top().second;\n        int currentDistance = priorityQueue.top().first;\n        priorityQueue.pop();\n\n        if (currentCity == totalCities)\n        {\n            return currentDistance;\n        }\n\n        if (currentDistance < minimumDistance[currentCity])\n        {\n            minimumDistance[currentCity] = currentDistance;\n            for (int j = 0; j < adjacencyList[currentCity].size(); ++j)\n            {\n                const auto &neighbor = adjacencyList[currentCity][j];\n                int nextCity = neighbor.first;\n                int nextDistance = std::max(currentDistance, neighbor.second);\n                if (nextDistance < minimumDistance[nextCity])\n                {\n                    priorityQueue.push({nextDistance, nextCity});\n                }\n            }\n        }\n    }\n\n    return -1;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxGroups(int numberOfNodes, vector<vector<int>> &edges)\n{\n    vector<vector<int>> adjacencyList(numberOfNodes + 1);\n    vector<int> nodeColor(numberOfNodes + 1, 0);\n\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        adjacencyList[edges[i][0]].push_back(edges[i][1]);\n        adjacencyList[edges[i][1]].push_back(edges[i][0]);\n    }\n\n    int maximumGroupSize = 0;\n    for (int nodeIndex = 1; nodeIndex <= numberOfNodes; ++nodeIndex)\n    {\n        if (nodeColor[nodeIndex] == 0)\n        {\n            queue<int> nodeQueue;\n            nodeQueue.push(nodeIndex);\n            nodeColor[nodeIndex] = 1;\n            while (!nodeQueue.empty())\n            {\n                int currentNode = nodeQueue.front();\n                nodeQueue.pop();\n                maximumGroupSize = max(maximumGroupSize, nodeColor[currentNode]);\n                for (int j = 0; j < adjacencyList[currentNode].size(); ++j)\n                {\n                    int neighbor = adjacencyList[currentNode][j];\n                    if (nodeColor[neighbor] == 0)\n                    {\n                        nodeColor[neighbor] = nodeColor[currentNode] + 1;\n                        nodeQueue.push(neighbor);\n                    }\n                    else if (nodeColor[neighbor] == nodeColor[currentNode])\n                    {\n                        return -1;\n                    }\n                }\n            }\n        }\n    }\n    return maximumGroupSize;\n}",
    "output": "#include <bits/stdc++.h>\nint MaxGroups(int numberOfNodes, std::vector<std::vector<int>> &edges)\n{\n    std::vector<std::vector<int>> adjacencyList(numberOfNodes + 1);\n    std::vector<int> nodeColor(numberOfNodes + 1, 0);\n\n    for(auto &edge : edges)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    int maximumGroupSize = 0;\n    for(int nodeIndex = 1; nodeIndex <= numberOfNodes; ++nodeIndex)\n    {\n        if(nodeColor[nodeIndex] == 0)\n        {\n            std::queue<int> nodeQueue;\n            nodeQueue.push(nodeIndex);\n            nodeColor[nodeIndex] = 1;\n            while(!nodeQueue.empty())\n            {\n                int currentNode = nodeQueue.front();\n                nodeQueue.pop();\n                maximumGroupSize = std::max(maximumGroupSize, nodeColor[currentNode]);\n                for(size_t i = 0; i < adjacencyList[currentNode].size(); ++i)\n                {\n                    int neighbor = adjacencyList[currentNode][i];\n                    if(nodeColor[neighbor] == 0)\n                    {\n                        nodeColor[neighbor] = nodeColor[currentNode] + 1;\n                        nodeQueue.push(neighbor);\n                    }\n                    else if(nodeColor[neighbor] == nodeColor[currentNode])\n                    {\n                        return -1;\n                    }\n                }\n            }\n        }\n    }\n    return maximumGroupSize;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countOfEvenSubarrays(vector<int> &numberArray)\n{\n    int arraySize = numberArray.size();\n    int evenCount = 0, oddCount = 0, totalCount = 0;\n\n    for (int i = 0; i < arraySize; ++i)\n    {\n        int currentNumber = numberArray[i];\n        if (currentNumber % 2 == 0)\n        {\n            evenCount++;\n            totalCount += evenCount;\n        }\n        else\n        {\n            swap(evenCount, oddCount);\n            oddCount++;\n            totalCount += oddCount;\n        }\n    }\n\n    return totalCount;\n}",
    "output": "#include <bits/stdc++.h>\n// for std::swap\n\nint CountOfEvenSubarrays(std::vector<int> &numberArray)\n{\n    int arraySize = numberArray.size();\n    int evenCount = 0, oddCount = 0, totalCount = 0;\n\n    for (int i = 0; i < arraySize; ++i)\n    {\n        int currentNumber = numberArray[i];\n        if (currentNumber % 2 == 0)\n        {\n            evenCount++;\n            totalCount += evenCount;\n        }\n        else\n        {\n            std::swap(evenCount, oddCount);\n            oddCount++;\n            totalCount += oddCount;\n        }\n    }\n\n    return totalCount;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxValue(vector<string> &stringList)\n{\n    int maxValue = 0;\n    for (int i = 0; i < stringList.size(); ++i)\n    {\n        const string &currentString = stringList[i];\n        int currentValue;\n        if (currentString.find_first_not_of(\"0123456789\") == string::npos)\n        {\n            currentValue = stoi(currentString);\n        }\n        else\n        {\n            currentValue = static_cast<int>(currentString.length());\n        }\n        maxValue = max(maxValue, currentValue);\n    }\n    return maxValue;\n}",
    "output": "#include <bits/stdc++.h>\nint MaxValue(std::vector<std::string> &stringList)\n{\n    int maxValue = 0;\n    for (int i = 0; i < stringList.size(); ++i)\n    {\n        const std::string &currentString = stringList[i];\n        int currentValue;\n        if (currentString.find_first_not_of(\"0123456789\") == std::string::npos)\n        {\n            currentValue = std::stoi(currentString);\n        }\n        else\n        {\n            currentValue = static_cast<int>(currentString.length());\n        }\n        maxValue = std::max(maxValue, currentValue);\n    }\n    return maxValue;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxStarSum(const vector<int> &nodeValues, const vector<vector<int>> &edges, int k)\n{\n    vector<int> adjacencyList[100000];\n    int maximumSum = -1e9;\n\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        const vector<int> &edge = edges[i];\n        adjacencyList[edge[0]].push_back(nodeValues[edge[1]]);\n        adjacencyList[edge[1]].push_back(nodeValues[edge[0]]);\n    }\n\n    for (int nodeIndex = 0; nodeIndex < nodeValues.size(); nodeIndex++)\n    {\n        sort(adjacencyList[nodeIndex].rbegin(), adjacencyList[nodeIndex].rend());\n        int currentSum = nodeValues[nodeIndex];\n        for (int j = 0; j < k && j < adjacencyList[nodeIndex].size(); j++)\n        {\n            currentSum += adjacencyList[nodeIndex][j];\n        }\n        maximumSum = max(maximumSum, currentSum);\n    }\n\n    return maximumSum;\n}",
    "output": "#include <bits/stdc++.h>\nint MaxStarSum(const std::vector<int> &nodeValues, const std::vector<std::vector<int>> &edges, int k)\n{\n    std::vector<int> adjacencyList[100000];\n    int maximumSum = -1e9;\n\n    for (const std::vector<int> &edge : edges)\n    {\n        adjacencyList[edge[0]].push_back(nodeValues[edge[1]]);\n        adjacencyList[edge[1]].push_back(nodeValues[edge[0]]);\n    }\n\n    for (int nodeIndex = 0; nodeIndex < nodeValues.size(); nodeIndex++)\n    {\n        std::sort(adjacencyList[nodeIndex].rbegin(), adjacencyList[nodeIndex].rend());\n        int currentSum = nodeValues[nodeIndex];\n        for (int j = 0; j < k && j < adjacencyList[nodeIndex].size(); j++)\n        {\n            currentSum += adjacencyList[nodeIndex][j];\n        }\n        maximumSum = std::max(maximumSum, currentSum);\n    }\n\n    return maximumSum;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumPathCost(vector<int> &stoneCosts)\n{\n    int numberOfStones= stoneCosts.size();\n    int minimumCost= stoneCosts[numberOfStones - 1];\n    for(int index= 1; index < numberOfStones - 1; ++index)\n    {\n        minimumCost= min(minimumCost, max(stoneCosts[index], stoneCosts[numberOfStones - 1] - stoneCosts[index]));\n    }\n    return minimumCost;\n}",
    "output": "#include <bits/stdc++.h>\nint MinimumPathCost(std::vector<int> &stoneCosts)\n{\n    int numberOfStones= stoneCosts.size();\n    int minimumCost= stoneCosts[numberOfStones - 1];\n    for(int index= 1; index < numberOfStones - 1; ++index)\n    {\n        minimumCost= std::min(minimumCost, std::max(stoneCosts[index], stoneCosts[numberOfStones - 1] - stoneCosts[index]));\n    }\n    return minimumCost;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minCost(vector<int> &firstArray, vector<int> &secondArray)\n{\n    unordered_map<int, vector<int>> valueToIndices;\n    for(int index = 0; index < firstArray.size(); ++index)\n    {\n        valueToIndices[firstArray[index]].push_back(index);\n    }\n\n    int totalCost = 0;\n    for(int i = 0; i < secondArray.size(); ++i)\n    {\n        int value = secondArray[i];\n        if(valueToIndices[value].empty())\n            return -1;\n        totalCost += valueToIndices[value].back();\n        valueToIndices[value].pop_back();\n    }\n\n    return totalCost;\n}",
    "output": "#include <bits/stdc++.h>\nint MinCost(std::vector<int> &firstArray, std::vector<int> &secondArray)\n{\n    std::unordered_map<int, std::vector<int>> valueToIndices;\n    for(int index= 0; index < firstArray.size(); ++index)\n    {\n        valueToIndices[firstArray[index]].push_back(index);\n    }\n\n    int totalCost= 0;\n    for(int i = 0; i < secondArray.size(); ++i)\n    {\n        int value = secondArray[i];\n        if(valueToIndices[value].empty())\n            return -1;\n        totalCost += valueToIndices[value].back();\n        valueToIndices[value].pop_back();\n    }\n\n    return totalCost;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxValueAfterOperations(vector<vector<int>> &grid)\n{\n    int totalMaxValue= 0;\n    while(!grid.empty())\n    {\n        int currentMaxValue= 0, maxRowIndex= -1;\n\n        for(int rowIndex= 0; rowIndex < grid.size(); ++rowIndex)\n        {\n            auto maxElementIterator= max_element(grid[rowIndex].begin(), grid[rowIndex].end());\n            if(*maxElementIterator > currentMaxValue)\n            {\n                currentMaxValue= *maxElementIterator;\n                maxRowIndex= rowIndex;\n            }\n            grid[rowIndex].erase(maxElementIterator);\n        }\n\n        totalMaxValue+= currentMaxValue;\n        if(grid[maxRowIndex].empty())\n        {\n            grid.erase(grid.begin() + maxRowIndex);\n        }\n    }\n\n    return totalMaxValue;\n}",
    "output": "#include <bits/stdc++.h>\nint MaxValueAfterOperations(std::vector<std::vector<int>> &grid)\n{\n    int totalMaxValue= 0;\n    while(!grid.empty())\n    {\n        int currentMaxValue= 0, maxRowIndex= -1;\n\n        for(int rowIndex= 0; rowIndex < grid.size(); ++rowIndex)\n        {\n            auto maxElementIterator= std::max_element(grid[rowIndex].begin(), grid[rowIndex].end());\n            if(*maxElementIterator > currentMaxValue)\n            {\n                currentMaxValue= *maxElementIterator;\n                maxRowIndex= rowIndex;\n            }\n            grid[rowIndex].erase(maxElementIterator);\n        }\n\n        totalMaxValue+= currentMaxValue;\n        if(grid[maxRowIndex].empty())\n        {\n            grid.erase(grid.begin() + maxRowIndex);\n        }\n    }\n\n    return totalMaxValue;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint longestSquareStreak(vector<int> &numberList)\n{\n    unordered_set<int> numberSet(numberList.begin(), numberList.end());\n    int longestStreak = -1;\n\n    for (auto it = numberSet.begin(); it != numberSet.end(); ++it)\n    {\n        int currentNumber = *it;\n        int currentStreak = 1;\n\n        while (numberSet.count(static_cast<int>(pow(currentNumber, 0.5))) > 0)\n        {\n            ++currentStreak;\n            currentNumber = static_cast<int>(pow(currentNumber, 0.5));\n        }\n\n        longestStreak = max(longestStreak, currentStreak);\n    }\n\n    return longestStreak >= 2 ? longestStreak : -1;\n}",
    "output": "#include <bits/stdc++.h>\nint LongestSquareStreak(std::vector<int> &numberList)\n{\n    std::unordered_set<int> numberSet(numberList.begin(), numberList.end());\n    int longestStreak = -1;\n\n    for (auto it = numberSet.begin(); it != numberSet.end(); ++it)\n    {\n        int currentNumber = *it;\n        int currentStreak = 1;\n\n        while (numberSet.count(static_cast<int>(std::pow(currentNumber, 0.5))) > 0)\n        {\n            ++currentStreak;\n            currentNumber = static_cast<int>(std::pow(currentNumber, 0.5));\n        }\n\n        longestStreak = std::max(longestStreak, currentStreak);\n    }\n\n    return longestStreak >= 2 ? longestStreak : -1;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Allocator\n{\n    vector<int> memory;\n\n  public:\n    Allocator(int size) : memory(size, 0) {}\n\n    int allocate(int blockSize, int memoryId)\n    {\n        int startIndex= -1, freeCount= 0;\n        for(int i= 0; i <= memory.size(); ++i)\n        {\n            if(i < memory.size() && memory[i] == 0)\n            {\n                if(startIndex == -1)\n                    startIndex= i;\n                freeCount++;\n            }\n            else\n            {\n                if(freeCount >= blockSize)\n                {\n                    fill(memory.begin() + startIndex, memory.begin() + startIndex + blockSize, memoryId);\n                    return startIndex;\n                }\n                startIndex= -1;\n                freeCount= 0;\n            }\n        }\n        return -1;\n    }\n\n    int free(int memoryId)\n    {\n        int freedCount= 0;\n        for(int i= 0; i < memory.size(); ++i)\n        {\n            if(memory[i] == memoryId)\n            {\n                freedCount++;\n                memory[i]= 0;\n            }\n        }\n        return freedCount;\n    }\n};",
    "output": "#include <bits/stdc++.h>\nclass Allocator\n{\n    std::vector<int> memory;\n\n  public:\n    Allocator(int size) : memory(size, 0) {}\n\n    int Allocate(int blockSize, int memoryId)\n    {\n        int startIndex= -1, freeCount= 0;\n        for(int i= 0; i <= memory.size(); ++i)\n        {\n            if(i < memory.size() && memory[i] == 0)\n            {\n                if(startIndex == -1)\n                    startIndex= i;\n                freeCount++;\n            }\n            else\n            {\n                if(freeCount >= blockSize)\n                {\n                    std::fill(memory.begin() + startIndex, memory.begin() + startIndex + blockSize, memoryId);\n                    return startIndex;\n                }\n                startIndex= -1;\n                freeCount= 0;\n            }\n        }\n        return -1;\n    }\n\n    int Free(int memoryId)\n    {\n        int freedCount= 0;\n        for(int i= 0; i < memory.size(); ++i)\n        {\n            if(memory[i] == memoryId)\n            {\n                freedCount++;\n                memory[i]= 0;\n            }\n        }\n        return freedCount;\n    }\n};"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> traverseMatrix(vector<vector<int>> &grid, const vector<int> &queries, int rows, int columns)\n{\n    vector<int> directionX= {-1, 0, 1, 0};\n    vector<int> directionY= {0, 1, 0, -1};\n    vector<int> result(queries.size(), 0);\n\n    for(int queryIndex= 0; queryIndex < queries.size(); ++queryIndex)\n    {\n        int queryValue= queries[queryIndex];\n        int pointsCount= 0;\n        set<pair<int, int>> visitedCells;\n\n        function<void(int, int)> depthFirstSearch= [&](int currentX, int currentY)\n        {\n            if(visitedCells.find({currentX, currentY}) == visitedCells.end() && grid[currentX][currentY] < queryValue)\n            {\n                visitedCells.insert({currentX, currentY});\n                pointsCount++;\n                for(int directionIndex= 0; directionIndex < 4; ++directionIndex)\n                {\n                    int nextX= currentX + directionX[directionIndex], nextY= currentY + directionY[directionIndex];\n                    if(nextX >= 0 && nextX < rows && nextY >= 0 && nextY < columns)\n                    {\n                        depthFirstSearch(nextX, nextY);\n                    }\n                }\n            }\n        };\n\n        depthFirstSearch(0, 0);\n        result[queryIndex]= pointsCount;\n    }\n\n    return result;\n}\n\nvector<int> maxPoints(vector<vector<int>> &grid, vector<int> &queries)\n{\n    int rows= grid.size();\n    int columns= grid[0].size();\n    return traverseMatrix(grid, queries, rows, columns);\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> TraverseMatrix(std::vector<std::vector<int>> &grid, const std::vector<int> &queries, int rows, int columns)\n{\n    std::vector<int> directionX= {-1, 0, 1, 0};\n    std::vector<int> directionY= {0, 1, 0, -1};\n    std::vector<int> result(queries.size(), 0);\n\n    for(int queryIndex= 0; queryIndex < queries.size(); ++queryIndex)\n    {\n        int queryValue= queries[queryIndex];\n        int pointsCount= 0;\n        std::set<std::pair<int, int>> visitedCells;\n\n        std::function<void(int, int)> depthFirstSearch= [&](int currentX, int currentY)\n        {\n            if(visitedCells.find({currentX, currentY}) == visitedCells.end() && grid[currentX][currentY] < queryValue)\n            {\n                visitedCells.insert({currentX, currentY});\n                pointsCount++;\n                for(int directionIndex= 0; directionIndex < 4; ++directionIndex)\n                {\n                    int nextX= currentX + directionX[directionIndex], nextY= currentY + directionY[directionIndex];\n                    if(nextX >= 0 && nextX < rows && nextY >= 0 && nextY < columns)\n                    {\n                        depthFirstSearch(nextX, nextY);\n                    }\n                }\n            }\n        };\n\n        depthFirstSearch(0, 0);\n        result[queryIndex]= pointsCount;\n    }\n\n    return result;\n}\n\nstd::vector<int> MaxPoints(std::vector<std::vector<int>> &grid, std::vector<int> &queries)\n{\n    int rows= grid.size();\n    int columns= grid[0].size();\n    return TraverseMatrix(grid, queries, rows, columns);\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint subsequenceOrSum(vector<int> &numbers)\n{\n    int orResult = 0;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int currentNumber = numbers[i];\n        orResult |= currentNumber;\n    }\n    return orResult;\n}",
    "output": "#include <bits/stdc++.h>\nint SubsequenceOrSum(std::vector<int> &numbers)\n{\n    int orResult = 0;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int currentNumber = numbers[i];\n        orResult |= currentNumber;\n    }\n    return orResult;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countSimilarPairs(vector<string> &wordList)\n{\n    int similarPairCount = 0;\n    for(int firstIndex = 0; firstIndex < wordList.size(); ++firstIndex)\n    {\n        for(int secondIndex = firstIndex + 1; secondIndex < wordList.size(); ++secondIndex)\n        {\n            unordered_set<char> firstWordSet{wordList[firstIndex].begin(), wordList[firstIndex].end()};\n            unordered_set<char> secondWordSet{wordList[secondIndex].begin(), wordList[secondIndex].end()};\n            if(firstWordSet == secondWordSet)\n                similarPairCount++;\n        }\n    }\n    return similarPairCount;\n}",
    "output": "#include <bits/stdc++.h>\nint CountSimilarPairs(std::vector<std::string> &wordList)\n{\n    int similarPairCount= 0;\n    for(int firstIndex= 0; firstIndex < wordList.size(); ++firstIndex)\n    {\n        for(int secondIndex= firstIndex + 1; secondIndex < wordList.size(); ++secondIndex)\n        {\n            std::unordered_set<char> firstWordSet{wordList[firstIndex].begin(), wordList[firstIndex].end()};\n            std::unordered_set<char> secondWordSet{wordList[secondIndex].begin(), wordList[secondIndex].end()};\n            if(firstWordSet == secondWordSet)\n                similarPairCount++;\n        }\n    }\n    return similarPairCount;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "int smallestFactorization(int number)\n{\n    if(number <= 3)\n        return number;\n    int factorizationResult= 0, factorMultiplier= 1;\n    for(int currentFactor= 2; currentFactor <= 5; ++currentFactor)\n    {\n        while(number % currentFactor == 0)\n        {\n            factorizationResult+= factorMultiplier * currentFactor;\n            factorMultiplier*= 10;\n            number/= currentFactor;\n        }\n    }\n    return number == 1 ? factorizationResult : number;\n}",
    "output": "int SmallestFactorization(int number)\n{\n    if(number <= 3)\n        return number;\n    int factorizationResult= 0, factorMultiplier= 1;\n    for(int currentFactor= 2; currentFactor <= 5; ++currentFactor)\n    {\n        while(number % currentFactor == 0)\n        {\n            factorizationResult+= factorMultiplier * currentFactor;\n            factorMultiplier*= 10;\n            number/= currentFactor;\n        }\n    }\n    return number == 1 ? factorizationResult : number;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPossibleDegreeEven(int numberOfVertices, vector<vector<int>> &edges)\n{\n    vector<int> vertexDegrees(numberOfVertices + 1, 0);\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        vertexDegrees[edges[i][0]]++;\n        vertexDegrees[edges[i][1]]++;\n    }\n\n    int oddDegreeCount = 0;\n    for (int index = 1; index <= numberOfVertices; index++)\n    {\n        if (vertexDegrees[index] % 2 != 0)\n            oddDegreeCount++;\n    }\n\n    return (oddDegreeCount == 0 || oddDegreeCount == 2);\n}",
    "output": "#include <bits/stdc++.h>\nbool IsPossibleDegreeEven(int numberOfVertices, std::vector<std::vector<int>> &edges)\n{\n    std::vector<int> vertexDegrees(numberOfVertices + 1, 0);\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        vertexDegrees[edges[i][0]]++;\n        vertexDegrees[edges[i][1]]++;\n    }\n\n    int oddDegreeCount = 0;\n    for (int index = 1; index <= numberOfVertices; index++)\n    {\n        if (vertexDegrees[index] % 2 != 0)\n            oddDegreeCount++;\n    }\n\n    return (oddDegreeCount == 0 || oddDegreeCount == 2);\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> lengthOfCycle(int numberOfNodes, const vector<vector<int>> &queries)\n{\n    vector<int> cycleLengths;\n    for (int i = 0; i < queries.size(); ++i)\n    {\n        const auto &query = queries[i];\n        int depthA = 0, depthB = 0, nodeA = query[0], nodeB = query[1];\n        while (nodeA != nodeB)\n        {\n            if (nodeA < nodeB)\n                swap(nodeA, nodeB);\n            nodeA >>= 1;\n            depthA++;\n        }\n        cycleLengths.push_back(depthA + depthB);\n    }\n    return cycleLengths;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> LengthOfCycle(int numberOfNodes, const std::vector<std::vector<int>> &queries)\n{\n    std::vector<int> cycleLengths;\n    for (int i = 0; i < queries.size(); ++i)\n    {\n        const auto &query = queries[i];\n        int depthA = 0, depthB = 0, nodeA = query[0], nodeB = query[1];\n        while (nodeA != nodeB)\n        {\n            if (nodeA < nodeB)\n                std::swap(nodeA, nodeB);\n            nodeA >>= 1;\n            depthA++;\n        }\n        cycleLengths.push_back(depthA + depthB);\n    }\n    return cycleLengths;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isValidPath(vector<vector<int>> &grid, int currentRow, int currentCol, int zeroCount, int oneCount)\n{\n    if(currentRow < 0 || currentCol < 0 || currentRow >= grid.size() || currentCol >= grid[0].size())\n    {\n        return false;\n    }\n    if(grid[currentRow][currentCol] == 1)\n    {\n        oneCount++;\n    }\n    else\n    {\n        zeroCount++;\n    }\n    if(currentRow == grid.size() - 1 && currentCol == grid[0].size() - 1)\n    {\n        return zeroCount == oneCount;\n    }\n    return isValidPath(grid, currentRow + 1, currentCol, zeroCount, oneCount) || isValidPath(grid, currentRow, currentCol + 1, zeroCount, oneCount);\n}\n\nbool equalPath(vector<vector<int>> &grid)\n{\n    return isValidPath(grid, 0, 0, 0, 0);\n}",
    "output": "#include <bits/stdc++.h>\nbool IsValidPath(std::vector<std::vector<int>> &grid, int currentRow, int currentCol, int zeroCount, int oneCount)\n{\n    if(currentRow < 0 || currentCol < 0 || currentRow >= grid.size() || currentCol >= grid[0].size())\n    {\n        return false;\n    }\n    if(grid[currentRow][currentCol] == 1)\n    {\n        oneCount++;\n    }\n    else\n    {\n        zeroCount++;\n    }\n    if(currentRow == grid.size() - 1 && currentCol == grid[0].size() - 1)\n    {\n        return zeroCount == oneCount;\n    }\n    return IsValidPath(grid, currentRow + 1, currentCol, zeroCount, oneCount) || IsValidPath(grid, currentRow, currentCol + 1, zeroCount, oneCount);\n}\n\nbool EqualPath(std::vector<std::vector<int>> &grid)\n{\n    return IsValidPath(grid, 0, 0, 0, 0);\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxCapturedForts(vector<int> &forts)\n{\n    int totalForts= forts.size();\n    int maxCapture= 0;\n    for(int currentFort= 0; currentFort < totalForts; currentFort++)\n    {\n        if(forts[currentFort] == 1)\n        {\n            for(int nextFort= currentFort + 1; nextFort < totalForts; nextFort++)\n            {\n                if(forts[nextFort] != -1)\n                {\n                    int captureCount= 0;\n                    for(int intermediateFort= currentFort + 1; intermediateFort < nextFort; intermediateFort++)\n                    {\n                        if(forts[intermediateFort] == 0)\n                            captureCount++;\n                    }\n                    if(forts[nextFort] == 1)\n                        maxCapture= max(maxCapture, captureCount);\n                }\n            }\n        }\n    }\n    return maxCapture;\n}",
    "output": "#include <bits/stdc++.h>\nint MaxCapturedForts(std::vector<int> &forts)\n{\n    int totalForts= forts.size();\n    int maxCapture= 0;\n    for(int currentFort= 0; currentFort < totalForts; currentFort++)\n    {\n        if(forts[currentFort] == 1)\n        {\n            for(int nextFort= currentFort + 1; nextFort < totalForts; nextFort++)\n            {\n                if(forts[nextFort] != -1)\n                {\n                    int captureCount= 0;\n                    for(int intermediateFort= currentFort + 1; intermediateFort < nextFort; intermediateFort++)\n                    {\n                        if(forts[intermediateFort] == 0)\n                            captureCount++;\n                    }\n                    if(forts[nextFort] == 1)\n                        maxCapture= std::max(maxCapture, captureCount);\n                }\n            }\n        }\n    }\n    return maxCapture;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> topKStudents(const vector<string> &positiveFeedback,\n                          const vector<string> &negativeFeedback,\n                          const vector<string> &reports,\n                          const vector<int> &studentIds,\n                          int k)\n{\n    unordered_map<int, int> studentPoints;\n    for(size_t i = 0; i < reports.size(); ++i)\n    {\n        int positiveCount = 0, negativeCount = 0;\n        for(size_t j = 0; j < positiveFeedback.size(); ++j)\n        {\n            const auto &positive = positiveFeedback[j];\n            size_t positiveIndex = reports[i].find(positive);\n            while(positiveIndex != string::npos)\n            {\n                ++positiveCount;\n                positiveIndex = reports[i].find(positive, positiveIndex + positive.length());\n            }\n        }\n        for(size_t j = 0; j < negativeFeedback.size(); ++j)\n        {\n            const auto &negative = negativeFeedback[j];\n            size_t negativeIndex = reports[i].find(negative);\n            while(negativeIndex != string::npos)\n            {\n                ++negativeCount;\n                negativeIndex = reports[i].find(negative, negativeIndex + negative.length());\n            }\n        }\n        studentPoints[studentIds[i]] += 3 * positiveCount - negativeCount;\n    }\n\n    vector<int> students(studentIds.begin(), studentIds.end());\n    sort(students.begin(), students.end(), [&studentPoints](int a, int b)\n         { return studentPoints[a] != studentPoints[b] ? studentPoints[a] > studentPoints[b] : a < b; });\n\n    return vector<int>(students.begin(), students.begin() + k);\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> TopKStudents(const std::vector<std::string> &positiveFeedback,\n                               const std::vector<std::string> &negativeFeedback,\n                               const std::vector<std::string> &reports,\n                               const std::vector<int> &studentIds,\n                               int k)\n{\n    std::unordered_map<int, int> studentPoints;\n    for(size_t i = 0; i < reports.size(); ++i)\n    {\n        int positiveCount = 0, negativeCount = 0;\n        for (size_t j = 0; j < positiveFeedback.size(); ++j)\n        {\n            const auto &positive = positiveFeedback[j];\n            size_t positiveIndex = reports[i].find(positive);\n            while (positiveIndex != std::string::npos)\n            {\n                ++positiveCount;\n                positiveIndex = reports[i].find(positive, positiveIndex + positive.length());\n            }\n        }\n        for (size_t j = 0; j < negativeFeedback.size(); ++j)\n        {\n            const auto &negative = negativeFeedback[j];\n            size_t negativeIndex = reports[i].find(negative);\n            while (negativeIndex != std::string::npos)\n            {\n                ++negativeCount;\n                negativeIndex = reports[i].find(negative, negativeIndex + negative.length());\n            }\n        }\n        studentPoints[studentIds[i]] += 3 * positiveCount - negativeCount;\n    }\n\n    std::vector<int> students(studentIds.begin(), studentIds.end());\n    std::sort(students.begin(), students.end(), [&studentPoints](int a, int b)\n              { return studentPoints[a] != studentPoints[b] ? studentPoints[a] > studentPoints[b] : a < b; });\n\n    return std::vector<int>(students.begin(), students.begin() + k);\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "int calculateMinimumPossibleMax(int divisor1, int divisor2, int uniqueCount1, int uniqueCount2)\n{\n    return (divisor1 - 1) * uniqueCount1 + (divisor2 - 1) * uniqueCount2 + 1;\n}",
    "output": "int CalculateMinimumPossibleMax(int divisor1, int divisor2, int uniqueCount1, int uniqueCount2)\n{\n    return (divisor1 - 1) * uniqueCount1 + (divisor2 - 1) * uniqueCount2 + 1;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\n// For std::min\nusing namespace std;\n\nint shortestDistance(vector<string> &words, string target, int startIndex)\n{\n    int totalWords = words.size();\n    int leftDistance = 0, rightDistance = 0, currentIndex = startIndex;\n    while(true)\n    {\n        if(words[currentIndex] == target)\n        {\n            return min(leftDistance, rightDistance);\n        }\n        leftDistance++;\n        rightDistance++;\n        currentIndex = (currentIndex + 1) % totalWords;\n        if(leftDistance == totalWords)\n        {\n            break;\n        }\n    }\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\n// For std::min\n\nint ShortestDistance(std::vector<std::string> &words, std::string target, int startIndex)\n{\n    int totalWords = words.size();\n    int leftDistance = 0, rightDistance = 0, currentIndex = startIndex;\n    while (true)\n    {\n        if (words[currentIndex] == target)\n        {\n            return std::min(leftDistance, rightDistance);\n        }\n        leftDistance++;\n        rightDistance++;\n        currentIndex = (currentIndex + 1) % totalWords;\n        if (leftDistance == totalWords)\n        {\n            break;\n        }\n    }\n    return -1;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minMinutes(string inputString, int requiredCount)\n{\n    int stringLength = inputString.length();\n    vector<int> leftCharacterCounts(3, 0), rightCharacterCounts(3, 0);\n    for (int i = 0; i < stringLength; ++i)\n        rightCharacterCounts[inputString[i] - 'a']++;\n\n    int minimumMinutes = stringLength, totalCount = 0;\n    while (true)\n    {\n        int leftIndex = 0, rightIndex = stringLength - 1;\n        while (leftIndex < rightIndex && leftCharacterCounts[inputString[leftIndex] - 'a'] < requiredCount && rightCharacterCounts[inputString[rightIndex] - 'a'] < requiredCount)\n        {\n            int neededLeft = max(0, requiredCount - leftCharacterCounts[inputString[leftIndex] - 'a']);\n            int neededRight = max(0, requiredCount - rightCharacterCounts[inputString[rightIndex] - 'a']);\n            if (neededLeft <= neededRight)\n            {\n                totalCount += neededLeft;\n                leftCharacterCounts[inputString[leftIndex] - 'a'] += neededLeft; // Fixed increment\n                rightCharacterCounts[inputString[leftIndex] - 'a'] -= neededLeft; // Fixed decrement\n                leftIndex++;\n            }\n            else\n            {\n                totalCount += neededRight;\n                rightCharacterCounts[inputString[rightIndex] - 'a'] -= neededRight; // Fixed decrement\n                leftCharacterCounts[inputString[rightIndex] - 'a'] += neededRight; // Fixed increment\n                rightIndex--;\n            }\n        }\n        minimumMinutes = min(minimumMinutes, totalCount);\n        if (leftIndex + 1 < inputString.length())\n        {\n            totalCount -= leftCharacterCounts[inputString[leftIndex] - 'a'];\n            leftCharacterCounts[inputString[leftIndex] - 'a']--;\n            rightCharacterCounts[inputString[leftIndex + 1] - 'a']++;\n            leftIndex++;\n        }\n        else\n            break;\n    }\n    if (leftCharacterCounts[0] >= requiredCount && leftCharacterCounts[1] >= requiredCount && leftCharacterCounts[2] >= requiredCount)\n        return minimumMinutes;\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint MinMinutes(std::string inputString, int requiredCount)\n{\n    int stringLength = inputString.length();\n    std::vector<int> leftCharacterCounts(3, 0), rightCharacterCounts(3, 0);\n    for (int i = 0; i < stringLength; ++i)\n        rightCharacterCounts[inputString[i] - 'a']++;\n\n    int minimumMinutes = stringLength, totalCount = 0;\n    while (true)\n    {\n        int leftIndex = 0, rightIndex = stringLength - 1;\n        while (leftIndex < rightIndex && leftCharacterCounts[inputString[leftIndex] - 'a'] < requiredCount && rightCharacterCounts[inputString[rightIndex] - 'a'] < requiredCount)\n        {\n            int neededLeft = std::max(0, requiredCount - leftCharacterCounts[inputString[leftIndex] - 'a']);\n            int neededRight = std::max(0, requiredCount - rightCharacterCounts[inputString[rightIndex] - 'a']);\n            if (neededLeft <= neededRight)\n            {\n                totalCount += neededLeft;\n                leftCharacterCounts[inputString[leftIndex] - 'a'] += neededLeft; // Correctly increment the count\n                rightCharacterCounts[inputString[leftIndex] - 'a'] -= neededLeft; // Correctly decrement the count\n                leftIndex++;\n            }\n            else\n            {\n                totalCount += neededRight;\n                rightCharacterCounts[inputString[rightIndex] - 'a'] -= neededRight; // Correctly decrement the count\n                leftCharacterCounts[inputString[rightIndex] - 'a'] += neededRight; // Correctly increment the count\n                rightIndex--;\n            }\n        }\n        minimumMinutes = std::min(minimumMinutes, totalCount);\n        if (leftIndex + 1 < inputString.length())\n        {\n            totalCount -= leftCharacterCounts[inputString[leftIndex] - 'a'];\n            leftCharacterCounts[inputString[leftIndex] - 'a']--;\n            rightCharacterCounts[inputString[leftIndex + 1] - 'a']++;\n            leftIndex++;\n        }\n        else\n            break;\n    }\n    if (leftCharacterCounts[0] >= requiredCount && leftCharacterCounts[1] >= requiredCount && leftCharacterCounts[2] >= requiredCount)\n        return minimumMinutes;\n    return -1;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMaxTastiness(vector<int> &prices, int numberOfItems)\n{\n    sort(prices.begin(), prices.end());\n    int maxTastiness= 0;\n    for(int i= 0; i < prices.size() - numberOfItems + 1; i++)\n    {\n        int minDifference= INT_MAX;\n        for(int j= i; j < i + numberOfItems - 1; j++)\n        {\n            minDifference= min(minDifference, prices[j + 1] - prices[j]);\n        }\n        maxTastiness= max(maxTastiness, minDifference);\n    }\n\n    return maxTastiness;\n}",
    "output": "#include <bits/stdc++.h>\nint CalculateMaxTastiness(std::vector<int> &prices, int numberOfItems)\n{\n    std::sort(prices.begin(), prices.end());\n    int maxTastiness= 0;\n    for(int i= 0; i < prices.size() - numberOfItems + 1; i++)\n    {\n        int minDifference= INT_MAX;\n        for(int j= i; j < i + numberOfItems - 1; j++)\n        {\n            minDifference= std::min(minDifference, prices[j + 1] - prices[j]);\n        }\n        maxTastiness= std::max(maxTastiness, minDifference);\n    }\n\n    return maxTastiness;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countPartitions(vector<int> &numbers, int target)\n{\n    long long totalSum = 0;\n    int size = numbers.size();\n    int modulus = 1000000007;\n\n    for (int i = 0; i < size; ++i)\n    {\n        totalSum += numbers[i];\n    }\n\n    if (totalSum < target * 2)\n    {\n        return 0;\n    }\n\n    vector<long long> dynamicProgramming(size + 1, 1);\n\n    for (int i = 1; i <= target - 1; i++)\n    {\n        for (int j = size - 1; j >= 1; j--)\n        {\n            dynamicProgramming[j] = (dynamicProgramming[j] * j + dynamicProgramming[j - 1]) % modulus;\n        }\n    }\n\n    long long result = 0;\n\n    for (int i = 0; i < size - 1; i++)\n    {\n        totalSum -= numbers[i];\n        if (totalSum >= target)\n        {\n            result = (result + dynamicProgramming[i + 1]) % modulus;\n        }\n    }\n\n    return (int)result;\n}",
    "output": "#include <bits/stdc++.h>\nint CountPartitions(std::vector<int> &numbers, int target)\n{\n    long long totalSum = 0;\n    int size = numbers.size();\n    int modulus = 1000000007;\n\n    for (int number : numbers)\n    {\n        totalSum += number;\n    }\n\n    if (totalSum < target * 2)\n    {\n        return 0;\n    }\n\n    std::vector<long long> dynamicProgramming(size + 1, 1);\n\n    for (int i = 1; i <= target - 1; i++)\n    {\n        for (int j = size - 1; j >= 1; j--)\n        {\n            dynamicProgramming[j] = (dynamicProgramming[j] * j + dynamicProgramming[j - 1]) % modulus;\n        }\n    }\n\n    long long result = 0;\n\n    for (int i = 0; i < size - 1; i++)\n    {\n        totalSum -= numbers[i];\n        if (totalSum >= target)\n        {\n            result = (result + dynamicProgramming[i + 1]) % modulus;\n        }\n    }\n\n    return (int)result;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countKBigIndices(vector<int> &numbers, int threshold)\n{\n    int size= numbers.size();\n    vector<int> leftIndices(size, 0), rightIndices(size, 0);\n\n    for(int index= 1; index < size; ++index)\n    {\n        if(numbers[index] > numbers[index - 1])\n            leftIndices[index]= leftIndices[index - 1] + 1;\n\n        int reverseIndex= size - index - 1;\n        if(reverseIndex + 1 < size && numbers[reverseIndex] < numbers[reverseIndex + 1]) // Ensure we don't go out of bounds\n            rightIndices[reverseIndex]= rightIndices[reverseIndex + 1] + 1;\n    }\n\n    int totalCount= 0;\n    for(int index= 0; index < size; ++index)\n        if(leftIndices[index] >= threshold && rightIndices[index] >= threshold)\n            totalCount++;\n\n    return totalCount;\n}",
    "output": "#include <bits/stdc++.h>\nint CountKBigIndices(std::vector<int> &numbers, int threshold)\n{\n    int size= numbers.size();\n    std::vector<int> leftIndices(size, 0), rightIndices(size, 0);\n\n    for(int index= 1; index < size; ++index)\n    {\n        if(numbers[index] > numbers[index - 1])\n            leftIndices[index]= leftIndices[index - 1] + 1;\n\n        int reverseIndex= size - index - 1;\n        if(reverseIndex + 1 < size && numbers[reverseIndex] < numbers[reverseIndex + 1]) // Ensure reverseIndex + 1 is within bounds\n            rightIndices[reverseIndex]= rightIndices[reverseIndex + 1] + 1;\n    }\n\n    int totalCount= 0;\n    for(int index= 0; index < size; ++index)\n        if(leftIndices[index] >= threshold && rightIndices[index] >= threshold)\n            totalCount++;\n\n    return totalCount;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "int countDigitsDividingNumber(int inputNumber)\n{\n    int divisorCount= 0, tempNumber= inputNumber;\n    while(tempNumber > 0)\n    {\n        int currentDigit= tempNumber % 10;\n        if(inputNumber % currentDigit == 0)\n        {\n            divisorCount++;\n        }\n        tempNumber/= 10;\n    }\n    return divisorCount;\n}",
    "output": "int CountDigitsDividingNumber(int inputNumber)\n{\n    int divisorCount= 0, tempNumber= inputNumber;\n    while(tempNumber > 0)\n    {\n        int currentDigit= tempNumber % 10;\n        if(inputNumber % currentDigit == 0)\n        {\n            divisorCount++;\n        }\n        tempNumber/= 10;\n    }\n    return divisorCount;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countDistinctPrimeFactors(const vector<int> &numbers)\n{\n    set<int> distinctPrimeFactors;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int number = numbers[i];\n        for (int divisor = 2; divisor * divisor <= number; ++divisor)\n        {\n            if (number % divisor == 0)\n            {\n                distinctPrimeFactors.insert(divisor);\n                distinctPrimeFactors.insert(number / divisor);\n            }\n        }\n    }\n    return distinctPrimeFactors.size();\n}",
    "output": "#include <bits/stdc++.h>\nint CountDistinctPrimeFactors(const std::vector<int> &numbers)\n{\n    std::set<int> distinctPrimeFactors;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int number = numbers[i];\n        for (int divisor = 2; divisor * divisor <= number; ++divisor)\n        {\n            if (number % divisor == 0)\n            {\n                distinctPrimeFactors.insert(divisor);\n                distinctPrimeFactors.insert(number / divisor);\n            }\n        }\n    }\n    return distinctPrimeFactors.size();\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minPartitions(string numberString, int maxValue)\n{\n    int stringLength= numberString.size();\n    int partitionCount= 0, currentIndex= 0;\n\n    while(currentIndex < stringLength)\n    {\n        int currentValue= 0;\n        // Make sure the currentValue is below maxValue\n        while(currentIndex < stringLength && currentValue * 10 + (numberString[currentIndex] - '0') <= maxValue)\n        {\n            currentValue= currentValue * 10 + (numberString[currentIndex] - '0');\n            currentIndex++;\n        }\n\n        if(currentValue == 0)\n            return -1;\n        partitionCount++;\n    }\n\n    return partitionCount;\n}",
    "output": "#include <bits/stdc++.h>\nint MinPartitions(std::string numberString, int maxValue)\n{\n    int stringLength= numberString.size();\n    int partitionCount= 0, currentIndex= 0;\n\n    while(currentIndex < stringLength)\n    {\n        int currentValue= 0;\n        // Make sure the currentValue is below maxValue\n        while(currentIndex < stringLength && currentValue * 10 + (numberString[currentIndex] - '0') <= maxValue)\n        {\n            currentValue= currentValue * 10 + (numberString[currentIndex] - '0');\n            currentIndex++;\n        }\n\n        if(currentValue == 0)\n            return -1;\n        partitionCount++;\n    }\n\n    return partitionCount;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPrime(int number)\n{\n    if(number <= 1)\n        return false;\n    for(int divisor= 2; divisor * divisor <= number; ++divisor)\n    {\n        if(number % divisor == 0)\n            return false;\n    }\n    return true;\n}\n\nvector<int> closestPrimePair(int rangeStart, int rangeEnd)\n{\n    int minimumDistance= rangeEnd - rangeStart + 1;\n    vector<int> result= {-1, -1};\n    for(int currentNumber= rangeStart; currentNumber <= rangeEnd; ++currentNumber)\n    {\n        if(isPrime(currentNumber))\n        {\n            for(int nextNumber= currentNumber + 1; nextNumber <= rangeEnd; ++nextNumber)\n            {\n                if(isPrime(nextNumber) && nextNumber - currentNumber < minimumDistance)\n                {\n                    minimumDistance= nextNumber - currentNumber;\n                    result= {currentNumber, nextNumber};\n                }\n            }\n        }\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nbool IsPrime(int number)\n{\n    if(number <= 1)\n        return false;\n    for(int divisor= 2; divisor * divisor <= number; ++divisor)\n    {\n        if(number % divisor == 0)\n            return false;\n    }\n    return true;\n}\n\nstd::vector<int> ClosestPrimePair(int rangeStart, int rangeEnd)\n{\n    int minimumDistance= rangeEnd - rangeStart + 1;\n    std::vector<int> result= {-1, -1};\n    for(int currentNumber= rangeStart; currentNumber <= rangeEnd; ++currentNumber)\n    {\n        if(IsPrime(currentNumber))\n        {\n            for(int nextNumber= currentNumber + 1; nextNumber <= rangeEnd; ++nextNumber)\n            {\n                if(IsPrime(nextNumber) && nextNumber - currentNumber < minimumDistance)\n                {\n                    minimumDistance= nextNumber - currentNumber;\n                    result= {currentNumber, nextNumber};\n                }\n            }\n        }\n    }\n    return result;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxFrequencyScore(vector<int> &numbers, int k)\n{\n    int size= numbers.size();\n    int rightIndex= 0, currentCount= 0, maxScore= 0;\n    long long currentScore= 0;\n    unordered_map<int, int> frequencyMap;\n\n    for(int leftIndex= 0; leftIndex < size; ++leftIndex)\n    {\n        while(rightIndex < size && currentCount < k)\n        {\n            currentScore= (currentScore + (long long)numbers[rightIndex] * frequencyMap[numbers[rightIndex]]) % 1000000007;\n            frequencyMap[numbers[rightIndex]]++;\n            currentCount++;\n            rightIndex++;\n        }\n\n        maxScore= max(maxScore, (int)currentScore);\n\n        if(currentCount == k)\n        {\n            currentScore-= numbers[leftIndex] * (frequencyMap[numbers[leftIndex]] - 1);\n            frequencyMap[numbers[leftIndex]]--;\n            currentCount--;\n        }\n    }\n\n    return maxScore;\n}",
    "output": "#include <bits/stdc++.h>\nint MaxFrequencyScore(std::vector<int> &numbers, int k)\n{\n    int size= numbers.size();\n    int rightIndex= 0, currentCount= 0, maxScore= 0;\n    long long currentScore= 0;\n    std::unordered_map<int, int> frequencyMap;\n\n    for(int leftIndex= 0; leftIndex < size; ++leftIndex)\n    {\n        while(rightIndex < size && currentCount < k)\n        {\n            currentScore= (currentScore + (long long)numbers[rightIndex] * frequencyMap[numbers[rightIndex]]) % 1000000007;\n            frequencyMap[numbers[rightIndex]]++;\n            currentCount++;\n            rightIndex++;\n        }\n\n        maxScore= std::max(maxScore, (int)currentScore);\n\n        if(currentCount == k)\n        {\n            currentScore-= numbers[leftIndex] * (frequencyMap[numbers[leftIndex]] - 1);\n            frequencyMap[numbers[leftIndex]]--;\n            currentCount--;\n        }\n    }\n\n    return maxScore;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring getBoxCategory(int boxLength, int boxWidth, int boxHeight, int boxMass)\n{\n    bool isBulky= boxLength >= 10000 || boxWidth >= 10000 || boxHeight >= 10000 || (long)boxLength * boxWidth * boxHeight >= 1000000000;\n    bool isHeavy= boxMass >= 100;\n\n    if(isBulky && isHeavy)\n        return \"Both \";\n    if(isBulky)\n        return \"Bulky \";\n    if(isHeavy)\n        return \"Heavy \";\n    return \"Neither \";\n}",
    "output": "#include <bits/stdc++.h>\nstd::string GetBoxCategory(int boxLength, int boxWidth, int boxHeight, int boxMass)\n{\n    bool isBulky= boxLength >= 10000 || boxWidth >= 10000 || boxHeight >= 10000 || (long)boxLength * boxWidth * boxHeight >= 1000000000;\n    bool isHeavy= boxMass >= 100;\n\n    if(isBulky && isHeavy)\n        return \"Both \";\n    if(isBulky)\n        return \"Bulky \";\n    if(isHeavy)\n        return \"Heavy \";\n    return \"Neither \";\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass DataStream\n{\n  public:\n    DataStream(int targetValue, int sequenceLength) : targetValue(targetValue), sequenceLength(sequenceLength) {}\n\n    bool consec(int num)\n    {\n        dataStream.push_back(num);\n        if(dataStream.size() > sequenceLength)\n            dataStream.pop_front();\n\n        return dataStream.size() == sequenceLength && count(dataStream.begin(), dataStream.end(), targetValue) == sequenceLength;\n    }\n\n  private:\n    int targetValue;\n    int sequenceLength;\n    deque<int> dataStream;\n};",
    "output": "#include <bits/stdc++.h>\nclass DataStream\n{\n  public:\n    DataStream(int targetValue, int sequenceLength) : targetValue(targetValue), sequenceLength(sequenceLength) {}\n\n    bool Consec(int num)\n    {\n        dataStream.push_back(num);\n        if(dataStream.size() > sequenceLength)\n            dataStream.pop_front();\n\n        return dataStream.size() == sequenceLength && count(dataStream.begin(), dataStream.end(), targetValue) == sequenceLength;\n    }\n\n  private:\n    int targetValue;\n    int sequenceLength;\n    std::deque<int> dataStream;\n};"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateXorBeauty(vector<int> &inputNumbers)\n{\n    int numberOfElements = inputNumbers.size();\n    int maximumXorValue = 1024; // Maximum value for bitwise operations\n    vector<int> frequencyCounter(maximumXorValue, 0);\n\n    for (int i = 0; i < numberOfElements; ++i)\n    {\n        frequencyCounter[inputNumbers[i] % maximumXorValue]++;\n    }\n\n    int xorBeautyResult = 0;\n    for (int i = 0; i < maximumXorValue; i++)\n    {\n        for (int j = i; j < maximumXorValue; j++)\n        {\n            int commonBits = (i | j) & (~(i ^ j));\n            if (commonBits < maximumXorValue && commonBits >= j)\n            {\n                int countCombinations = frequencyCounter[i] * frequencyCounter[j] * (i == j ? 1 : 2);\n                if (commonBits != i && commonBits != j)\n                {\n                    countCombinations *= frequencyCounter[commonBits];\n                }\n                xorBeautyResult ^= countCombinations;\n            }\n        }\n    }\n\n    return xorBeautyResult;\n}",
    "output": "#include <bits/stdc++.h>\nint CalculateXorBeauty(std::vector<int> &inputNumbers)\n{\n    int numberOfElements = inputNumbers.size();\n    int maximumXorValue = 1024; // Maximum value for bitwise operations\n    std::vector<int> frequencyCounter(maximumXorValue, 0);\n\n    for(int i = 0; i < numberOfElements; ++i)\n    {\n        frequencyCounter[inputNumbers[i] % maximumXorValue]++;\n    }\n\n    int xorBeautyResult = 0;\n    for(int i = 0; i < maximumXorValue; i++)\n    {\n        for(int j = i; j < maximumXorValue; j++)\n        {\n            int commonBits = (i | j) & (~(i ^ j));\n            if(commonBits < maximumXorValue && commonBits >= j)\n            {\n                int countCombinations = frequencyCounter[i] * frequencyCounter[j] * (i == j ? 1 : 2);\n                if(commonBits != i && commonBits != j)\n                {\n                    countCombinations *= frequencyCounter[commonBits];\n                }\n                xorBeautyResult ^= countCombinations;\n            }\n        }\n    }\n\n    return xorBeautyResult;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMaxMinPower(vector<int> &stationPowers, int range, int additionalPower)\n{\n    int numberOfStations = stationPowers.size();\n    vector<int> totalPower(numberOfStations);\n    for(int currentStation = 0; currentStation < numberOfStations; currentStation++)\n    {\n        for(int nearbyStation = max(0, currentStation - range); nearbyStation <= min(numberOfStations - 1, currentStation + range); nearbyStation++)\n        {\n            totalPower[nearbyStation] += stationPowers[currentStation];\n        }\n    }\n\n    int sumOfK = 0, minimumPower = INT_MAX;\n    for(int currentIndex = range; currentIndex < numberOfStations - range; currentIndex++)\n    {\n        sumOfK += stationPowers[currentIndex];\n        minimumPower = min(minimumPower, totalPower[currentIndex]);\n    }\n\n    for(int j = 0, i = numberOfStations - 2 * range; j < 2 * range; j++, i--)\n    {\n        sumOfK -= stationPowers[i + range + 1];\n        minimumPower -= stationPowers[j];\n        minimumPower += sumOfK;\n        minimumPower += additionalPower;\n        minimumPower = min(minimumPower, totalPower[j]);\n    }\n\n    return minimumPower;\n}",
    "output": "#include <bits/stdc++.h>\nint CalculateMaxMinPower(std::vector<int> &stationPowers, int range, int additionalPower)\n{\n    int numberOfStations = stationPowers.size();\n    std::vector<int> totalPower(numberOfStations);\n    for (int currentStation = 0; currentStation < numberOfStations; currentStation++)\n    {\n        for (int nearbyStation = std::max(0, currentStation - range); nearbyStation <= std::min(numberOfStations - 1, currentStation + range); nearbyStation++)\n        {\n            totalPower[nearbyStation] += stationPowers[currentStation];\n        }\n    }\n\n    int sumOfK = 0, minimumPower = std::numeric_limits<int>::max();\n    for (int currentIndex = range; currentIndex < numberOfStations - range; currentIndex++)\n    {\n        sumOfK += stationPowers[currentIndex];\n        minimumPower = std::min(minimumPower, totalPower[currentIndex]);\n    }\n\n    for (int j = 0, i = numberOfStations - 2 * range; j < 2 * range; j++, i--)\n    {\n        sumOfK -= stationPowers[i + range + 1];\n        minimumPower -= stationPowers[j];\n        minimumPower += sumOfK;\n        minimumPower += additionalPower;\n        minimumPower = std::min(minimumPower, totalPower[j]);\n    }\n\n    return minimumPower;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxPositiveNegativeCount(const vector<int> &numbers)\n{\n    int positiveCount= upper_bound(numbers.begin(), numbers.end(), -1) - numbers.begin();\n    int negativeCount= numbers.size() - positiveCount;\n    return max(positiveCount, negativeCount);\n}",
    "output": "#include <bits/stdc++.h>\nint MaxPositiveNegativeCount(const std::vector<int> &numbers)\n{\n    int positiveCount = std::upper_bound(numbers.begin(), numbers.end(), -1) - numbers.begin();\n    int negativeCount = numbers.size() - positiveCount;\n    return std::max(positiveCount, negativeCount);\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxScore(const vector<int> &numbers, int numberOfPicks)\n{\n    priority_queue<int> maxHeap(numbers.begin(), numbers.end());\n    int totalScore= 0;\n\n    for(int i= 0; i < numberOfPicks; i++)\n    {\n        int currentNumber= maxHeap.top();\n        maxHeap.pop();\n        totalScore+= currentNumber;\n        maxHeap.push(currentNumber / 3);\n    }\n\n    return totalScore;\n}",
    "output": "#include <bits/stdc++.h>\nint MaxScore(const std::vector<int> &numbers, int numberOfPicks)\n{\n    std::priority_queue<int> maxHeap(numbers.begin(), numbers.end());\n    int totalScore= 0;\n\n    for(int i= 0; i < numberOfPicks; i++)\n    {\n        int currentNumber= maxHeap.top();\n        maxHeap.pop();\n        totalScore+= currentNumber;\n        maxHeap.push(currentNumber / 3);\n    }\n\n    return totalScore;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool compare(const string &firstWord, const string &secondWord)\n{\n    array<int, 26> letterCountsFirst = {0}, letterCountsSecond = {0};\n    for (int i = 0; i < firstWord.size(); ++i)\n        letterCountsFirst[firstWord[i] - 'a']++;\n    for (int i = 0; i < secondWord.size(); ++i)\n        letterCountsSecond[secondWord[i] - 'a']++;\n    for (int index = 0; index < 26; ++index)\n    {\n        if (letterCountsFirst[index] && letterCountsSecond[index])\n            return true;\n    }\n    return false;\n}\n\nbool swapEqualDistinct(const string &firstWord, const string &secondWord)\n{\n    bool hasCommonLetter = compare(firstWord, secondWord);\n    return hasCommonLetter && firstWord.size() == secondWord.size();\n}",
    "output": "bool Compare(const std::string &firstWord, const std::string &secondWord)\n{\n    std::array<int, 26> letterCountsFirst = {0}, letterCountsSecond = {0};\n    for (int i = 0; i < firstWord.size(); ++i)\n        letterCountsFirst[firstWord[i] - 'a']++;\n    for (int i = 0; i < secondWord.size(); ++i)\n        letterCountsSecond[secondWord[i] - 'a']++;\n    for (int index = 0; index < 26; ++index)\n    {\n        if (letterCountsFirst[index] && letterCountsSecond[index])\n            return true;\n    }\n    return false;\n}\n\nbool SwapEqualDistinct(const std::string &firstWord, const std::string &secondWord)\n{\n    bool hasCommonLetter = Compare(firstWord, secondWord);\n    return hasCommonLetter && firstWord.size() == secondWord.size();\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint getLastMoment(int totalMoments, int numElements, vector<vector<int>> &elementTimes)\n{\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> leftQueue, rightQueue;\n    for(int index= 0; index < numElements; index++)\n    {\n        leftQueue.push({elementTimes[index][0] + elementTimes[index][2], index});\n    }\n\n    while(totalMoments)\n    {\n        while(!rightQueue.empty() && rightQueue.top().first <= leftQueue.top().first)\n        {\n            auto rightTopElement= rightQueue.top();\n            rightQueue.pop();\n            leftQueue.push({rightTopElement.first + elementTimes[rightTopElement.second][0] + elementTimes[rightTopElement.second][2], rightTopElement.second});\n        }\n        auto leftTopElement= leftQueue.top();\n        leftQueue.pop();\n        elementTimes[leftTopElement.second][2]+= elementTimes[leftTopElement.second][3] + elementTimes[leftTopElement.second][0] + elementTimes[leftTopElement.second][1];\n        rightQueue.push({leftTopElement.first + elementTimes[leftTopElement.second][1], leftTopElement.second});\n        totalMoments--;\n    }\n\n    int lastMoment= -1;\n    while(!rightQueue.empty())\n    {\n        lastMoment= max(lastMoment, elementTimes[rightQueue.top().second][2]);\n        rightQueue.pop();\n    }\n    return lastMoment;\n}",
    "output": "#include <bits/stdc++.h>\nint GetLastMoment(int totalMoments, int numElements, std::vector<std::vector<int>> &elementTimes)\n{\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> leftQueue, rightQueue;\n    for(int index= 0; index < numElements; index++)\n    {\n        leftQueue.push({elementTimes[index][0] + elementTimes[index][2], index});\n    }\n\n    while(totalMoments)\n    {\n        while(!rightQueue.empty() && rightQueue.top().first <= leftQueue.top().first)\n        {\n            auto rightTopElement= rightQueue.top();\n            rightQueue.pop();\n            leftQueue.push({rightTopElement.first + elementTimes[rightTopElement.second][0] + elementTimes[rightTopElement.second][2], rightTopElement.second});\n        }\n        auto leftTopElement= leftQueue.top();\n        leftQueue.pop();\n        elementTimes[leftTopElement.second][2]+= elementTimes[leftTopElement.second][3] + elementTimes[leftTopElement.second][0] + elementTimes[leftTopElement.second][1];\n        rightQueue.push({leftTopElement.first + elementTimes[leftTopElement.second][1], leftTopElement.second});\n        totalMoments--;\n    }\n\n    int lastMoment= -1;\n    while(!rightQueue.empty())\n    {\n        lastMoment= std::max(lastMoment, elementTimes[rightQueue.top().second][2]);\n        rightQueue.pop();\n    }\n    return lastMoment;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\n// for std::max\nusing namespace std;\n\nint countGoodStrings(int minLength, int maxLength, int oneGroupSize, int zeroGroupSize, int modulo = 1000000007)\n{\n    int maxCount = maxLength / oneGroupSize + maxLength / zeroGroupSize;\n\n    vector<long long> dynamicProgramming(maxCount + 1);\n    dynamicProgramming[0] = 1;\n\n    for (int index = 1; index <= maxCount; index++)\n        dynamicProgramming[index] = (dynamicProgramming[index - 1] * (index % oneGroupSize == 0 || index % zeroGroupSize == 0)) % modulo;\n\n    long long result = 0;\n    for (int index = 0; index <= maxCount; index++)\n    {\n        result = (result + dynamicProgramming[minLength / oneGroupSize + minLength / zeroGroupSize - index] - \n            (minLength - 1) / oneGroupSize - (minLength - 1) / zeroGroupSize + index < 0 ? 0\n            : dynamicProgramming[(minLength - 1) / oneGroupSize + (minLength - 1) / zeroGroupSize - index]) % modulo;\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nint CountGoodStrings(int minLength, int maxLength, int oneGroupSize, int zeroGroupSize, int modulo= 1000000007)\n{\n    int maxCount= maxLength / oneGroupSize + maxLength / zeroGroupSize;\n\n    std::vector<long long> dynamicProgramming(maxCount + 1);\n    dynamicProgramming[0]= 1;\n\n    for(int index= 1; index <= maxCount; index++)\n        dynamicProgramming[index]= (dynamicProgramming[index - 1] * (index % oneGroupSize == 0 || index % zeroGroupSize == 0)) % modulo;\n\n    long long result= 0;\n    for(int index= 0; index <= maxCount; index++)\n    {\n        result= (result + dynamicProgramming[minLength / oneGroupSize + minLength / zeroGroupSize - index] - (minLength - 1) / oneGroupSize - (minLength - 1) / zeroGroupSize + index < 0 ? 0\n                                                                                                                                                                                          : dynamicProgramming[(minLength - 1) / oneGroupSize + (minLength - 1) / zeroGroupSize - index]) %\n                modulo;\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> timeCrossingTheDoor(vector<int> &arrivalTimes, vector<int> &personState)\n{\n    int numberOfPersons= arrivalTimes.size();\n    vector<int> crossingTimes(numberOfPersons);\n    vector<int> lastSeenTimeAtDoor(2, -1);\n\n    for(int personIndex= 0, currentTime= 0; personIndex < numberOfPersons; ++personIndex, ++currentTime)\n    {\n        while(currentTime < arrivalTimes[personIndex])\n            currentTime++;\n\n        int direction= (lastSeenTimeAtDoor[1] != currentTime - 1) ? 1 : 0;\n\n        if(personState[personIndex] == direction)\n        {\n            lastSeenTimeAtDoor[personState[personIndex]]= currentTime;\n        }\n        else\n        {\n            while(personIndex + 1 < numberOfPersons && arrivalTimes[personIndex + 1] == currentTime && personState[personIndex + 1] != direction)\n                ++personIndex;\n\n            if(personIndex + 1 < numberOfPersons && arrivalTimes[personIndex + 1] == currentTime && personState[personIndex + 1] == direction)\n            {\n                lastSeenTimeAtDoor[personState[personIndex= personIndex + 1]]= currentTime;\n            }\n            else\n            {\n                currentTime--, personIndex--;\n            }\n        }\n        crossingTimes[personIndex]= lastSeenTimeAtDoor[personState[personIndex]];\n    }\n    return crossingTimes;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> TimeCrossingTheDoor(std::vector<int> &arrivalTimes, std::vector<int> &personState)\n{\n    int numberOfPersons = arrivalTimes.size();\n    std::vector<int> crossingTimes(numberOfPersons);\n    std::vector<int> lastSeenTimeAtDoor(2, -1);\n\n    for(int personIndex = 0, currentTime = 0; personIndex < numberOfPersons; ++personIndex, ++currentTime)\n    {\n        while(currentTime < arrivalTimes[personIndex])\n            currentTime++;\n\n        int direction = (lastSeenTimeAtDoor[1] != currentTime - 1) ? 1 : 0;\n\n        if(personState[personIndex] == direction)\n        {\n            lastSeenTimeAtDoor[personState[personIndex]] = currentTime;\n        }\n        else\n        {\n            while(personIndex + 1 < numberOfPersons && arrivalTimes[personIndex + 1] == currentTime && personState[personIndex + 1] != direction)\n                ++personIndex;\n\n            if(personIndex + 1 < numberOfPersons && arrivalTimes[personIndex + 1] == currentTime && personState[personIndex + 1] == direction)\n            {\n                lastSeenTimeAtDoor[personState[personIndex = personIndex + 1]] = currentTime;\n            }\n            else\n            {\n                currentTime--, personIndex--;\n            }\n        }\n        crossingTimes[personIndex] = lastSeenTimeAtDoor[personState[personIndex]];\n    }\n    return crossingTimes;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\n// For abs function\nusing namespace std;\n\nint differenceBetweenElementAndDigitSum(vector<int> &numbers)\n{\n    int totalElementSum = 0, totalDigitSum = 0;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int currentNumber = numbers[i];\n        totalElementSum += currentNumber;\n        int tempNumber = currentNumber; // Create a temporary variable to hold the current number\n        while (tempNumber > 0)\n        {\n            totalDigitSum += tempNumber % 10;\n            tempNumber /= 10;\n        }\n    }\n    return abs(totalElementSum - totalDigitSum);\n}",
    "output": "#include <bits/stdc++.h>\n// for abs\n\nint DifferenceBetweenElementAndDigitSum(std::vector<int> &numbers)\n{\n    int totalElementSum = 0, totalDigitSum = 0;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int currentNumber = numbers[i];\n        totalElementSum += currentNumber;\n        int tempNumber = currentNumber; // Create a temporary variable to hold the current number\n        while (tempNumber > 0)\n        {\n            totalDigitSum += tempNumber % 10;\n            tempNumber /= 10;\n        }\n    }\n    return std::abs(totalElementSum - totalDigitSum);\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> applyQueries(int matrixSize, vector<vector<int>> &queryList)\n{\n    vector<vector<int>> matrix(matrixSize, vector<int>(matrixSize, 0));\n\n    for (int i = 0; i < queryList.size(); ++i)\n    {\n        auto &query = queryList[i];\n        for (int row = query[0]; row <= query[2]; ++row)\n        {\n            for (int col = query[1]; col <= query[3]; ++col)\n            {\n                matrix[row][col]++;\n            }\n        }\n    }\n\n    return matrix;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> ApplyQueries(int matrixSize, std::vector<std::vector<int>> &queryList)\n{\n    std::vector<std::vector<int>> matrix(matrixSize, std::vector<int>(matrixSize, 0));\n\n    for (int i = 0; i < queryList.size(); ++i)\n    {\n        auto &query = queryList[i];\n        for (int row = query[0]; row <= query[2]; ++row)\n        {\n            for (int col = query[1]; col <= query[3]; ++col)\n            {\n                matrix[row][col]++;\n            }\n        }\n    }\n\n    return matrix;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countGoodSubarrays(vector<int> &numbers, int targetSum)\n{\n    unordered_map<int, int> prefixSumCount;\n    int totalGoodSubarrays = 0, currentPrefixSum = 0;\n\n    prefixSumCount[0] = 1;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int number = numbers[i];\n        currentPrefixSum += number - 1;\n        totalGoodSubarrays += prefixSumCount[currentPrefixSum - targetSum];\n        prefixSumCount[currentPrefixSum]++;\n    }\n\n    return totalGoodSubarrays;\n}",
    "output": "#include <bits/stdc++.h>\nint CountGoodSubarrays(std::vector<int> &numbers, int targetSum)\n{\n    std::unordered_map<int, int> prefixSumCount;\n    int totalGoodSubarrays = 0, currentPrefixSum = 0;\n\n    prefixSumCount[0] = 1;\n    for (int i = 0; i < numbers.size(); ++i)\n    {\n        int number = numbers[i];\n        currentPrefixSum += number - 1;\n        totalGoodSubarrays += prefixSumCount[currentPrefixSum - targetSum];\n        prefixSumCount[currentPrefixSum]++;\n    }\n\n    return totalGoodSubarrays;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adjacencyList;\nvector<int> nodePrices;\nvector<pair<vector<long long>, vector<long long>>> dynamicProgramming;\n\nvoid depthFirstSearch(int currentNode, int parentNode)\n{\n    dynamicProgramming[currentNode].first[0] = nodePrices[currentNode];\n    dynamicProgramming[currentNode].first[1] = 0;\n    dynamicProgramming[currentNode].second[0] = nodePrices[currentNode];\n    dynamicProgramming[currentNode].second[1] = 0;\n\n    for (int i = 0; i < adjacencyList[currentNode].size(); ++i)\n    {\n        int neighborNode = adjacencyList[currentNode][i];\n        if (neighborNode == parentNode)\n            continue;\n        depthFirstSearch(neighborNode, currentNode);\n        dynamicProgramming[currentNode].first.push_back(dynamicProgramming[neighborNode].first[0] + nodePrices[currentNode] - dynamicProgramming[neighborNode].second[0]);\n        dynamicProgramming[currentNode].first.push_back(dynamicProgramming[neighborNode].first[1]);\n        dynamicProgramming[currentNode].second.push_back(dynamicProgramming[neighborNode].second[0] + nodePrices[currentNode] - dynamicProgramming[neighborNode].first[0]);\n        dynamicProgramming[currentNode].second.push_back(dynamicProgramming[neighborNode].second[1]);\n\n        sort(dynamicProgramming[currentNode].first.begin(), dynamicProgramming[currentNode].first.end());\n        sort(dynamicProgramming[currentNode].second.begin(), dynamicProgramming[currentNode].second.end());\n    }\n}\n\nint getMaxCost(int numberOfNodes, vector<vector<int>> &edges, vector<int> &priceList)\n{\n    adjacencyList.resize(numberOfNodes);\n    nodePrices = priceList;\n    dynamicProgramming.resize(numberOfNodes, pair<vector<long long>, vector<long long>>(vector<long long>(2), vector<long long>(2)));\n\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        vector<int> &edge = edges[i];\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    depthFirstSearch(0, -1);\n\n    long long maximumCost = 0;\n    for (int i = 0; i < numberOfNodes; ++i)\n    {\n        maximumCost = max(maximumCost, dynamicProgramming[i].first.back() - dynamicProgramming[i].second.back());\n    }\n\n    return maximumCost;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> adjacencyList;\nstd::vector<int> nodePrices;\nstd::vector<std::pair<std::vector<long long>, std::vector<long long>>> dynamicProgramming;\n\nvoid DepthFirstSearch(int currentNode, int parentNode)\n{\n    dynamicProgramming[currentNode].first[0] = nodePrices[currentNode];\n    dynamicProgramming[currentNode].first[1] = 0;\n    dynamicProgramming[currentNode].second[0] = nodePrices[currentNode];\n    dynamicProgramming[currentNode].second[1] = 0;\n\n    for (int i = 0; i < adjacencyList[currentNode].size(); ++i)  // Modified to traditional for-loop\n    {\n        int neighborNode = adjacencyList[currentNode][i];\n        if (neighborNode == parentNode)\n            continue;\n        DepthFirstSearch(neighborNode, currentNode);\n        dynamicProgramming[currentNode].first.push_back(dynamicProgramming[neighborNode].first[0] + nodePrices[currentNode] - dynamicProgramming[neighborNode].second[0]);\n        dynamicProgramming[currentNode].first.push_back(dynamicProgramming[neighborNode].first[1]);\n        dynamicProgramming[currentNode].second.push_back(dynamicProgramming[neighborNode].second[0] + nodePrices[currentNode] - dynamicProgramming[neighborNode].first[0]);\n        dynamicProgramming[currentNode].second.push_back(dynamicProgramming[neighborNode].second[1]);\n\n        std::sort(dynamicProgramming[currentNode].first.begin(), dynamicProgramming[currentNode].first.end());\n        std::sort(dynamicProgramming[currentNode].second.begin(), dynamicProgramming[currentNode].second.end());\n    }\n}\n\nint GetMaxCost(int numberOfNodes, std::vector<std::vector<int>> &edges, std::vector<int> &priceList)\n{\n    adjacencyList.resize(numberOfNodes);\n    nodePrices = priceList;\n    dynamicProgramming.resize(numberOfNodes, std::pair<std::vector<long long>, std::vector<long long>>(std::vector<long long>(2), std::vector<long long>(2)));\n\n    for (int i = 0; i < edges.size(); ++i)  // Modified to traditional for-loop\n    {\n        std::vector<int> &edge = edges[i];\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    DepthFirstSearch(0, -1);\n\n    long long maximumCost = 0;\n    for (int i = 0; i < numberOfNodes; ++i)\n    {\n        maximumCost = std::max(maximumCost, dynamicProgramming[i].first.back() - dynamicProgramming[i].second.back());\n    }\n\n    return maximumCost;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countOfGoodSubsequences(string inputString)\n{\n    vector<int> characterCount(26, 0);\n    long totalCount = 0;\n    const int modulo = 1000000007;\n\n    for (char currentChar : inputString)\n    {\n        characterCount[currentChar - 'a']++;\n    }\n\n    for (int i = 0; i < characterCount.size(); ++i)\n    {\n        int occurrence = characterCount[i];\n        totalCount = (totalCount + (1L << occurrence) - 1) % modulo;\n    }\n\n    return totalCount;\n}",
    "output": "#include <bits/stdc++.h>\nint CountOfGoodSubsequences(std::string inputString)\n{\n    std::vector<int> characterCount(26, 0);\n    long totalCount = 0;\n    const int modulo = 1000000007;\n\n    for (char currentChar : inputString)\n    {\n        characterCount[currentChar - 'a']++;\n    }\n\n    for (int i = 0; i < characterCount.size(); ++i)\n    {\n        int occurrence = characterCount[i];\n        totalCount = (totalCount + (1L << occurrence) - 1) % modulo;\n    }\n\n    return totalCount;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findMinimumCommonNumber(vector<int> &firstArray, vector<int> &secondArray)\n{\n    int firstIndex= 0, secondIndex= 0;\n    while(firstIndex < firstArray.size() && secondIndex < secondArray.size())\n    {\n        if(firstArray[firstIndex] == secondArray[secondIndex])\n        {\n            return firstArray[firstIndex];\n        }\n        else if(firstArray[firstIndex] < secondArray[secondIndex])\n        {\n            firstIndex++;\n        }\n        else\n        {\n            secondIndex++;\n        }\n    }\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint FindMinimumCommonNumber(std::vector<int> &firstArray, std::vector<int> &secondArray)\n{\n    int firstIndex= 0, secondIndex= 0;\n    while(firstIndex < firstArray.size() && secondIndex < secondArray.size())\n    {\n        if(firstArray[firstIndex] == secondArray[secondIndex])\n        {\n            return firstArray[firstIndex];\n        }\n        else if(firstArray[firstIndex] < secondArray[secondIndex])\n        {\n            firstIndex++;\n        }\n        else\n        {\n            secondIndex++;\n        }\n    }\n    return -1;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\n// For abs function\nusing namespace std;\n\nint minChanges(vector<int> &firstArray, vector<int> &secondArray, int differenceFactor)\n{\n    int arraySize= firstArray.size();\n    int totalOperations= 0;\n    for(int index= 0; index < arraySize; ++index)\n    {\n        int difference= abs(firstArray[index] - secondArray[index]);\n        if(difference % differenceFactor != 0)\n            return -1;\n        totalOperations+= difference / differenceFactor;\n    }\n    return totalOperations;\n}",
    "output": "#include <bits/stdc++.h>\nint MinChanges(std::vector<int> &firstArray, std::vector<int> &secondArray, int differenceFactor)\n{\n    int arraySize= firstArray.size();\n    int totalOperations= 0;\n    for(int index= 0; index < arraySize; ++index)\n    {\n        int difference= std::abs(firstArray[index] - secondArray[index]);\n        if(difference % differenceFactor != 0)\n            return -1;\n        totalOperations+= difference / differenceFactor;\n    }\n    return totalOperations;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxScore(vector<int> &firstArray, vector<int> &secondArray, int maxElements)\n{\n    int arraySize = firstArray.size();\n    int maximumResult = 0;\n    int sumFirstArray = 0, minimumSecondArray = secondArray[0];\n    for(int startIndex = 0, endIndex = 0; endIndex < arraySize; ++endIndex)\n    {\n        sumFirstArray += firstArray[endIndex];\n        minimumSecondArray = min(minimumSecondArray, secondArray[endIndex]);\n        if(endIndex - startIndex + 1 > maxElements)\n            sumFirstArray -= firstArray[startIndex++];\n        if(endIndex + 1 >= maxElements)\n            maximumResult = max(maximumResult, sumFirstArray * minimumSecondArray);\n    }\n    return maximumResult;\n}",
    "output": "#include <bits/stdc++.h>\nint MaxScore(std::vector<int> &firstArray, std::vector<int> &secondArray, int maxElements)\n{\n    int arraySize= firstArray.size();\n    int maximumResult= 0;\n    int sumFirstArray= 0, minimumSecondArray= secondArray[0];\n    for(int startIndex= 0, endIndex= 0; endIndex < arraySize; ++endIndex)\n    {\n        sumFirstArray+= firstArray[endIndex];\n        minimumSecondArray= std::min(minimumSecondArray, secondArray[endIndex]);\n        if(endIndex - startIndex + 1 > maxElements)\n            sumFirstArray-= firstArray[startIndex++];\n        if(endIndex + 1 >= maxElements)\n            maximumResult= std::max(maximumResult, sumFirstArray * minimumSecondArray);\n    }\n    return maximumResult;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "bool canReach(int targetX, int targetY)\n{\n    while(targetX > 1 && targetY > 1)\n    {\n        if(targetX < targetY)\n            swap(targetX, targetY);\n        targetX-= targetY;\n    }\n    return targetX == 1 || targetY == 1;\n}",
    "output": "bool CanReach(int targetX, int targetY)\n{\n    while(targetX > 1 && targetY > 1)\n    {\n        if(targetX < targetY)\n            swap(targetX, targetY);\n        targetX-= targetY;\n    }\n    return targetX == 1 || targetY == 1;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "int sumOfDigits(int inputNumber)\n{\n    int digitSum= 0;\n    bool isPositive= true;\n\n    while(inputNumber > 0)\n    {\n        int currentDigit= inputNumber % 10;\n        inputNumber/= 10;\n\n        if(isPositive)\n        {\n            digitSum+= currentDigit;\n        }\n        else\n        {\n            digitSum-= currentDigit;\n        }\n\n        isPositive= !isPositive;\n    }\n\n    return digitSum;\n}",
    "output": "int SumOfDigits(int inputNumber)\n{\n    int digitSum= 0;\n    bool isPositive= true;\n\n    while(inputNumber > 0)\n    {\n        int currentDigit= inputNumber % 10;\n        inputNumber/= 10;\n\n        if(isPositive)\n        {\n            digitSum+= currentDigit;\n        }\n        else\n        {\n            digitSum-= currentDigit;\n        }\n\n        isPositive= !isPositive;\n    }\n\n    return digitSum;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> sortStudents(vector<vector<int>> &studentScores, int scoreIndex)\n{\n    sort(studentScores.begin(), studentScores.end(), [scoreIndex](const vector<int> &firstStudent, const vector<int> &secondStudent)\n         { return firstStudent[scoreIndex] > secondStudent[scoreIndex]; });\n    return studentScores;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> SortStudents(std::vector<std::vector<int>> &studentScores, int scoreIndex)\n{\n    std::sort(studentScores.begin(), studentScores.end(), [scoreIndex](const std::vector<int> &firstStudent, const std::vector<int> &secondStudent)\n         { return firstStudent[scoreIndex] > secondStudent[scoreIndex]; });\n    return studentScores;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canMakeEqual(string sourceString, string targetString)\n{\n    int sourceCountOnes= count(sourceString.begin(), sourceString.end(), '1');\n    int targetCountOnes= count(targetString.begin(), targetString.end(), '1');\n    return sourceCountOnes >= targetCountOnes;\n}",
    "output": "#include <bits/stdc++.h>\nbool CanMakeEqual(std::string sourceString, std::string targetString)\n{\n    int sourceCountOnes= std::count(sourceString.begin(), sourceString.end(), '1');\n    int targetCountOnes= std::count(targetString.begin(), targetString.end(), '1');\n    return sourceCountOnes >= targetCountOnes;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\n// For std::min\nusing namespace std;\n\nint getCost(int endIndex, vector<int> &frequencyCount, vector<int> &numberList)\n{\n    return frequencyCount[numberList[endIndex]] == 1 ? 1 : 0;\n}\n\nint minCost(vector<int> &numberList, int cost)\n{\n    int listSize= numberList.size(), infinity= 1e9 + 7;\n    vector<int> frequencyCount(1001, 0), dynamicProgramming(listSize + 1, 0); // frequencyCount for frequency, dynamicProgramming for dynamic programming\n\n    for(int startIndex= 0, endIndex= 0; endIndex < listSize; ++endIndex)\n    {\n        ++frequencyCount[numberList[endIndex]];\n\n        if(frequencyCount[numberList[endIndex]] == 2) // if occurrence is 2, change dynamicProgramming\n            dynamicProgramming[endIndex + 1]= dynamicProgramming[startIndex] + cost + (endIndex - startIndex + 1);\n        else if(frequencyCount[numberList[endIndex]] > 2) // if occurrence is more than 2\n            dynamicProgramming[endIndex + 1]= min(dynamicProgramming[endIndex], dynamicProgramming[endIndex - 1] - (frequencyCount[numberList[endIndex]] - 2));\n        else\n            dynamicProgramming[endIndex + 1]= dynamicProgramming[endIndex] + getCost(endIndex, frequencyCount, numberList) + cost;\n\n        while(startIndex < endIndex + 1 && frequencyCount[numberList[startIndex]] >= 2)\n        {\n            --frequencyCount[numberList[startIndex]];\n            ++startIndex; // update first pointer startIndex when numberList[startIndex] has occurred more than once\n        }\n    }\n\n    return dynamicProgramming[listSize];\n}",
    "output": "#include <bits/stdc++.h>\nint GetCost(int endIndex, std::vector<int> &frequencyCount, std::vector<int> &numberList)\n{\n    return frequencyCount[numberList[endIndex]] == 1 ? 1 : 0;\n}\n\nint MinCost(std::vector<int> &numberList, int cost)\n{\n    int listSize= numberList.size(), infinity= 1e9 + 7;\n    std::vector<int> frequencyCount(1001, 0), dynamicProgramming(listSize + 1, 0); // frequencyCount for frequency, dynamicProgramming for dynamic programming\n\n    for(int startIndex= 0, endIndex= 0; endIndex < listSize; ++endIndex)\n    {\n        ++frequencyCount[numberList[endIndex]];\n\n        if(frequencyCount[numberList[endIndex]] == 2) // if occurrence is 2, change dynamicProgramming\n            dynamicProgramming[endIndex + 1]= dynamicProgramming[startIndex] + cost + (endIndex - startIndex + 1);\n        else if(frequencyCount[numberList[endIndex]] > 2) // if occurrence is more than 2\n            dynamicProgramming[endIndex + 1]= std::min(dynamicProgramming[endIndex], dynamicProgramming[endIndex - 1] - (frequencyCount[numberList[endIndex]] - 2));\n        else\n            dynamicProgramming[endIndex + 1]= dynamicProgramming[endIndex] + GetCost(endIndex, frequencyCount, numberList) + cost;\n\n        while(startIndex < endIndex + 1 && frequencyCount[numberList[startIndex]] >= 2)\n        {\n            --frequencyCount[numberList[startIndex]];\n            ++startIndex; // update first pointer startIndex when numberList[startIndex] has occurred more than once\n        }\n    }\n\n    return dynamicProgramming[listSize];\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble maxValue(vector<vector<int>> &items, int capacity)\n{\n    sort(items.begin(), items.end(), [](const vector<int> &a, const vector<int> &b)\n         { return (double)a[0] / a[1] > (double)b[0] / b[1]; });\n\n    double maxTotalPrice = 0;\n    for (int i = 0; i < items.size(); ++i)\n    {\n        const auto &item = items[i];\n        if (capacity >= item[1])\n        {\n            capacity -= item[1];\n            maxTotalPrice += item[0];\n        }\n        else\n        {\n            maxTotalPrice += (double)item[0] * capacity / item[1];\n            break;\n        }\n    }\n\n    return maxTotalPrice;\n}",
    "output": "#include <bits/stdc++.h>\ndouble MaxValue(std::vector<std::vector<int>> &items, int capacity)\n{\n    std::sort(items.begin(), items.end(), [](const std::vector<int> &a, const std::vector<int> &b)\n         { return (double)a[0] / a[1] > (double)b[0] / b[1]; });\n\n    double maxTotalPrice = 0;\n    for (int i = 0; i < items.size(); ++i)\n    {\n        const auto &item = items[i];\n        if (capacity >= item[1])\n        {\n            capacity -= item[1];\n            maxTotalPrice += item[0];\n        }\n        else\n        {\n            maxTotalPrice += (double)item[0] * capacity / item[1];\n            break;\n        }\n    }\n\n    return maxTotalPrice;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "int distinctCount(int totalNumbers)\n{\n    return totalNumbers - 1;\n}",
    "output": "int DistinctCount(int totalNumbers)\n{\n    return totalNumbers - 1;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod= 1e9 + 7;\n\nint waysToCollide(int numberOfObjects)\n{\n    int powerOfTwo= 1;\n    for(int index= 0; index < numberOfObjects; index++)\n    {\n        powerOfTwo= (2LL * powerOfTwo) % mod;\n    }\n    return (powerOfTwo - numberOfObjects - 1 + mod) % mod;\n}",
    "output": "#include <bits/stdc++.h>\nconst int mod = 1e9 + 7;\n\nint WaysToCollide(int numberOfObjects)\n{\n    int powerOfTwo = 1;\n    for(int index = 0; index < numberOfObjects; index++)\n    {\n        powerOfTwo = (2LL * powerOfTwo) % mod;\n    }\n    return (powerOfTwo - numberOfObjects - 1 + mod) % mod;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maximizeScore(vector<int> &weightValues, int numberOfGroups)\n{\n    int totalWeights= weightValues.size();\n    vector<int> prefixSum(totalWeights + 1);\n    partial_sum(weightValues.begin(), weightValues.end(), prefixSum.begin() + 1);\n    vector<vector<int>> dynamicProgramming(totalWeights, vector<int>(numberOfGroups + 1));\n\n    for(int currentIndex= 0; currentIndex < totalWeights; currentIndex++)\n    {\n        for(int groupIndex= 1; groupIndex <= numberOfGroups; groupIndex++)\n        {\n            dynamicProgramming[currentIndex][groupIndex]= -1e9;\n        }\n    }\n\n    for(int currentIndex= 0; currentIndex < totalWeights; currentIndex++)\n    {\n        dynamicProgramming[currentIndex][1]= prefixSum[currentIndex + 1];\n        if(currentIndex > 0)\n        {\n            dynamicProgramming[currentIndex][currentIndex + 1]= prefixSum[currentIndex + 1] - prefixSum[1];\n        }\n        for(int groupIndex= 2; groupIndex <= min<int>(currentIndex + 1, numberOfGroups); groupIndex++)\n        {\n            for(int previousGroupSize= 1; previousGroupSize <= currentIndex - groupIndex + 2; previousGroupSize++)\n            {\n                dynamicProgramming[currentIndex][groupIndex]= max(dynamicProgramming[currentIndex][groupIndex],\n                                                                   dynamicProgramming[currentIndex - previousGroupSize][groupIndex - 1] + weightValues[currentIndex] + weightValues[currentIndex - previousGroupSize]);\n            }\n        }\n    }\n\n    return dynamicProgramming[totalWeights - 1][numberOfGroups] - dynamicProgramming[totalWeights - 1][1];\n}",
    "output": "#include <bits/stdc++.h>\nint MaximizeScore(std::vector<int> &weightValues, int numberOfGroups)\n{\n    int totalWeights= weightValues.size();\n    std::vector<int> prefixSum(totalWeights + 1);\n    std::partial_sum(weightValues.begin(), weightValues.end(), prefixSum.begin() + 1);\n    std::vector<std::vector<int>> dynamicProgramming(totalWeights, std::vector<int>(numberOfGroups + 1));\n\n    for(int currentIndex= 0; currentIndex < totalWeights; currentIndex++)\n    {\n        for(int groupIndex= 1; groupIndex <= numberOfGroups; groupIndex++)\n        {\n            dynamicProgramming[currentIndex][groupIndex]= -1e9;\n        }\n    }\n\n    for(int currentIndex= 0; currentIndex < totalWeights; currentIndex++)\n    {\n        dynamicProgramming[currentIndex][1]= prefixSum[currentIndex + 1];\n        if(currentIndex > 0)\n        {\n            dynamicProgramming[currentIndex][currentIndex + 1]= prefixSum[currentIndex + 1] - prefixSum[1];\n        }\n        for(int groupIndex= 2; groupIndex <= std::min<int>(currentIndex + 1, numberOfGroups); groupIndex++)\n        {\n            for(int previousGroupSize= 1; previousGroupSize <= currentIndex - groupIndex + 2; previousGroupSize++)\n            {\n                dynamicProgramming[currentIndex][groupIndex]= std::max(dynamicProgramming[currentIndex][groupIndex],\n                                                                       dynamicProgramming[currentIndex - previousGroupSize][groupIndex - 1] + weightValues[currentIndex] + weightValues[currentIndex - previousGroupSize]);\n            }\n        }\n    }\n\n    return dynamicProgramming[totalWeights - 1][numberOfGroups] - dynamicProgramming[totalWeights - 1][1];\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countIncreasingQuadruplets(vector<int> &numberList)\n{\n    int listSize= numberList.size(), quadrupletCount= 0;\n    for(int firstIndex= 0; firstIndex < listSize - 3; firstIndex++)\n    {\n        for(int secondIndex= firstIndex + 1; secondIndex < listSize - 2; secondIndex++)\n        {\n            for(int thirdIndex= secondIndex + 1; thirdIndex < listSize - 1; thirdIndex++)\n            {\n                if(numberList[firstIndex] < numberList[thirdIndex] && numberList[thirdIndex] < numberList[secondIndex])\n                {\n                    for(int fourthIndex= thirdIndex + 1; fourthIndex < listSize; fourthIndex++)\n                    {\n                        if(numberList[secondIndex] < numberList[fourthIndex])\n                        {\n                            quadrupletCount++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return quadrupletCount;\n}",
    "output": "#include <bits/stdc++.h>\nint CountIncreasingQuadruplets(std::vector<int> &numberList)\n{\n    int listSize= numberList.size(), quadrupletCount= 0;\n    for(int firstIndex= 0; firstIndex < listSize - 3; firstIndex++)\n    {\n        for(int secondIndex= firstIndex + 1; secondIndex < listSize - 2; secondIndex++)\n        {\n            for(int thirdIndex= secondIndex + 1; thirdIndex < listSize - 1; thirdIndex++)\n            {\n                if(numberList[firstIndex] < numberList[thirdIndex] && numberList[thirdIndex] < numberList[secondIndex])\n                {\n                    for(int fourthIndex= thirdIndex + 1; fourthIndex < listSize; fourthIndex++)\n                    {\n                        if(numberList[secondIndex] < numberList[fourthIndex])\n                        {\n                            quadrupletCount++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return quadrupletCount;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> separateDigits(const vector<int> &inputNumbers)\n{\n    vector<int> resultDigits;\n    for (int i = 0; i < inputNumbers.size(); ++i)\n    {\n        int currentNumber = inputNumbers[i];\n        vector<int> extractedDigits;\n        while (currentNumber)\n        {\n            extractedDigits.insert(extractedDigits.begin(), currentNumber % 10);\n            currentNumber /= 10;\n        }\n        resultDigits.insert(resultDigits.end(), extractedDigits.begin(), extractedDigits.end());\n    }\n    return resultDigits;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> SeparateDigits(const std::vector<int> &inputNumbers)\n{\n    std::vector<int> resultDigits;\n    for (size_t i = 0; i < inputNumbers.size(); ++i)\n    {\n        int currentNumber = inputNumbers[i];\n        std::vector<int> extractedDigits;\n        while (currentNumber)\n        {\n            extractedDigits.insert(extractedDigits.begin(), currentNumber % 10);\n            currentNumber /= 10;\n        }\n        resultDigits.insert(resultDigits.end(), extractedDigits.begin(), extractedDigits.end());\n    }\n    return resultDigits;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxChosenIntegers(vector<int> &bannedIntegers, int totalIntegers, int maxSum)\n{\n    unordered_set<int> bannedSet(bannedIntegers.begin(), bannedIntegers.end());\n    int chosenCount= 0, currentSum= 0;\n    for(int integer= totalIntegers; integer >= 1 && maxSum - currentSum >= integer; --integer)\n    {\n        if(bannedSet.find(integer) == bannedSet.end())\n        {\n            currentSum+= integer;\n            ++chosenCount;\n        }\n    }\n    return chosenCount;\n}",
    "output": "#include <bits/stdc++.h>\nint MaxChosenIntegers(std::vector<int> &bannedIntegers, int totalIntegers, int maxSum)\n{\n    std::unordered_set<int> bannedSet(bannedIntegers.begin(), bannedIntegers.end());\n    int chosenCount= 0, currentSum= 0;\n    for(int integer= totalIntegers; integer >= 1 && maxSum - currentSum >= integer; --integer)\n    {\n        if(bannedSet.find(integer) == bannedSet.end())\n        {\n            currentSum+= integer;\n            ++chosenCount;\n        }\n    }\n    return chosenCount;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxPrizes(vector<int> &prizePositions, int maxDistance)\n{\n    int totalPositions= prizePositions.size();\n    int maximumPrizes= 0;\n    for(int currentIndex= 0; currentIndex < totalPositions; ++currentIndex)\n    {\n        int leftSegmentEnd= prizePositions[currentIndex] + maxDistance;\n        int rightSegmentStart= upper_bound(prizePositions.begin(), prizePositions.end(), leftSegmentEnd) - prizePositions.begin();\n        int rightSegmentEnd= prizePositions[rightSegmentStart] + maxDistance;\n        maximumPrizes= max(maximumPrizes, int(upper_bound(prizePositions.begin(), prizePositions.end(), rightSegmentEnd) - lower_bound(prizePositions.begin(), prizePositions.end(), prizePositions[currentIndex])));\n    }\n    return maximumPrizes;\n}",
    "output": "#include <bits/stdc++.h>\nint MaxPrizes(std::vector<int> &prizePositions, int maxDistance)\n{\n    int totalPositions= prizePositions.size();\n    int maximumPrizes= 0;\n    for(int currentIndex= 0; currentIndex < totalPositions; ++currentIndex)\n    {\n        int leftSegmentEnd= prizePositions[currentIndex] + maxDistance;\n        int rightSegmentStart= std::upper_bound(prizePositions.begin(), prizePositions.end(), leftSegmentEnd) - prizePositions.begin();\n        int rightSegmentEnd= prizePositions[rightSegmentStart] + maxDistance;\n        maximumPrizes= std::max(maximumPrizes, int(std::upper_bound(prizePositions.begin(), prizePositions.end(), rightSegmentEnd) - std::lower_bound(prizePositions.begin(), prizePositions.end(), prizePositions[currentIndex])));\n    }\n    return maximumPrizes;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canReach(vector<vector<int>> &grid, int currentRow, int currentCol)\n{\n    if(currentRow < 0 || currentCol < 0 || currentRow >= grid.size() || currentCol >= grid[0].size() || grid[currentRow][currentCol] == 0)\n        return false;\n\n    if(currentRow == grid.size() - 1 && currentCol == grid[0].size() - 1)\n        return true;\n\n    grid[currentRow][currentCol]= 0;\n\n    return canReach(grid, currentRow + 1, currentCol) || canReach(grid, currentRow, currentCol + 1);\n}\n\nbool canDisconnect(vector<vector<int>> &grid)\n{\n    int reachableCount= 0;\n\n    for(int currentRow= 1; currentRow < grid.size(); currentRow++)\n    {\n        for(int currentCol= 1; currentCol < grid[0].size(); currentCol++)\n        {\n            if(grid[currentRow][currentCol] == 1 && (canReach(grid, currentRow - 1, currentCol) || canReach(grid, currentRow, currentCol - 1)))\n            {\n                reachableCount++;\n                if(reachableCount > 1)\n                    return true;\n            }\n        }\n    }\n\n    return reachableCount <= 1;\n}",
    "output": "#include <bits/stdc++.h>\nbool CanReach(std::vector<std::vector<int>> &grid, int currentRow, int currentCol)\n{\n    if(currentRow < 0 || currentCol < 0 || currentRow >= grid.size() || currentCol >= grid[0].size() || grid[currentRow][currentCol] == 0)\n        return false;\n\n    if(currentRow == grid.size() - 1 && currentCol == grid[0].size() - 1)\n        return true;\n\n    grid[currentRow][currentCol]= 0;\n\n    return CanReach(grid, currentRow + 1, currentCol) || CanReach(grid, currentRow, currentCol + 1);\n}\n\nbool CanDisconnect(std::vector<std::vector<int>> &grid)\n{\n    int reachableCount= 0;\n\n    for(int currentRow= 1; currentRow < grid.size(); currentRow++)\n    {\n        for(int currentCol= 1; currentCol < grid[0].size(); currentCol++)\n        {\n            if(grid[currentRow][currentCol] == 1 && (CanReach(grid, currentRow - 1, currentCol) || CanReach(grid, currentRow, currentCol - 1)))\n            {\n                reachableCount++;\n                if(reachableCount > 1)\n                    return true;\n            }\n        }\n    }\n\n    return reachableCount <= 1;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxChosenIntegers(vector<int> &bannedIntegers, int totalIntegers, long long maxAllowedSum)\n{\n    unordered_set<int> bannedSet(bannedIntegers.begin(), bannedIntegers.end());\n    int countChosenIntegers= 0;\n    long long currentChosenSum= 0;\n\n    for(int i= totalIntegers; i > 0 && currentChosenSum < maxAllowedSum; --i)\n    {\n        if(bannedSet.find(i) == bannedSet.end())\n        {\n            if(currentChosenSum + i <= maxAllowedSum)\n            {\n                currentChosenSum+= i;\n                countChosenIntegers++;\n            }\n            else\n            {\n                break;\n            }\n        }\n    }\n\n    return countChosenIntegers;\n}",
    "output": "#include <bits/stdc++.h>\nint MaxChosenIntegers(std::vector<int> &bannedIntegers, int totalIntegers, long long maxAllowedSum)\n{\n    std::unordered_set<int> bannedSet(bannedIntegers.begin(), bannedIntegers.end());\n    int countChosenIntegers= 0;\n    long long currentChosenSum= 0;\n\n    for(int i= totalIntegers; i > 0 && currentChosenSum < maxAllowedSum; --i)\n    {\n        if(bannedSet.find(i) == bannedSet.end())\n        {\n            if(currentChosenSum + i <= maxAllowedSum)\n            {\n                currentChosenSum+= i;\n                countChosenIntegers++;\n            }\n            else\n            {\n                break;\n            }\n        }\n    }\n\n    return countChosenIntegers;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint giftsRemaining(vector<int> &giftValues, int numberOfIterations)\n{\n    for(int iteration = 0; iteration < numberOfIterations; iteration++)\n    {\n        sort(giftValues.begin(), giftValues.end());\n        int maxIndex = giftValues.size() - 1;\n        giftValues[maxIndex] -= static_cast<int>(sqrt(giftValues[maxIndex]));\n    }\n    int totalRemainingGifts = 0;\n    for(int j = 0; j < giftValues.size(); j++)\n        totalRemainingGifts += giftValues[j];\n    return totalRemainingGifts;\n}",
    "output": "#include <bits/stdc++.h>\nint GiftsRemaining(std::vector<int> &giftValues, int numberOfIterations)\n{\n    for(int iteration = 0; iteration < numberOfIterations; iteration++)\n    {\n        std::sort(giftValues.begin(), giftValues.end());\n        int maxIndex = giftValues.size() - 1;\n        giftValues[maxIndex] -= static_cast<int>(sqrt(giftValues[maxIndex]));\n    }\n    int totalRemainingGifts = 0;\n    for(int i = 0; i < giftValues.size(); i++)\n        totalRemainingGifts += giftValues[i];\n    return totalRemainingGifts;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isVowel(char character)\n{\n    return character == 'a' || character == 'e' || character == 'i' || character == 'o' || character == 'u';\n}\n\nvector<int> countVowelStrings(vector<string> &wordList, vector<vector<int>> &queryRanges)\n{\n    vector<int> result;\n    for (int i = 0; i < queryRanges.size(); ++i)\n    {\n        auto &query = queryRanges[i];\n        int vowelStringCount = 0;\n        for (int index = query[0]; index <= query[1]; index++)\n        {\n            if (isVowel(wordList[index].front()) && isVowel(wordList[index].back()))\n            {\n                vowelStringCount++;\n            }\n        }\n        result.push_back(vowelStringCount);\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nbool IsVowel(char character)\n{\n    return character == 'a' || character == 'e' || character == 'i' || character == 'o' || character == 'u';\n}\n\nstd::vector<int> CountVowelStrings(std::vector<std::string> &wordList, std::vector<std::vector<int>> &queryRanges)\n{\n    std::vector<int> result;\n    for (int i = 0; i < queryRanges.size(); ++i)\n    {\n        auto &query = queryRanges[i];\n        int vowelStringCount = 0;\n        for (int index = query[0]; index <= query[1]; index++)\n        {\n            if (IsVowel(wordList[index].front()) && IsVowel(wordList[index].back()))\n            {\n                vowelStringCount++;\n            }\n        }\n        result.push_back(vowelStringCount);\n    }\n    return result;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findMinimumCapability(vector<int> &numberList, int requiredCount)\n{\n    int size= numberList.size(), left= 1, right= 1e9;\n    while(left < right)\n    {\n        int mid= left + (right - left) / 2, index= 0, count= 0;\n        for(int j= 0; j < size; ++j)\n        {\n            if(numberList[j] <= mid)\n            {\n                ++count;\n                index= j + 2;\n                while(index + 1 < size && (index == j + 1 || numberList[index] > mid))\n                    ++index;\n            }\n        }\n        if(count < requiredCount)\n            left= mid + 1;\n        else\n            right= mid;\n    }\n    return left;\n}",
    "output": "#include <bits/stdc++.h>\nint FindMinimumCapability(std::vector<int> &numberList, int requiredCount)\n{\n    int size= numberList.size(), left= 1, right= 1e9;\n    while(left < right)\n    {\n        int mid= left + (right - left) / 2, index= 0, count= 0;\n        for(int j= 0; j < size; ++j)\n        {\n            if(numberList[j] <= mid)\n            {\n                ++count;\n                index= j + 2;\n                while(index + 1 < size && (index == j + 1 || numberList[index] > mid))\n                    ++index;\n            }\n        }\n        if(count < requiredCount)\n            left= mid + 1;\n        else\n            right= mid;\n    }\n    return left;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minCostToEqualBaskets(vector<int> &basket1, vector<int> &basket2)\n{\n    unordered_map<int, int> differenceCount;\n    for (int index = 0; index < basket1.size(); index++)\n    {\n        differenceCount[basket1[index] - basket2[index]]++;\n    }\n\n    int minimumCost = INT_MAX, currentCost = 0;\n    for (auto it = differenceCount.begin(); it != differenceCount.end(); ++it) // traditional for loop\n    {\n        const auto &entry = *it;\n        if (entry.second == differenceCount[-entry.first])\n        {\n            currentCost = 0;\n            for (int index = 0; index < basket1.size(); index++)\n            {\n                if (basket1[index] - basket2[index] == entry.first)\n                {\n                    currentCost += min(basket1[index], basket2[index]);\n                }\n            }\n            minimumCost = min(minimumCost, currentCost);\n        }\n    }\n\n    return minimumCost == INT_MAX ? -1 : minimumCost / 2;\n}",
    "output": "#include <bits/stdc++.h>\nint MinCostToEqualBaskets(std::vector<int> &basket1, std::vector<int> &basket2)\n{\n    std::unordered_map<int, int> differenceCount;\n    for(int index= 0; index < basket1.size(); index++)\n    {\n        differenceCount[basket1[index] - basket2[index]]++;\n    }\n\n    int minimumCost= std::numeric_limits<int>::max(), currentCost= 0;\n    for(auto it = differenceCount.begin(); it != differenceCount.end(); ++it)\n    {\n        const auto &entry = *it;\n        if(entry.second == differenceCount[-entry.first])\n        {\n            currentCost = 0;\n            for(int index= 0; index < basket1.size(); index++)\n            {\n                if(basket1[index] - basket2[index] == entry.first)\n                {\n                    currentCost += std::min(basket1[index], basket2[index]);\n                }\n            }\n            minimumCost = std::min(minimumCost, currentCost);\n        }\n    }\n\n    return minimumCost == std::numeric_limits<int>::max() ? -1 : minimumCost / 2;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint concatenationValue(vector<int> &numberList)\n{\n    int concatenatedValue= 0;\n    while(!numberList.empty())\n    {\n        int size= numberList.size();\n        if(size == 1)\n        {\n            concatenatedValue+= numberList[0];\n            numberList.pop_back();\n        }\n        else\n        {\n            concatenatedValue+= stoi(to_string(numberList[0]) + to_string(numberList[size - 1]));\n            numberList.erase(numberList.begin());\n            numberList.pop_back();\n        }\n    }\n    return concatenatedValue;\n}",
    "output": "#include <bits/stdc++.h>\nint ConcatenationValue(std::vector<int> &numberList)\n{\n    int concatenatedValue= 0;\n    while(!numberList.empty())\n    {\n        int size= numberList.size();\n        if(size == 1)\n        {\n            concatenatedValue+= numberList[0];\n            numberList.pop_back();\n        }\n        else\n        {\n            concatenatedValue+= std::stoi(std::to_string(numberList[0]) + std::to_string(numberList[size - 1]));\n            numberList.erase(numberList.begin());\n            numberList.pop_back();\n        }\n    }\n    return concatenatedValue;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countFairPairs(vector<int> &numbers, int lowerBound, int upperBound)\n{\n    int size= numbers.size();\n    int fairPairCount= 0;\n    for(int indexI= 0; indexI < size; ++indexI)\n    {\n        for(int indexJ= indexI + 1; indexJ < size; ++indexJ)\n        {\n            if((lowerBound <= numbers[indexI] + numbers[indexJ]) && (numbers[indexI] + numbers[indexJ] <= upperBound))\n            {\n                fairPairCount++;\n            }\n        }\n    }\n    return fairPairCount;\n}",
    "output": "#include <bits/stdc++.h>\nint CountFairPairs(std::vector<int> &numbers, int lowerBound, int upperBound)\n{\n    int size = numbers.size();\n    int fairPairCount = 0;\n    for(int indexI = 0; indexI < size; ++indexI)\n    {\n        for(int indexJ = indexI + 1; indexJ < size; ++indexJ)\n        {\n            if((lowerBound <= numbers[indexI] + numbers[indexJ]) && (numbers[indexI] + numbers[indexJ] <= upperBound))\n            {\n                fairPairCount++;\n            }\n        }\n    }\n    return fairPairCount;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\n// Include this for log2 function\n\nusing namespace std;\n\nvector<vector<int>> shortestSubstringQueries(const string &inputString, const vector<vector<int>> &queryPairs)\n{\n    int stringLength = inputString.length();\n    unordered_map<int, int> indexMap;\n\n    for(int currentIndex = 0, currentValue = 0, bitMask = 0; currentIndex < stringLength; currentIndex++)\n    {\n        bitMask |= 1 << (inputString[currentIndex] - '0');\n        currentValue = (currentValue << 1) | (inputString[currentIndex] - '0');\n\n        for(int bitPosition = 0; bitPosition <= 9 && currentIndex + 1 - (1 << bitPosition) >= 0; bitPosition++)\n        {\n            int newValue = currentValue & ((1 << (bitPosition + 1)) - 1);\n            if(indexMap.count(newValue) == 0)\n                indexMap[newValue] = currentIndex + 1 - (1 << bitPosition);\n        }\n    }\n\n    vector<vector<int>> result;\n    for(int i = 0; i < queryPairs.size(); ++i)\n    {\n        const auto &query = queryPairs[i];\n        int targetValue = query[0] ^ query[1];\n        if(indexMap.count(targetValue))\n            result.push_back({indexMap[targetValue], indexMap[targetValue] + static_cast<int>(log2(targetValue))});\n        else\n            result.push_back({-1, -1});\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> ShortestSubstringQueries(const std::string &inputString, const std::vector<std::vector<int>> &queryPairs)\n{\n    int stringLength = inputString.length();\n    std::unordered_map<int, int> indexMap;\n\n    for (int currentIndex = 0, currentValue = 0, bitMask = 0; currentIndex < stringLength; currentIndex++)\n    {\n        bitMask |= 1 << (inputString[currentIndex] - '0');\n        currentValue = (currentValue << 1) | (inputString[currentIndex] - '0');\n\n        for (int bitPosition = 0; bitPosition <= 9 && currentIndex + 1 - (1 << bitPosition) >= 0; bitPosition++)\n        {\n            int newValue = currentValue & ((1 << (bitPosition + 1)) - 1);\n            if (indexMap.count(newValue) == 0)\n                indexMap[newValue] = currentIndex + 1 - (1 << bitPosition);\n        }\n    }\n\n    std::vector<std::vector<int>> result;\n    for (size_t i = 0; i < queryPairs.size(); ++i)\n    {\n        const auto &query = queryPairs[i];\n        int targetValue = query[0] ^ query[1];\n        if (indexMap.count(targetValue))\n            result.push_back({indexMap[targetValue], indexMap[targetValue] + static_cast<int>(log2(targetValue))});\n        else\n            result.push_back({-1, -1});\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMinimumScore(string sourceString, string targetString)\n{\n    int sourceLength= sourceString.size(), targetLength= targetString.size();\n    vector<vector<int>> dynamicProgrammingTable(sourceLength + 1, vector<int>(targetLength + 1, 1e6));\n    dynamicProgrammingTable[0][0]= 0;\n    for(int sourceIndex= 0; sourceIndex < sourceLength; ++sourceIndex)\n        for(int targetIndex= 0; targetIndex < targetLength; ++targetIndex)\n            if(sourceString[sourceIndex] == targetString[targetIndex])\n                dynamicProgrammingTable[sourceIndex + 1][targetIndex + 1]= min(dynamicProgrammingTable[sourceIndex + 1][targetIndex + 1], dynamicProgrammingTable[sourceIndex][targetIndex]);\n            else\n                dynamicProgrammingTable[sourceIndex + 1][targetIndex]= min(dynamicProgrammingTable[sourceIndex + 1][targetIndex], dynamicProgrammingTable[sourceIndex][targetIndex] + 1);\n    int minimumScore= 1e6;\n    for(int sourceIndex= 0; sourceIndex < sourceLength; ++sourceIndex)\n        minimumScore= min(minimumScore, dynamicProgrammingTable[sourceIndex + 1][targetLength]);\n    return minimumScore;\n}",
    "output": "#include <bits/stdc++.h>\nint CalculateMinimumScore(std::string sourceString, std::string targetString)\n{\n    int sourceLength= sourceString.size(), targetLength= targetString.size();\n    std::vector<std::vector<int>> dynamicProgrammingTable(sourceLength + 1, std::vector<int>(targetLength + 1, 1e6));\n    dynamicProgrammingTable[0][0]= 0;\n    for(int sourceIndex= 0; sourceIndex < sourceLength; ++sourceIndex)\n        for(int targetIndex= 0; targetIndex < targetLength; ++targetIndex)\n            if(sourceString[sourceIndex] == targetString[targetIndex])\n                dynamicProgrammingTable[sourceIndex + 1][targetIndex + 1]= std::min(dynamicProgrammingTable[sourceIndex + 1][targetIndex + 1], dynamicProgrammingTable[sourceIndex][targetIndex]);\n            else\n                dynamicProgrammingTable[sourceIndex + 1][targetIndex]= std::min(dynamicProgrammingTable[sourceIndex + 1][targetIndex], dynamicProgrammingTable[sourceIndex][targetIndex] + 1);\n    int minimumScore= 1e6;\n    for(int sourceIndex= 0; sourceIndex < sourceLength; ++sourceIndex)\n        minimumScore= std::min(minimumScore, dynamicProgrammingTable[sourceIndex + 1][targetLength]);\n    return minimumScore;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateDifferenceMaxMin(int inputNumber)\n{\n    int maxRemapValue = 1, minRemapValue = 9;\n    string numberString = to_string(inputNumber);\n    for (int i = 0; i < numberString.size(); ++i)\n    {\n        char digitChar = numberString[i];\n        int digitValue = digitChar - '0';\n        maxRemapValue = max(maxRemapValue, 9 - digitValue);\n        if (digitValue != 0)\n        {\n            minRemapValue = min(minRemapValue, digitValue);\n        }\n    }\n    int maxCalculatedValue = inputNumber + maxRemapValue * (numberString.length() - count(numberString.begin(), numberString.end(), '9' - maxRemapValue));\n    int minCalculatedValue = inputNumber - minRemapValue * count(numberString.begin(), numberString.end(), minRemapValue + '0');\n    return maxCalculatedValue - minCalculatedValue;\n}",
    "output": "#include <bits/stdc++.h>\nint CalculateDifferenceMaxMin(int inputNumber)\n{\n    int maxRemapValue = 1, minRemapValue = 9;\n    std::string numberString = std::to_string(inputNumber);\n    for (int i = 0; i < numberString.size(); ++i)\n    {\n        char digitChar = numberString[i];\n        int digitValue = digitChar - '0';\n        maxRemapValue = std::max(maxRemapValue, 9 - digitValue);\n        if (digitValue != 0)\n        {\n            minRemapValue = std::min(minRemapValue, digitValue);\n        }\n    }\n    int maxCalculatedValue = inputNumber + maxRemapValue * (numberString.length() - std::count(numberString.begin(), numberString.end(), '9' - maxRemapValue));\n    int minCalculatedValue = inputNumber - minRemapValue * std::count(numberString.begin(), numberString.end(), minRemapValue + '0');\n    return maxCalculatedValue - minCalculatedValue;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minScoreAfterChange(vector<int> &numbers)\n{\n    int size = numbers.size();\n    int firstMin = numbers[0], secondMin = numbers[1], lastMax = numbers[size - 1], secondLastMax = numbers[size - 2];\n\n    for(int index = 1; index < size - 1; index++)\n    {\n        firstMin = min(firstMin, numbers[index]);\n        secondMin = min(secondMin, numbers[index + 1]);\n        lastMax = max(lastMax, numbers[index]);\n        secondLastMax = max(secondLastMax, numbers[index - 1]);\n    }\n\n    int low = min(min(firstMin, lastMax), min(secondMin, secondLastMax));\n    int high = max(max(firstMin, lastMax), max(secondMin, secondLastMax));\n\n    return high - low;\n}",
    "output": "#include <bits/stdc++.h>\nint MinScoreAfterChange(std::vector<int> &numbers)\n{\n    int size= numbers.size();\n    int firstMin= numbers[0], secondMin= numbers[1], lastMax= numbers[size - 1], secondLastMax= numbers[size - 2];\n\n    for(int index= 1; index < size - 1; index++)\n    {\n        firstMin= std::min(firstMin, numbers[index]);\n        secondMin= std::min(secondMin, numbers[index + 1]);\n        lastMax= std::max(lastMax, numbers[index]);\n        secondLastMax= std::max(secondLastMax, numbers[index - 1]);\n    }\n\n    int low= std::min(std::min(firstMin, lastMax), std::min(secondMin, secondLastMax));\n    int high= std::max(std::max(firstMin, lastMax), std::max(secondMin, secondLastMax));\n\n    return high - low;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findMinNonExpressibleInteger(vector<int> &sortedNumbers)\n{\n    int minimumNonExpressibleInteger = 1;\n    sort(sortedNumbers.begin(), sortedNumbers.end());\n    for (int i = 0; i < sortedNumbers.size(); ++i)\n    {\n        int currentNumber = sortedNumbers[i];\n        if (currentNumber > minimumNonExpressibleInteger)\n            break;\n        minimumNonExpressibleInteger += currentNumber;\n    }\n    return minimumNonExpressibleInteger;\n}",
    "output": "#include <bits/stdc++.h>\nint FindMinNonExpressibleInteger(std::vector<int> &sortedNumbers)\n{\n    int minimumNonExpressibleInteger = 1;\n    std::sort(sortedNumbers.begin(), sortedNumbers.end());\n    for (size_t i = 0; i < sortedNumbers.size(); ++i)\n    {\n        int currentNumber = sortedNumbers[i];\n        if (currentNumber > minimumNonExpressibleInteger)\n            break;\n        minimumNonExpressibleInteger += currentNumber;\n    }\n    return minimumNonExpressibleInteger;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> solve(vector<int> &sourceArray, vector<int> &targetArray, vector<vector<int>> &queries)\n{\n    vector<int> result;\n    for (int i = 0; i < queries.size(); ++i)\n    {\n        auto &query = queries[i];\n        if (query[0] == 1)\n        {\n            for (int index = query[1]; index <= query[2]; index++)\n            {\n                sourceArray[index] ^= 1;\n            }\n        }\n        else if (query[0] == 2)\n        {\n            for (int index = 0; index < sourceArray.size(); index++)\n            {\n                targetArray[index] += sourceArray[index] * query[1];\n            }\n        }\n        else if (query[0] == 3)\n        {\n            int totalSum = 0;\n            for (int j = 0; j < targetArray.size(); ++j)\n            {\n                totalSum += targetArray[j];\n            }\n            result.push_back(totalSum);\n        }\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> Solve(std::vector<int> &sourceArray, std::vector<int> &targetArray, std::vector<std::vector<int>> &queries)\n{\n    std::vector<int> result;\n    for (int i = 0; i < queries.size(); ++i)\n    {\n        auto &query = queries[i];\n        if (query[0] == 1)\n        {\n            for (int index = query[1]; index <= query[2]; index++)\n            {\n                sourceArray[index] ^= 1;\n            }\n        }\n        else if (query[0] == 2)\n        {\n            for (int index = 0; index < sourceArray.size(); index++)\n            {\n                targetArray[index] += sourceArray[index] * query[1];\n            }\n        }\n        else if (query[0] == 3)\n        {\n            int totalSum = 0;\n            for (int j = 0; j < targetArray.size(); ++j)\n            {\n                totalSum += targetArray[j];\n            }\n            result.push_back(totalSum);\n        }\n    }\n    return result;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> mergeNumbers(vector<vector<int>> &numberList1, vector<vector<int>> &numberList2)\n{\n    map<int, int> mergedMap;\n    vector<vector<int>> mergedResult;\n\n    for (int i = 0; i < numberList1.size(); ++i)\n    {\n        const auto &currentPair = numberList1[i];\n        mergedMap[currentPair[0]] += currentPair[1];\n    }\n\n    for (int i = 0; i < numberList2.size(); ++i)\n    {\n        const auto &currentPair = numberList2[i];\n        mergedMap[currentPair[0]] += currentPair[1];\n    }\n\n    for (const auto &currentPair : mergedMap)\n    {\n        mergedResult.push_back({currentPair.first, currentPair.second});\n    }\n\n    return mergedResult;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> MergeNumbers(std::vector<std::vector<int>> &numberList1, std::vector<std::vector<int>> &numberList2)\n{\n    std::map<int, int> mergedMap;\n    std::vector<std::vector<int>> mergedResult;\n\n    for (int i = 0; i < numberList1.size(); ++i)\n    {\n        const auto &currentPair = numberList1[i];\n        mergedMap[currentPair[0]] += currentPair[1];\n    }\n\n    for (int i = 0; i < numberList2.size(); ++i)\n    {\n        const auto &currentPair = numberList2[i];\n        mergedMap[currentPair[0]] += currentPair[1];\n    }\n\n    for (const auto &currentPair : mergedMap)\n    {\n        mergedResult.push_back({currentPair.first, currentPair.second});\n    }\n\n    return mergedResult;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "int minOperations(int inputNumber)\n{\n    int totalOperations= 0;\n    while(inputNumber)\n    {\n        totalOperations+= inputNumber % 2;\n        inputNumber/= 2;\n    }\n    return totalOperations;\n}",
    "output": "int MinOperations(int inputNumber)\n{\n    int totalOperations= 0;\n    while(inputNumber)\n    {\n        totalOperations+= inputNumber % 2;\n        inputNumber/= 2;\n    }\n    return totalOperations;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int modulo = 1e9 + 7;\n\nint countSquareFreeSubsets(vector<int> &inputNumbers)\n{\n    unordered_map<int, int> frequencyCounter;\n    for (int number : inputNumbers)\n    {\n        frequencyCounter[number]++;\n    }\n\n    vector<vector<long long>> dynamicProgramming(61, vector<long long>(1001));\n    dynamicProgramming[0][0] = 1;\n    int currentIndex = 0;\n    for (auto it = frequencyCounter.begin(); it != frequencyCounter.end(); ++it)\n    {\n        const int number = it->first;\n        const int frequency = it->second;\n        currentIndex++;\n        for (int squareCount = 0; squareCount <= 60; squareCount++)\n        {\n            for (int nonSquareCount = 0; nonSquareCount + frequency <= 1000; nonSquareCount++)\n            {\n                dynamicProgramming[currentIndex][nonSquareCount + frequency] += dynamicProgramming[currentIndex - 1][nonSquareCount] * ((1LL << frequency) - 1) % modulo;\n                dynamicProgramming[currentIndex][nonSquareCount + frequency] %= modulo;\n                dynamicProgramming[currentIndex][nonSquareCount] += dynamicProgramming[currentIndex - 1][nonSquareCount];\n                dynamicProgramming[currentIndex][nonSquareCount] %= modulo;\n\n                if ((squareCount / number) % 2 == 1)\n                {\n                    dynamicProgramming[currentIndex][nonSquareCount + frequency] -= dynamicProgramming[currentIndex - 1][nonSquareCount] * ((1LL << (frequency - 1)) - 1) % modulo;\n                    if (dynamicProgramming[currentIndex][nonSquareCount + frequency] < 0)\n                        dynamicProgramming[currentIndex][nonSquareCount + frequency] += modulo;\n                }\n            }\n        }\n    }\n    return dynamicProgramming[currentIndex][0];\n}",
    "output": "#include <bits/stdc++.h>\nconst int modulo = 1e9 + 7;\n\nint CountSquareFreeSubsets(std::vector<int> &inputNumbers)\n{\n    std::unordered_map<int, int> frequencyCounter;\n    for (int number : inputNumbers)\n    {\n        frequencyCounter[number]++;\n    }\n\n    std::vector<std::vector<long long>> dynamicProgramming(61, std::vector<long long>(1001));\n    dynamicProgramming[0][0] = 1;\n    int currentIndex = 0;\n    for (auto it = frequencyCounter.begin(); it != frequencyCounter.end(); ++it)\n    {\n        const int number = it->first;\n        const int frequency = it->second;\n        currentIndex++;\n        for (int squareCount = 0; squareCount <= 60; squareCount++)\n        {\n            for (int nonSquareCount = 0; nonSquareCount + frequency <= 1000; nonSquareCount++)\n            {\n                dynamicProgramming[currentIndex][nonSquareCount + frequency] += dynamicProgramming[currentIndex - 1][nonSquareCount] * ((1LL << frequency) - 1) % modulo;\n                dynamicProgramming[currentIndex][nonSquareCount + frequency] %= modulo;\n                dynamicProgramming[currentIndex][nonSquareCount] += dynamicProgramming[currentIndex - 1][nonSquareCount];\n                dynamicProgramming[currentIndex][nonSquareCount] %= modulo;\n\n                if ((squareCount / number) % 2 == 1)\n                {\n                    dynamicProgramming[currentIndex][nonSquareCount + frequency] -= dynamicProgramming[currentIndex - 1][nonSquareCount] * ((1LL << (frequency - 1)) - 1) % modulo;\n                    if (dynamicProgramming[currentIndex][nonSquareCount + frequency] < 0)\n                        dynamicProgramming[currentIndex][nonSquareCount + frequency] += modulo;\n                }\n            }\n        }\n    }\n    return dynamicProgramming[currentIndex][0];\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring smallestWordForLCP(vector<vector<int>> &longestCommonPrefix)\n{\n    int matrixSize = longestCommonPrefix.size();\n    string resultWord(matrixSize, 'a');\n    for(int rowIndex = 1; rowIndex < matrixSize; ++rowIndex)\n        for(int colIndex = 1; colIndex < matrixSize; ++colIndex)\n        {\n            if(longestCommonPrefix[rowIndex][colIndex] > min(longestCommonPrefix[rowIndex - 1][colIndex], longestCommonPrefix[rowIndex][colIndex - 1]))\n            {\n                resultWord[rowIndex + longestCommonPrefix[rowIndex][colIndex] - 1] = max(resultWord[rowIndex + longestCommonPrefix[rowIndex][colIndex] - 1], (char)(resultWord[rowIndex - 1] + 1));\n            }\n            else if(longestCommonPrefix[rowIndex][colIndex] < min(longestCommonPrefix[rowIndex - 1][colIndex], longestCommonPrefix[rowIndex][colIndex - 1]))\n            {\n                return \"\";\n            }\n        }\n    return resultWord;\n}",
    "output": "#include <bits/stdc++.h>\nstd::string SmallestWordForLCP(std::vector<std::vector<int>> &longestCommonPrefix)\n{\n    int matrixSize= longestCommonPrefix.size();\n    std::string resultWord(matrixSize, 'a');\n    for(int rowIndex= 1; rowIndex < matrixSize; ++rowIndex)\n        for(int colIndex= 1; colIndex < matrixSize; ++colIndex)\n        {\n            if(longestCommonPrefix[rowIndex][colIndex] > std::min(longestCommonPrefix[rowIndex - 1][colIndex], longestCommonPrefix[rowIndex][colIndex - 1]))\n            {\n                resultWord[rowIndex + longestCommonPrefix[rowIndex][colIndex] - 1]= std::max(resultWord[rowIndex + longestCommonPrefix[rowIndex][colIndex] - 1], (char)(resultWord[rowIndex - 1] + 1));\n            }\n            else if(longestCommonPrefix[rowIndex][colIndex] < std::min(longestCommonPrefix[rowIndex - 1][colIndex], longestCommonPrefix[rowIndex][colIndex - 1]))\n            {\n                return \"\";\n            }\n        }\n    return resultWord;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> getAnswer(vector<int> &inputNumbers)\n{\n    int size= inputNumbers.size();\n    vector<int> leftSum(size, 0), rightSum(size, 0), result(size, 0);\n\n    for(int index= 1; index < size; index++)\n    {\n        leftSum[index]= leftSum[index - 1] + inputNumbers[index - 1];\n    }\n\n    for(int index= size - 2; index >= 0; index--)\n    {\n        rightSum[index]= rightSum[index + 1] + inputNumbers[index + 1];\n    }\n\n    for(int index= 0; index < size; index++)\n    {\n        result[index]= abs(leftSum[index] - rightSum[index]);\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> GetAnswer(std::vector<int> &inputNumbers)\n{\n    int size = inputNumbers.size();\n    std::vector<int> leftSum(size, 0), rightSum(size, 0), result(size, 0);\n\n    for(int index = 1; index < size; index++)\n    {\n        leftSum[index] = leftSum[index - 1] + inputNumbers[index - 1];\n    }\n\n    for(int index = size - 2; index >= 0; index--)\n    {\n        rightSum[index] = rightSum[index + 1] + inputNumbers[index + 1];\n    }\n\n    for(int index = 0; index < size; index++)\n    {\n        result[index] = std::abs(leftSum[index] - rightSum[index]);\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> divisibilityArray(string numberString, int divisor)\n{\n    vector<int> divisibilityResults(numberString.size());\n    int currentValue= 0;\n    for(size_t index= 0; index < numberString.length(); ++index)\n    {\n        currentValue= (currentValue * 10 + (numberString[index] - '0')) % divisor;\n        divisibilityResults[index]= (currentValue == 0) ? 1 : 0;\n    }\n    return divisibilityResults;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> DivisibilityArray(std::string numberString, int divisor)\n{\n    std::vector<int> divisibilityResults(numberString.size());\n    int currentValue= 0;\n    for(size_t index= 0; index < numberString.length(); ++index)\n    {\n        currentValue= (currentValue * 10 + (numberString[index] - '0')) % divisor;\n        divisibilityResults[index]= (currentValue == 0) ? 1 : 0;\n    }\n    return divisibilityResults;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minTime(vector<vector<int>> &grid)\n{\n    int rows= grid.size(), columns= grid[0].size();\n    vector<vector<int>> visited(rows, vector<int>(columns, 1000000));\n\n    const int directionX[]= {-1, 0, 1, 0};\n    const int directionY[]= {0, 1, 0, -1};\n\n    visited[0][0]= 0;\n\n    queue<pair<int, int>> positionQueue;\n    positionQueue.push({0, 0});\n\n    while(!positionQueue.empty())\n    {\n        auto [currentX, currentY]= positionQueue.front();\n        positionQueue.pop();\n\n        for(int i= 0; i < 4; i++)\n        {\n            int nextX= currentX + directionX[i];\n            int nextY= currentY + directionY[i];\n\n            if(nextX >= 0 && nextX < rows && nextY >= 0 && nextY < columns)\n            {\n                int time= max(grid[nextX][nextY], visited[currentX][currentY] + 1);\n                if(visited[nextX][nextY] > time)\n                {\n                    visited[nextX][nextY]= time;\n                    positionQueue.push({nextX, nextY});\n                }\n            }\n        }\n    }\n\n    return visited[rows - 1][columns - 1] == 1000000 ? -1 : visited[rows - 1][columns - 1];\n}",
    "output": "#include <bits/stdc++.h>\nint MinTime(std::vector<std::vector<int>> &grid)\n{\n    int rows = grid.size(), columns = grid[0].size();\n    std::vector<std::vector<int>> visited(rows, std::vector<int>(columns, 1000000));\n\n    const int directionX[] = {-1, 0, 1, 0};\n    const int directionY[] = {0, 1, 0, -1};\n\n    visited[0][0] = 0;\n\n    std::queue<std::pair<int, int>> positionQueue;\n    positionQueue.push({0, 0});\n\n    while (!positionQueue.empty())\n    {\n        auto [currentX, currentY] = positionQueue.front();\n        positionQueue.pop();\n\n        for (int i = 0; i < 4; i++)\n        {\n            int nextX = currentX + directionX[i];\n            int nextY = currentY + directionY[i];\n\n            if (nextX >= 0 && nextX < rows && nextY >= 0 && nextY < columns)\n            {\n                int time = std::max(grid[nextX][nextY], visited[currentX][currentY] + 1);\n                if (visited[nextX][nextY] > time)\n                {\n                    visited[nextX][nextY] = time;\n                    positionQueue.push({nextX, nextY});\n                }\n            }\n        }\n    }\n\n    return visited[rows - 1][columns - 1] == 1000000 ? -1 : visited[rows - 1][columns - 1];\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMinSumOfTwoNumbers(string inputNumber)\n{\n    vector<int> digitCount(10, 0);\n    for (char digit : inputNumber)\n        digitCount[digit - '0']++;\n\n    int firstNumber = 0, secondNumber = 0;\n    for (int i = 1; i <= 9; i += 2)\n    {\n        int count = digitCount[i];\n        while (count--)\n            firstNumber = firstNumber * 10 + i;\n    }\n    for (int i = 0; i <= 9; i += 2)\n    {\n        int count = digitCount[i];\n        while (count--)\n            secondNumber = secondNumber * 10 + i;\n    }\n    return firstNumber + secondNumber;\n}",
    "output": "#include <bits/stdc++.h>\nint CalculateMinSumOfTwoNumbers(std::string inputNumber)\n{\n    std::vector<int> digitCount(10, 0);\n    for(char digit : inputNumber)\n        digitCount[digit - '0']++;\n\n    int firstNumber = 0, secondNumber = 0;\n    for(int i = 1; i <= 9; i += 2)\n    {\n        int count = digitCount[i];\n        while(count--)\n            firstNumber = firstNumber * 10 + i;\n    }\n    for(int i = 0; i <= 9; i += 2)\n    {\n        int count = digitCount[i];\n        while(count--)\n            secondNumber = secondNumber * 10 + i;\n    }\n    return firstNumber + secondNumber;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "int calculateColoredCells(int gridSize)\n{\n    return gridSize * gridSize + (gridSize - 1) * (gridSize - 1);\n}",
    "output": "int CalculateColoredCells(int gridSize)\n{\n    return gridSize * gridSize + (gridSize - 1) * (gridSize - 1);\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int modulo = 1e9 + 7;\n\nint totalWaysToSplitRanges(vector<vector<int>> &ranges)\n{\n    sort(ranges.begin(), ranges.end(), [](const vector<int> &firstRange, const vector<int> &secondRange)\n         { return firstRange[1] < secondRange[1]; });\n    int overlappingCount = 0, nonOverlappingCount = 1, previousEnd = -1;\n    for (int i = 0; i < ranges.size(); ++i)\n    {\n        const auto &currentRange = ranges[i];\n        if (currentRange[0] <= previousEnd)\n        {\n            overlappingCount++;\n        }\n        else\n        {\n            nonOverlappingCount++;\n        }\n        previousEnd = max(previousEnd, currentRange[1]);\n    }\n    long result = 1;\n    for (int i = 1; i <= overlappingCount; ++i)\n    {\n        result = (result * 2) % modulo;\n    }\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nconst int modulo = 1e9 + 7;\n\nint TotalWaysToSplitRanges(std::vector<std::vector<int>> &ranges)\n{\n    std::sort(ranges.begin(), ranges.end(), [](const std::vector<int> &firstRange, const std::vector<int> &secondRange)\n              { return firstRange[1] < secondRange[1]; });\n    int overlappingCount = 0, nonOverlappingCount = 1, previousEnd = -1;\n    for (int i = 0; i < ranges.size(); ++i)\n    {\n        const auto &currentRange = ranges[i];\n        if (currentRange[0] <= previousEnd)\n        {\n            overlappingCount++;\n        }\n        else\n        {\n            nonOverlappingCount++;\n        }\n        previousEnd = std::max(previousEnd, currentRange[1]);\n    }\n    long result = 1;\n    for (int i = 1; i <= overlappingCount; ++i)\n    {\n        result = (result * 2) % modulo;\n    }\n    return result;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint possibleRoots(const vector<vector<int>> &edges, const vector<vector<int>> &guesses, int k)\n{\n    int nodeCount = edges.size() + 1;\n    vector<int> inDegree(nodeCount, 0);\n    unordered_set<int> guessParents;\n\n    for (int i = 0; i < guesses.size(); ++i)\n    {\n        guessParents.insert(guesses[i][0]);\n    }\n\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        inDegree[edges[i][1]]++;\n    }\n\n    int possibleRootsCount = 0;\n    for (int i = 0; i < nodeCount; ++i)\n    {\n        if (inDegree[i] == 0)\n        {\n            if (k == 0 || guessParents.find(i) != guessParents.end())\n            {\n                possibleRootsCount++;\n            }\n        }\n        else if (inDegree[i] == 1 && guesses.size() - k < inDegree[i])\n        {\n            possibleRootsCount++;\n        }\n    }\n    return possibleRootsCount;\n}",
    "output": "#include <bits/stdc++.h>\nint PossibleRoots(const std::vector<std::vector<int>> &edges, const std::vector<std::vector<int>> &guesses, int k)\n{\n    int nodeCount = edges.size() + 1;\n    std::vector<int> inDegree(nodeCount, 0);\n    std::unordered_set<int> guessParents;\n\n    for (int i = 0; i < guesses.size(); ++i)\n    {\n        guessParents.insert(guesses[i][0]);\n    }\n\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        inDegree[edges[i][1]]++;\n    }\n\n    int possibleRootsCount = 0;\n    for (int i = 0; i < nodeCount; ++i)\n    {\n        if (inDegree[i] == 0)\n        {\n            if (k == 0 || guessParents.find(i) != guessParents.end())\n            {\n                possibleRootsCount++;\n            }\n        }\n        else if (inDegree[i] == 1 && guesses.size() - k < inDegree[i])\n        {\n            possibleRootsCount++;\n        }\n    }\n    return possibleRootsCount;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "int calculatePillowPosition(int numberOfPillows, int time)\n{\n    time%= (2 * numberOfPillows - 2);\n    if(time <= numberOfPillows - 1)\n        return time + 1;\n    else\n        return 2 * numberOfPillows - time - 1;\n}",
    "output": "int CalculatePillowPosition(int numberOfPillows, int time)\n{\n    time%= (2 * numberOfPillows - 2);\n    if(time <= numberOfPillows - 1)\n        return time + 1;\n    else\n        return 2 * numberOfPillows - time - 1;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nint kthLargestLevelSum(TreeNode *rootNode, int k)\n{\n    vector<int> levelSums;\n    queue<TreeNode *> nodeQueue;\n    nodeQueue.push(rootNode);\n\n    while(!nodeQueue.empty())\n    {\n        int levelSum= 0;\n        int levelSize= nodeQueue.size();\n        for(int i= 0; i < levelSize; ++i)\n        {\n            TreeNode *currentNode= nodeQueue.front();\n            nodeQueue.pop();\n            levelSum+= currentNode->value;\n\n            if(currentNode->leftChild)\n                nodeQueue.push(currentNode->leftChild);\n            if(currentNode->rightChild)\n                nodeQueue.push(currentNode->rightChild);\n        }\n\n        levelSums.push_back(levelSum);\n    }\n\n    sort(levelSums.begin(), levelSums.end(), greater<int>());\n    return (k > levelSums.size() ? -1 : levelSums[k - 1]);\n}",
    "output": "#include <bits/stdc++.h>\nstruct TreeNode\n{\n    int value;\n    TreeNode *leftChild;\n    TreeNode *rightChild;\n};\n\nint KthLargestLevelSum(TreeNode *rootNode, int k)\n{\n    std::vector<int> levelSums;\n    std::queue<TreeNode *> nodeQueue;\n    nodeQueue.push(rootNode);\n\n    while(!nodeQueue.empty())\n    {\n        int levelSum= 0;\n        int levelSize= nodeQueue.size();\n        for(int i= 0; i < levelSize; ++i)\n        {\n            TreeNode *currentNode= nodeQueue.front();\n            nodeQueue.pop();\n            levelSum+= currentNode->value;\n\n            if(currentNode->leftChild)\n                nodeQueue.push(currentNode->leftChild);\n            if(currentNode->rightChild)\n                nodeQueue.push(currentNode->rightChild);\n        }\n\n        levelSums.push_back(levelSum);\n    }\n\n    std::sort(levelSums.begin(), levelSums.end(), std::greater<int>());\n    return (k > levelSums.size() ? -1 : levelSums[k - 1]);\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint gcd(int firstNumber, int secondNumber)\n{\n    return secondNumber == 0 ? firstNumber : gcd(secondNumber, firstNumber % secondNumber);\n}\n\nint findValidSplit(const vector<int> &numberList)\n{\n    int length= numberList.size();\n    vector<int> prefixProduct(length);\n    vector<int> suffixProduct(length);\n\n    prefixProduct[0]= numberList[0];\n    suffixProduct[length - 1]= numberList[length - 1];\n\n    for(int index= 1; index < length; ++index)\n        prefixProduct[index]= prefixProduct[index - 1] * numberList[index];\n\n    for(int index= length - 2; index >= 0; --index)\n        suffixProduct[index]= suffixProduct[index + 1] * numberList[index];\n\n    for(int index= 0; index < length - 1; ++index)\n    {\n        if(gcd(prefixProduct[index], suffixProduct[index + 1]) == 1)\n            return index;\n    }\n\n    return -1;\n}",
    "output": "#include <bits/stdc++.h>\nint Gcd(int firstNumber, int secondNumber)\n{\n    return secondNumber == 0 ? firstNumber : Gcd(secondNumber, firstNumber % secondNumber);\n}\n\nint FindValidSplit(const std::vector<int> &numberList)\n{\n    int length= numberList.size();\n    std::vector<int> prefixProduct(length);\n    std::vector<int> suffixProduct(length);\n\n    prefixProduct[0]= numberList[0];\n    suffixProduct[length - 1]= numberList[length - 1];\n\n    for(int index= 1; index < length; ++index)\n        prefixProduct[index]= prefixProduct[index - 1] * numberList[index];\n\n    for(int index= length - 2; index >= 0; --index)\n        suffixProduct[index]= suffixProduct[index + 1] * numberList[index];\n\n    for(int index= 0; index < length - 1; ++index)\n    {\n        if(Gcd(prefixProduct[index], suffixProduct[index + 1]) == 1)\n            return index;\n    }\n\n    return -1;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int modulo = 1e9 + 7;\n\nint numberOfWays(int target, vector<vector<int>> &itemTypes)\n{\n    vector<int> dynamicProgramming(target + 1, 0);\n    dynamicProgramming[0] = 1;\n    for (int i = 0; i < itemTypes.size(); ++i)\n    {\n        auto &itemType = itemTypes[i];\n        int itemCount = itemType[0], itemMarks = itemType[1];\n        vector<int> tempDynamicProgramming(target + 1, 0);\n        for (int currentScore = 0; currentScore <= target; ++currentScore)\n        {\n            for (int itemUsed = 0; itemUsed <= itemCount && itemUsed * itemMarks + currentScore <= target; ++itemUsed)\n            {\n                tempDynamicProgramming[currentScore + itemUsed * itemMarks] = (tempDynamicProgramming[currentScore + itemUsed * itemMarks] + dynamicProgramming[currentScore]) % modulo;\n            }\n        }\n        dynamicProgramming = tempDynamicProgramming;\n    }\n    return dynamicProgramming[target];\n}",
    "output": "#include <bits/stdc++.h>\nconst int modulo = 1e9 + 7;\n\nint NumberOfWays(int target, std::vector<std::vector<int>> &itemTypes)\n{\n    std::vector<int> dynamicProgramming(target + 1, 0);\n    dynamicProgramming[0] = 1;\n    for (int i = 0; i < itemTypes.size(); ++i)\n    {\n        auto &itemType = itemTypes[i];\n        int itemCount = itemType[0], itemMarks = itemType[1];\n        std::vector<int> tempDynamicProgramming(target + 1, 0);\n        for (int currentScore = 0; currentScore <= target; ++currentScore)\n        {\n            for (int itemUsed = 0; itemUsed <= itemCount && itemUsed * itemMarks + currentScore <= target; ++itemUsed)\n            {\n                tempDynamicProgramming[currentScore + itemUsed * itemMarks] = \n                    (tempDynamicProgramming[currentScore + itemUsed * itemMarks] + dynamicProgramming[currentScore]) % modulo;\n            }\n        }\n        dynamicProgramming = tempDynamicProgramming;\n    }\n    return dynamicProgramming[target];\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isVowel(char character)\n{\n    return character == 'a' || character == 'e' || character == 'i' || character == 'o' || character == 'u';\n}\n\nint countVowelStrings(vector<string> &words, int leftIndex, int rightIndex)\n{\n    int vowelCount= 0;\n    for(int index= leftIndex; index <= rightIndex; index++)\n    {\n        if(isVowel(words[index][0]) && isVowel(words[index][words[index].length() - 1]))\n        {\n            vowelCount++;\n        }\n    }\n    return vowelCount;\n}",
    "output": "#include <bits/stdc++.h>\nbool IsVowel(char character)\n{\n    return character == 'a' || character == 'e' || character == 'i' || character == 'o' || character == 'u';\n}\n\nint CountVowelStrings(std::vector<std::string> &words, int leftIndex, int rightIndex)\n{\n    int vowelCount= 0;\n    for(int index= leftIndex; index <= rightIndex; index++)\n    {\n        if(IsVowel(words[index][0]) && IsVowel(words[index][words[index].length() - 1]))\n        {\n            vowelCount++;\n        }\n    }\n    return vowelCount;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxScore(vector<int> &scores)\n{\n    sort(scores.begin(), scores.end());\n    int count= 0, totalPrefixSum= 0;\n    for(int index= 0; index < scores.size(); ++index)\n    {\n        if(totalPrefixSum + scores[index] > 0)\n        {\n            ++count;\n            totalPrefixSum+= scores[index];\n        }\n    }\n    return count;\n}",
    "output": "#include <bits/stdc++.h>\nint MaxScore(std::vector<int> &scores)\n{\n    std::sort(scores.begin(), scores.end());\n    int count= 0, totalPrefixSum= 0;\n    for(int index= 0; index < scores.size(); ++index)\n    {\n        if(totalPrefixSum + scores[index] > 0)\n        {\n            ++count;\n            totalPrefixSum+= scores[index];\n        }\n    }\n    return count;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countBeautifulSubarrays(vector<int> &inputNumbers)\n{\n    vector<int> oddCount(20, 0);\n    vector<int> evenCount(20, 0);\n    evenCount[0] = 1;\n\n    for (int i = 0; i < inputNumbers.size(); ++i)\n    {\n        int currentNumber = inputNumbers[i];\n        bool isOdd = __builtin_parity(currentNumber);\n        for (int j = 19; j >= 0; j--)\n        {\n            int bitMask = 1 << j;\n            if (currentNumber & bitMask)\n            {\n                if (isOdd)\n                    swap(oddCount[j], evenCount[j]);\n                oddCount[j]++;\n            }\n            else\n            {\n                if (!isOdd)\n                    swap(oddCount[j], evenCount[j]);\n                evenCount[j]++;\n            }\n            currentNumber -= (currentNumber & bitMask);\n        }\n    }\n\n    long long result = 0;\n    for (int i = 0; i < 20; i++)\n        result += (long long)evenCount[i] * (evenCount[i] - 1) / 2;\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nint CountBeautifulSubarrays(std::vector<int> &inputNumbers)\n{\n    std::vector<int> oddCount(20, 0);\n    std::vector<int> evenCount(20, 0);\n    evenCount[0] = 1;\n\n    for (size_t currentIndex = 0; currentIndex < inputNumbers.size(); ++currentIndex)\n    {\n        int currentNumber = inputNumbers[currentIndex];\n        bool isOdd = __builtin_parity(currentNumber);\n        for (int i = 19; i >= 0; i--)\n        {\n            int bitMask = 1 << i;\n            if (currentNumber & bitMask)\n            {\n                if (isOdd)\n                    std::swap(oddCount[i], evenCount[i]);\n                oddCount[i]++;\n            }\n            else\n            {\n                if (!isOdd)\n                    std::swap(oddCount[i], evenCount[i]);\n                evenCount[i]++;\n            }\n            currentNumber -= (currentNumber & bitMask);\n        }\n    }\n\n    long long result = 0;\n    for (int i = 0; i < 20; i++)\n        result += (long long)evenCount[i] * (evenCount[i] - 1) / 2;\n    return result;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minTimeOn(vector<vector<int>> &taskList)\n{\n    vector<vector<int>> timeIntervals;\n    for (int i = 0; i < taskList.size(); ++i)\n    {\n        const auto &task = taskList[i];\n        timeIntervals.push_back({task[1] + 1, task[2]});\n    }\n    sort(timeIntervals.begin(), timeIntervals.end());\n\n    vector<int> dynamicProgramming(2001, 0);\n    for (int i = 0; i < timeIntervals.size(); ++i)\n    {\n        const auto &interval = timeIntervals[i];\n        for (int time = 2000; time >= interval[0]; --time)\n        {\n            dynamicProgramming[time] = max(dynamicProgramming[time], dynamicProgramming[time - interval[1]] + interval[1]);\n        }\n    }\n    return dynamicProgramming.back();\n}",
    "output": "#include <bits/stdc++.h>\nint MinTimeOn(std::vector<std::vector<int>> &taskList)\n{\n    std::vector<std::vector<int>> timeIntervals;\n    for (const auto &task : taskList)\n    {\n        timeIntervals.push_back({task[1] + 1, task[2]});\n    }\n    std::sort(timeIntervals.begin(), timeIntervals.end());\n\n    std::vector<int> dynamicProgramming(2001, 0);\n    for (int i = 0; i < timeIntervals.size(); ++i)\n    {\n        const auto &interval = timeIntervals[i];\n        for (int time = 2000; time >= interval[0]; --time)\n        {\n            dynamicProgramming[time] = std::max(dynamicProgramming[time], dynamicProgramming[time - interval[1]] + interval[1]);\n        }\n    }\n    return dynamicProgramming.back();\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass TodoList\n{\n  public:\n    struct Task\n    {\n        int id;\n        string description;\n        int dueDate;\n        vector<string> tags;\n        bool isCompleted;\n\n        Task(int taskId, const string &taskDesc, int taskDueDate, const vector<string> &taskTags)\n            : id(taskId), description(taskDesc), dueDate(taskDueDate), tags(taskTags), isCompleted(false) {}\n    };\n\n    TodoList() : taskId(1) {}\n\n    int addTask(int userId, string taskDescription, int dueDate, vector<string> tags)\n    {\n        tasks[userId].emplace_back(taskId, taskDescription, dueDate, tags);\n        return taskId++;\n    }\n\n    vector<string> getAllTasks(int userId)\n    {\n        vector<string> result;\n        vector<Task> &userTasks = tasks[userId];\n\n        sort(userTasks.begin(), userTasks.end(), [](const Task &a, const Task &b)\n             { return a.dueDate < b.dueDate; });\n\n        for (size_t i = 0; i < userTasks.size(); ++i)\n        {\n            const auto &task = userTasks[i];\n            if (!task.isCompleted)\n            {\n                result.push_back(task.description);\n            }\n        }\n\n        return result;\n    }\n\n    vector<string> getTasksForTag(int userId, string tag)\n    {\n        vector<string> result;\n        vector<Task> &userTasks = tasks[userId];\n\n        sort(userTasks.begin(), userTasks.end(), [](const Task &a, const Task &b)\n             { return a.dueDate < b.dueDate; });\n\n        for (size_t i = 0; i < userTasks.size(); ++i)\n        {\n            const auto &task = userTasks[i];\n            if (!task.isCompleted && find(task.tags.begin(), task.tags.end(), tag) != task.tags.end())\n            {\n                result.push_back(task.description);\n            }\n        }\n\n        return result;\n    }\n\n    void completeTask(int userId, int taskId)\n    {\n        vector<Task> &userTasks = tasks[userId];\n        for (size_t i = 0; i < userTasks.size(); ++i)\n        {\n            auto &task = userTasks[i];\n            if (task.id == taskId)\n            {\n                task.isCompleted = true;\n                break;\n            }\n        }\n    }\n\n  private:\n    int taskId;\n    map<int, vector<Task>> tasks;\n};",
    "output": "#include <bits/stdc++.h>\nclass TodoList\n{\n  public:\n    struct Task\n    {\n        int id;\n        std::string description;\n        int dueDate;\n        std::vector<std::string> tags;\n        bool isCompleted;\n\n        Task(int taskId, const std::string &taskDesc, int taskDueDate, const std::vector<std::string> &taskTags)\n            : id(taskId), description(taskDesc), dueDate(taskDueDate), tags(taskTags), isCompleted(false) {}\n    };\n\n    TodoList() : taskId(1) {}\n\n    int AddTask(int userId, std::string taskDescription, int dueDate, std::vector<std::string> tags)\n    {\n        tasks[userId].emplace_back(taskId, taskDescription, dueDate, tags);\n        return taskId++;\n    }\n\n    std::vector<std::string> GetAllTasks(int userId)\n    {\n        std::vector<std::string> result;\n        std::vector<Task> &userTasks = tasks[userId];\n\n        std::sort(userTasks.begin(), userTasks.end(), [](const Task &a, const Task &b)\n                  { return a.dueDate < b.dueDate; });\n\n        for (size_t i = 0; i < userTasks.size(); ++i)\n        {\n            const auto &task = userTasks[i];\n            if (!task.isCompleted)\n            {\n                result.push_back(task.description);\n            }\n        }\n\n        return result;\n    }\n\n    std::vector<std::string> GetTasksForTag(int userId, std::string tag)\n    {\n        std::vector<std::string> result;\n        std::vector<Task> &userTasks = tasks[userId];\n\n        std::sort(userTasks.begin(), userTasks.end(), [](const Task &a, const Task &b)\n                  { return a.dueDate < b.dueDate; });\n\n        for (size_t i = 0; i < userTasks.size(); ++i)\n        {\n            const auto &task = userTasks[i];\n            if (!task.isCompleted && std::find(task.tags.begin(), task.tags.end(), tag) != task.tags.end())\n            {\n                result.push_back(task.description);\n            }\n        }\n\n        return result;\n    }\n\n    void CompleteTask(int userId, int taskId)\n    {\n        std::vector<Task> &userTasks = tasks[userId];\n        for (size_t i = 0; i < userTasks.size(); ++i)\n        {\n            auto &task = userTasks[i];\n            if (task.id == taskId)\n            {\n                task.isCompleted = true;\n                break;\n            }\n        }\n    }\n\n  private:\n    int taskId;\n    std::map<int, std::vector<Task>> tasks;\n};"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "int maximumChildrenWithEightDollars(int totalMoney, int totalChildren)\n{\n    if(totalMoney < totalChildren * 1 || totalMoney > totalChildren * 8)\n        return -1;\n    int maxEights= (totalMoney - totalChildren) / 7;\n    return maxEights >= totalChildren ? totalChildren : maxEights;\n}",
    "output": "int MaximumChildrenWithEightDollars(int totalMoney, int totalChildren)\n{\n    if(totalMoney < totalChildren * 1 || totalMoney > totalChildren * 8)\n        return -1;\n    int maxEights= (totalMoney - totalChildren) / 7;\n    return maxEights >= totalChildren ? totalChildren : maxEights;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMaxGreatness(vector<int> &numberList)\n{\n    sort(numberList.begin(), numberList.end());\n    int totalGreatness= 0;\n    for(int index= 1; index < numberList.size(); ++index)\n    {\n        if(numberList[index - 1] < numberList[index])\n        {\n            swap(numberList[index - 1], numberList[index]);\n            ++totalGreatness;\n        }\n    }\n    return totalGreatness;\n}",
    "output": "#include <bits/stdc++.h>\nint CalculateMaxGreatness(std::vector<int> &numberList)\n{\n    std::sort(numberList.begin(), numberList.end());\n    int totalGreatness= 0;\n    for(int index= 1; index < numberList.size(); ++index)\n    {\n        if(numberList[index - 1] < numberList[index])\n        {\n            std::swap(numberList[index - 1], numberList[index]);\n            ++totalGreatness;\n        }\n    }\n    return totalGreatness;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateScore(vector<int> &scoreList)\n{\n    int scoreCount= scoreList.size();\n    vector<int> dp(scoreCount + 2, 0);\n\n    for(int index= 0; index < scoreCount; ++index)\n    {\n        dp[index + 2]= max(dp[index + 1], dp[index] + scoreList[index]);\n    }\n\n    return dp[scoreCount + 1];\n}",
    "output": "#include <bits/stdc++.h>\nint CalculateScore(std::vector<int> &scoreList)\n{\n    int scoreCount= scoreList.size();\n    std::vector<int> dp(scoreCount + 2, 0);\n\n    for(int index= 0; index < scoreCount; ++index)\n    {\n        dp[index + 2]= std::max(dp[index + 1], dp[index] + scoreList[index]);\n    }\n\n    return dp[scoreCount + 1];\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minTimeToRepair(vector<int> &repairRanks, int totalCars)\n{\n    sort(repairRanks.begin(), repairRanks.end());\n    int lowerBound = 0, upperBound = 100 * totalCars * totalCars;\n    while (lowerBound < upperBound)\n    {\n        int midPoint = lowerBound + (upperBound - lowerBound) / 2;\n        int totalCarsRepaired = 0;\n        for (int i = 0; i < repairRanks.size(); ++i)\n        {\n            int rank = repairRanks[i];\n            int carsRepaired = min(totalCars, midPoint / (rank * rank));\n            totalCarsRepaired += carsRepaired;\n            if (totalCarsRepaired >= totalCars)\n                break;\n        }\n        if (totalCarsRepaired >= totalCars)\n            upperBound = midPoint;\n        else\n            lowerBound = midPoint + 1;\n    }\n    return lowerBound;\n}",
    "output": "#include <bits/stdc++.h>\nint MinTimeToRepair(std::vector<int> &repairRanks, int totalCars)\n{\n    std::sort(repairRanks.begin(), repairRanks.end());\n    int lowerBound = 0, upperBound = 100 * totalCars * totalCars;\n    while (lowerBound < upperBound)\n    {\n        int midPoint = lowerBound + (upperBound - lowerBound) / 2;\n        int totalCarsRepaired = 0;\n        \n        for (int i = 0; i < repairRanks.size(); ++i)\n        {\n            int rank = repairRanks[i];\n            int carsRepaired = std::min(totalCars, midPoint / (rank * rank));\n            totalCarsRepaired += carsRepaired;\n            if (totalCarsRepaired >= totalCars)\n                break;\n        }\n        \n        if (totalCarsRepaired >= totalCars)\n            upperBound = midPoint;\n        else\n            lowerBound = midPoint + 1;\n    }\n    return lowerBound;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> countEvenOddIndices(int inputNumber)\n{\n    vector<int> count(2, 0);\n    int currentIndex= 0;\n    while(inputNumber > 0)\n    {\n        if(inputNumber % 2)\n            count[currentIndex % 2]+= 1;\n        inputNumber/= 2;\n        currentIndex+= 1;\n    }\n    return count;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> CountEvenOddIndices(int inputNumber)\n{\n    std::vector<int> count(2, 0);\n    int currentIndex= 0;\n    while(inputNumber > 0)\n    {\n        if(inputNumber % 2)\n            count[currentIndex % 2]+= 1;\n        inputNumber/= 2;\n        currentIndex+= 1;\n    }\n    return count;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isValidMove(int currentRow, int currentCol, int nextValue, int gridSize)\n{\n    return (currentRow + 1 < gridSize && currentCol + 2 < gridSize && nextValue == gridSize * (currentRow + 1) + (currentCol + 2)) ||\n           (currentRow + 1 < gridSize && currentCol - 2 >= 0 && nextValue == gridSize * (currentRow + 1) + (currentCol - 2)) ||\n           (currentRow + 2 < gridSize && currentCol + 1 < gridSize && nextValue == gridSize * (currentRow + 2) + (currentCol + 1)) ||\n           (currentRow + 2 < gridSize && currentCol - 1 >= 0 && nextValue == gridSize * (currentRow + 2) + (currentCol - 1));\n}\n\nbool validPath(vector<vector<int>> &grid)\n{\n    int gridSize= grid.size();\n    for(int rowIndex= 0; rowIndex < gridSize; rowIndex++)\n    {\n        for(int colIndex= 0; colIndex < gridSize; colIndex++)\n        {\n            int currentValue= grid[rowIndex][colIndex];\n            if(currentValue != gridSize * gridSize - 1 && !isValidMove(rowIndex, colIndex, currentValue + 1, gridSize))\n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool IsValidMove(int currentRow, int currentCol, int nextValue, int gridSize)\n{\n    return (currentRow + 1 < gridSize && currentCol + 2 < gridSize && nextValue == gridSize * (currentRow + 1) + (currentCol + 2)) ||\n           (currentRow + 1 < gridSize && currentCol - 2 >= 0 && nextValue == gridSize * (currentRow + 1) + (currentCol - 2)) ||\n           (currentRow + 2 < gridSize && currentCol + 1 < gridSize && nextValue == gridSize * (currentRow + 2) + (currentCol + 1)) ||\n           (currentRow + 2 < gridSize && currentCol - 1 >= 0 && nextValue == gridSize * (currentRow + 2) + (currentCol - 1));\n}\n\nbool ValidPath(std::vector<std::vector<int>> &grid)\n{\n    int gridSize= grid.size();\n    for(int rowIndex= 0; rowIndex < gridSize; rowIndex++)\n    {\n        for(int colIndex= 0; colIndex < gridSize; colIndex++)\n        {\n            int currentValue= grid[rowIndex][colIndex];\n            if(currentValue != gridSize * gridSize - 1 && !IsValidMove(rowIndex, colIndex, currentValue + 1, gridSize))\n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countBeautifulSubsets(vector<int> &numberList, int differenceThreshold)\n{\n    sort(numberList.begin(), numberList.end());\n    int totalCount= 0;\n    vector<int> dynamicProgramming(numberList.size(), 1);\n    for(int currentIndex= 0; currentIndex < numberList.size(); currentIndex++)\n    {\n        for(int previousIndex= 0, leftPointer= 0, rightPointer= -1; previousIndex < currentIndex; previousIndex++)\n        {\n            while(leftPointer < previousIndex && numberList[previousIndex] - numberList[leftPointer] >= differenceThreshold)\n                leftPointer++;\n            while(rightPointer + 1 < previousIndex && numberList[rightPointer + 1] - numberList[previousIndex] < differenceThreshold)\n                rightPointer++;\n            if(leftPointer <= rightPointer)\n                dynamicProgramming[previousIndex]-= dynamicProgramming[leftPointer - 1];\n            dynamicProgramming[previousIndex]+= dynamicProgramming[previousIndex - 1] + 1;\n            totalCount+= dynamicProgramming[previousIndex];\n        }\n    }\n    return totalCount;\n}",
    "output": "#include <bits/stdc++.h>\nint CountBeautifulSubsets(std::vector<int> &numberList, int differenceThreshold)\n{\n    std::sort(numberList.begin(), numberList.end());\n    int totalCount = 0;\n    std::vector<int> dynamicProgramming(numberList.size(), 1);\n    for(int currentIndex = 0; currentIndex < numberList.size(); currentIndex++)\n    {\n        for(int previousIndex = 0, leftPointer = 0, rightPointer = -1; previousIndex < currentIndex; previousIndex++)\n        {\n            while(leftPointer < previousIndex && numberList[previousIndex] - numberList[leftPointer] >= differenceThreshold)\n                leftPointer++;\n            while(rightPointer + 1 < previousIndex && numberList[rightPointer + 1] - numberList[previousIndex] < differenceThreshold)\n                rightPointer++;\n            if(leftPointer <= rightPointer)\n                dynamicProgramming[previousIndex] -= dynamicProgramming[leftPointer - 1];\n            dynamicProgramming[previousIndex] += dynamicProgramming[previousIndex - 1] + 1;\n            totalCount += dynamicProgramming[previousIndex];\n        }\n    }\n    return totalCount;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calculateMaximumMex(vector<int> &numbers, int incrementValue)\n{\n    unordered_set<int> numberSet(numbers.begin(), numbers.end());\n\n    for(int i= 0; i <= 100000; i++)\n    {\n        if(!numberSet.count(i))\n            numberSet.insert(i + incrementValue);\n    }\n\n    int minimumExcludedValue= 0;\n    while(numberSet.count(minimumExcludedValue))\n        minimumExcludedValue++;\n\n    return minimumExcludedValue;\n}",
    "output": "int CalculateMaximumMex(std::vector<int> &numbers, int incrementValue)\n{\n    std::unordered_set<int> numberSet(numbers.begin(), numbers.end());\n\n    for(int i= 0; i <= 100000; i++)\n    {\n        if(!numberSet.count(i))\n            numberSet.insert(i + incrementValue);\n    }\n\n    int minimumExcludedValue= 0;\n    while(numberSet.count(minimumExcludedValue))\n        minimumExcludedValue++;\n\n    return minimumExcludedValue;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &nums)\n{\n    int minimumPrefixSum = 0;\n    int currentPrefixSum = 0;\n    for (int i = 0; i < nums.size(); ++i)\n    {\n        int currentNumber = nums[i];\n        currentPrefixSum += currentNumber;\n        minimumPrefixSum = min(minimumPrefixSum, currentPrefixSum);\n    }\n    return minimumPrefixSum < 0 ? -minimumPrefixSum : 0;\n}",
    "output": "#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &nums)\n{\n    int minimumPrefixSum = 0;\n    int currentPrefixSum = 0;\n    for (int i = 0; i < nums.size(); ++i)\n    {\n        int currentNumber = nums[i];\n        currentPrefixSum += currentNumber;\n        minimumPrefixSum = std::min(minimumPrefixSum, currentPrefixSum);\n    }\n    return minimumPrefixSum < 0 ? -minimumPrefixSum : 0;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "int maxSum(int numberOfOnes, int numberOfZeros, int numberOfNegativeOnes, int limit)\n{\n    int maximumSum= 0;\n    for(int i= 0; i <= limit; ++i)\n    {\n        int onesCount= min(i, numberOfOnes);\n        int negativeOnesCount= min(limit - i, numberOfNegativeOnes);\n        maximumSum= max(maximumSum, onesCount - negativeOnesCount);\n    }\n    return maximumSum;\n}",
    "output": "int MaxSum(int numberOfOnes, int numberOfZeros, int numberOfNegativeOnes, int limit)\n{\n    int maximumSum= 0;\n    for(int i= 0; i <= limit; ++i)\n    {\n        int onesCount= min(i, numberOfOnes);\n        int negativeOnesCount= min(limit - i, numberOfNegativeOnes);\n        maximumSum= max(maximumSum, onesCount - negativeOnesCount);\n    }\n    return maximumSum;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool strictlyIncreasingArray(vector<int> &numberArray)\n{\n    for(int currentIndex= 0; currentIndex < numberArray.size() - 1; ++currentIndex)\n    {\n        numberArray[currentIndex]-= currentIndex;\n        if(numberArray[currentIndex] >= numberArray[currentIndex + 1])\n        {\n            return false;\n        }\n    }\n    return true;\n}",
    "output": "#include <bits/stdc++.h>\nbool StrictlyIncreasingArray(std::vector<int> &numberArray)\n{\n    for(int currentIndex= 0; currentIndex < numberArray.size() - 1; ++currentIndex)\n    {\n        numberArray[currentIndex]-= currentIndex;\n        if(numberArray[currentIndex] >= numberArray[currentIndex + 1])\n        {\n            return false;\n        }\n    }\n    return true;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> minOperations(vector<int> &numbers, vector<int> &queries)\n{\n    vector<int> operationsCount;\n    for (int i = 0; i < queries.size(); ++i)\n    {\n        int query = queries[i];\n        int totalOperations = 0;\n        for (int j = 0; j < numbers.size(); ++j)\n        {\n            int number = numbers[j];\n            totalOperations += abs(number - query);\n        }\n        operationsCount.push_back(totalOperations);\n    }\n    return operationsCount;\n}",
    "output": "#include <bits/stdc++.h>\n// for std::abs\n\nstd::vector<int> MinOperations(std::vector<int> &numbers, std::vector<int> &queries)\n{\n    std::vector<int> operationsCount;\n    for (int i = 0; i < queries.size(); ++i)\n    {\n        int query = queries[i];\n        int totalOperations = 0;\n        for (int j = 0; j < numbers.size(); ++j)\n        {\n            int number = numbers[j];\n            totalOperations += std::abs(number - query);\n        }\n        operationsCount.push_back(totalOperations);\n    }\n    return operationsCount;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\npair<int, int> depthFirstSearch(const vector<vector<int>> &adjacencyList, const vector<int> &coinValues, int currentNode, int parentNode)\n{\n    int totalCoins = coinValues[currentNode], totalDistance = 0;\n    for (int i = 0; i < adjacencyList[currentNode].size(); ++i)\n    {\n        int neighborNode = adjacencyList[currentNode][i];\n        if (neighborNode != parentNode)\n        {\n            auto result = depthFirstSearch(adjacencyList, coinValues, neighborNode, currentNode);\n            totalCoins += result.first;\n            totalDistance += 2 * result.first + result.second;\n        }\n    }\n    return {totalCoins, totalDistance};\n}\n\nint minEdgesToCollectCoins(const vector<int> &coinValues, const vector<vector<int>> &edges)\n{\n    int numberOfNodes = coinValues.size();\n    vector<vector<int>> adjacencyList(numberOfNodes);\n    for (const auto &edge : edges)\n    {\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n    return depthFirstSearch(adjacencyList, coinValues, 0, -1).second / 2;\n}",
    "output": "#include <bits/stdc++.h>\nstd::pair<int, int> DepthFirstSearch(const std::vector<std::vector<int>> &adjacencyList, const std::vector<int> &coinValues, int currentNode, int parentNode)\n{\n    int totalCoins = coinValues[currentNode], totalDistance = 0;\n    for (int i = 0; i < adjacencyList[currentNode].size(); ++i)\n    {\n        int neighborNode = adjacencyList[currentNode][i];\n        if (neighborNode != parentNode)\n        {\n            auto result = DepthFirstSearch(adjacencyList, coinValues, neighborNode, currentNode);\n            totalCoins += result.first;\n            totalDistance += 2 * result.first + result.second;\n        }\n    }\n    return {totalCoins, totalDistance};\n}\n\nint MinEdgesToCollectCoins(const std::vector<int> &coinValues, const std::vector<std::vector<int>> &edges)\n{\n    int numberOfNodes = coinValues.size();\n    std::vector<std::vector<int>> adjacencyList(numberOfNodes);\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        const auto &edge = edges[i];\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n    return DepthFirstSearch(adjacencyList, coinValues, 0, -1).second / 2;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minTimeToEatGrains(vector<int> &hens, vector<int> &grains)\n{\n    sort(hens.begin(), hens.end());\n    sort(grains.begin(), grains.end());\n    int minTime = 0, maxTime = 1e9;\n\n    while (minTime < maxTime)\n    {\n        int midTime = minTime + (maxTime - minTime) / 2;\n        bool canEat = true;\n        int henIndex = 0;\n\n        for (int j = 0; j < grains.size(); ++j)\n        {\n            int grain = grains[j];\n\n            if (henIndex >= hens.size())\n            {\n                canEat = false;\n                break;\n            }\n\n            while (henIndex < hens.size() && hens[henIndex] < grain - midTime)\n            {\n                ++henIndex;\n            }\n\n            if (henIndex >= hens.size() || hens[henIndex] > grain + midTime)\n            {\n                canEat = false;\n                break;\n            }\n\n            ++henIndex;\n        }\n\n        if (canEat)\n        {\n            maxTime = midTime;\n        }\n        else\n        {\n            minTime = midTime + 1;\n        }\n    }\n\n    return minTime;\n}",
    "output": "#include <bits/stdc++.h>\nint MinTimeToEatGrains(std::vector<int> &hens, std::vector<int> &grains)\n{\n    std::sort(hens.begin(), hens.end());\n    std::sort(grains.begin(), grains.end());\n    int minTime = 0, maxTime = 1e9;\n\n    while (minTime < maxTime)\n    {\n        int midTime = minTime + (maxTime - minTime) / 2;\n        bool canEat = true;\n        int henIndex = 0;\n\n        for (int j = 0; j < grains.size(); ++j)\n        {\n            int grain = grains[j];\n            if (henIndex >= hens.size())\n            {\n                canEat = false;\n                break;\n            }\n\n            while (henIndex < hens.size() && hens[henIndex] < grain - midTime)\n            {\n                ++henIndex;\n            }\n\n            if (henIndex >= hens.size() || hens[henIndex] > grain + midTime)\n            {\n                canEat = false;\n                break;\n            }\n\n            ++henIndex;\n        }\n\n        if (canEat)\n        {\n            maxTime = midTime;\n        }\n        else\n        {\n            minTime = midTime + 1;\n        }\n    }\n\n    return minTime;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint findSmallestNumberWithAtLeastOneDigitFromEachArray(vector<int> &firstArray, vector<int> &secondArray)\n{\n    int minFirstArray = *min_element(firstArray.begin(), firstArray.end());\n    int minSecondArray = *min_element(secondArray.begin(), secondArray.end());\n    for (int i = 0; i < firstArray.size(); ++i)\n    {\n        int numberFromFirstArray = firstArray[i];\n        for (int j = 0; j < secondArray.size(); ++j)\n        {\n            int numberFromSecondArray = secondArray[j];\n            if (numberFromFirstArray == numberFromSecondArray)\n            {\n                return numberFromFirstArray;\n            }\n        }\n    }\n    return minFirstArray * 10 + minSecondArray;\n}",
    "output": "#include <bits/stdc++.h>\nint FindSmallestNumberWithAtLeastOneDigitFromEachArray(std::vector<int> &firstArray, std::vector<int> &secondArray)\n{\n    int minFirstArray = *std::min_element(firstArray.begin(), firstArray.end());\n    int minSecondArray = *std::min_element(secondArray.begin(), secondArray.end());\n    for (int i = 0; i < firstArray.size(); ++i)\n    {\n        int numberFromFirstArray = firstArray[i];\n        for (int j = 0; j < secondArray.size(); ++j)\n        {\n            int numberFromSecondArray = secondArray[j];\n            if (numberFromFirstArray == numberFromSecondArray)\n            {\n                return numberFromFirstArray;\n            }\n        }\n    }\n    return minFirstArray * 10 + minSecondArray;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxValueSubstring(string inputString, string charList, vector<int> values)\n{\n    unordered_map<char, int> charValues;\n\n    for(int index = 0; index < charList.length(); index++)\n    {\n        charValues[charList[index]] = values[index];\n    }\n\n    int maxCost = 0;\n    int currentCost = 0;\n\n    for (int i = 0; i < inputString.length(); ++i)\n    {\n        char currentChar = inputString[i];\n        int charValue = charValues.count(currentChar) ? charValues[currentChar] : static_cast<int>(currentChar - 'a' + 1);\n\n        currentCost = max(0, currentCost + charValue);\n        maxCost = max(maxCost, currentCost);\n    }\n\n    return maxCost;\n}",
    "output": "int MaxValueSubstring(std::string inputString, std::string charList, std::vector<int> values)\n{\n    std::unordered_map<char, int> charValues;\n\n    for(int index= 0; index < charList.length(); index++)\n    {\n        charValues[charList[index]]= values[index];\n    }\n\n    int maxCost= 0;\n    int currentCost= 0;\n\n    for (int i = 0; i < inputString.length(); ++i)\n    {\n        char currentChar = inputString[i];\n        int charValue = charValues.count(currentChar) ? charValues[currentChar] : static_cast<int>(currentChar - 'a' + 1);\n\n        currentCost = std::max(0, currentCost + charValue);\n        maxCost = std::max(maxCost, currentCost);\n    }\n\n    return maxCost;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minOperations(vector<int> &array, int subarraySize)\n{\n    int arraySize= array.size(), minimumCost= INT_MAX;\n    vector<int> prefixSum(arraySize + 1);\n\n    for(int index= 1; index <= arraySize; index++)\n    {\n        prefixSum[index]= prefixSum[index - 1] + array[index - 1];\n    }\n\n    for(int startIndex= 1; startIndex <= arraySize - subarraySize + 1; startIndex++)\n    {\n        int targetValue= (prefixSum[startIndex - 1] + prefixSum[arraySize] - prefixSum[startIndex + subarraySize - 1] + arraySize / subarraySize - 1) / (arraySize / subarraySize);\n        int currentCost= 0;\n        for(int elementIndex= startIndex; elementIndex < startIndex + subarraySize; elementIndex++)\n        {\n            currentCost+= abs(array[elementIndex - 1] - targetValue);\n        }\n        minimumCost= min(minimumCost, currentCost);\n    }\n    return minimumCost;\n}",
    "output": "#include <bits/stdc++.h>\nint MinOperations(std::vector<int> &array, int subarraySize)\n{\n    int arraySize= array.size(), minimumCost= INT_MAX;\n    std::vector<int> prefixSum(arraySize + 1);\n\n    for(int index= 1; index <= arraySize; index++)\n    {\n        prefixSum[index]= prefixSum[index - 1] + array[index - 1];\n    }\n\n    for(int startIndex= 1; startIndex <= arraySize - subarraySize + 1; startIndex++)\n    {\n        int targetValue= (prefixSum[startIndex - 1] + prefixSum[arraySize] - prefixSum[startIndex + subarraySize - 1] + arraySize / subarraySize - 1) / (arraySize / subarraySize);\n        int currentCost= 0;\n        for(int elementIndex= startIndex; elementIndex < startIndex + subarraySize; elementIndex++)\n        {\n            currentCost+= std::abs(array[elementIndex - 1] - targetValue);\n        }\n        minimumCost= std::min(minimumCost, currentCost);\n    }\n    return minimumCost;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint shortestCycleLength(int nodeCount, vector<vector<int>> &edges)\n{\n    vector<vector<int>> adjacencyList(nodeCount);\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        const vector<int> &edge = edges[i];\n        adjacencyList[edge[0]].push_back(edge[1]);\n        adjacencyList[edge[1]].push_back(edge[0]);\n    }\n\n    int minimumCycleLength = nodeCount + 1;\n    for (int startNode = 0; startNode < nodeCount; ++startNode)\n    {\n        vector<int> distance(nodeCount, nodeCount + 1);\n        distance[startNode] = 0;\n        queue<int> nodeQueue;\n        nodeQueue.push(startNode);\n\n        while (!nodeQueue.empty())\n        {\n            int currentNode = nodeQueue.front();\n            nodeQueue.pop();\n            for (int j = 0; j < adjacencyList[currentNode].size(); ++j)\n            {\n                int neighbor = adjacencyList[currentNode][j];\n                if (distance[neighbor] == nodeCount + 1)\n                {\n                    distance[neighbor] = distance[currentNode] + 1;\n                    nodeQueue.push(neighbor);\n                }\n                else if (distance[neighbor] >= distance[currentNode] - 1)\n                {\n                    minimumCycleLength = min(minimumCycleLength, distance[currentNode] + distance[neighbor] + 1);\n                }\n            }\n        }\n    }\n\n    return minimumCycleLength == nodeCount + 1 ? -1 : minimumCycleLength;\n}",
    "output": "#include <bits/stdc++.h>\nint ShortestCycleLength(int nodeCount, std::vector<std::vector<int>> &edges)\n{\n    std::vector<std::vector<int>> adjacencyList(nodeCount);\n    for (int i = 0; i < edges.size(); ++i)\n    {\n        adjacencyList[edges[i][0]].push_back(edges[i][1]);\n        adjacencyList[edges[i][1]].push_back(edges[i][0]);\n    }\n\n    int minimumCycleLength = nodeCount + 1;\n    for (int startNode = 0; startNode < nodeCount; ++startNode)\n    {\n        std::vector<int> distance(nodeCount, nodeCount + 1);\n        distance[startNode] = 0;\n        std::queue<int> nodeQueue;\n        nodeQueue.push(startNode);\n\n        while (!nodeQueue.empty())\n        {\n            int currentNode = nodeQueue.front();\n            nodeQueue.pop();\n            for (int j = 0; j < adjacencyList[currentNode].size(); ++j)\n            {\n                int neighbor = adjacencyList[currentNode][j];\n                if (distance[neighbor] == nodeCount + 1)\n                {\n                    distance[neighbor] = distance[currentNode] + 1;\n                    nodeQueue.push(neighbor);\n                }\n                else if (distance[neighbor] >= distance[currentNode] - 1)\n                {\n                    minimumCycleLength = std::min(minimumCycleLength, distance[currentNode] + distance[neighbor] + 1);\n                }\n            }\n        }\n    }\n\n    return minimumCycleLength == nodeCount + 1 ? -1 : minimumCycleLength;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint longestBalancedSubstring(string binaryString)\n{\n    int maxLength= 0;\n    int zeroCount= 0;\n    int oneCount= 0;\n\n    for(int index= 0; index < binaryString.size(); ++index)\n    {\n        if(binaryString[index] == '0')\n        {\n            zeroCount++;\n        }\n        else\n        {\n            oneCount++;\n        }\n        if(zeroCount == oneCount)\n        {\n            maxLength= max(maxLength, zeroCount * 2);\n        }\n        else if(zeroCount > oneCount)\n        {\n            zeroCount= oneCount= 0;\n        }\n    }\n\n    zeroCount= oneCount= 0;\n    for(int index= binaryString.size() - 1; index >= 0; --index)\n    {\n        if(binaryString[index] == '0')\n        {\n            zeroCount++;\n        }\n        else\n        {\n            oneCount++;\n        }\n        if(zeroCount == oneCount)\n        {\n            maxLength= max(maxLength, zeroCount * 2);\n        }\n        else if(zeroCount < oneCount)\n        {\n            zeroCount= oneCount= 0;\n        }\n    }\n\n    return maxLength;\n}",
    "output": "#include <bits/stdc++.h>\nint LongestBalancedSubstring(std::string binaryString)\n{\n    int maxLength= 0;\n    int zeroCount= 0;\n    int oneCount= 0;\n\n    for(int index= 0; index < binaryString.size(); ++index)\n    {\n        if(binaryString[index] == '0')\n        {\n            zeroCount++;\n        }\n        else\n        {\n            oneCount++;\n        }\n        if(zeroCount == oneCount)\n        {\n            maxLength= std::max(maxLength, zeroCount * 2);\n        }\n        else if(zeroCount > oneCount)\n        {\n            zeroCount= oneCount= 0;\n        }\n    }\n\n    zeroCount= oneCount= 0;\n    for(int index= binaryString.size() - 1; index >= 0; --index)\n    {\n        if(binaryString[index] == '0')\n        {\n            zeroCount++;\n        }\n        else\n        {\n            oneCount++;\n        }\n        if(zeroCount == oneCount)\n        {\n            maxLength= std::max(maxLength, zeroCount * 2);\n        }\n        else if(zeroCount < oneCount)\n        {\n            zeroCount= oneCount= 0;\n        }\n    }\n\n    return maxLength;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> distinctRowsFrom(vector<int> &inputNumbers)\n{\n    vector<unordered_set<int>> uniqueRows;\n\n    for (int i = 0; i < inputNumbers.size(); ++i)\n    {\n        int currentNumber = inputNumbers[i];\n        bool isInserted = false;\n        for (int j = 0; j < uniqueRows.size(); ++j)\n        {\n            auto &row = uniqueRows[j];\n            if (row.find(currentNumber) == row.end())\n            {\n                row.insert(currentNumber);\n                isInserted = true;\n                break;\n            }\n        }\n\n        if (!isInserted)\n            uniqueRows.push_back({currentNumber});\n    }\n\n    vector<vector<int>> result;\n    for (int k = 0; k < uniqueRows.size(); ++k)\n    {\n        auto &row = uniqueRows[k];\n        result.emplace_back(row.begin(), row.end());\n    }\n\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> DistinctRowsFrom(std::vector<int> &inputNumbers)\n{\n    std::vector<std::unordered_set<int>> uniqueRows;\n\n    for(int i = 0; i < inputNumbers.size(); ++i)\n    {\n        int currentNumber = inputNumbers[i];\n        bool isInserted = false;\n        for (int j = 0; j < uniqueRows.size(); ++j)\n        {\n            auto &row = uniqueRows[j];\n            if(row.find(currentNumber) == row.end())\n            {\n                row.insert(currentNumber);\n                isInserted = true;\n                break;\n            }\n        }\n\n        if(!isInserted)\n            uniqueRows.push_back({currentNumber});\n    }\n\n    std::vector<std::vector<int>> result;\n    for (int i = 0; i < uniqueRows.size(); ++i)\n    {\n        auto &row = uniqueRows[i];\n        result.emplace_back(row.begin(), row.end());\n    }\n\n    return result;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxPoints(const vector<int> &firstMouseRewards, const vector<int> &secondMouseRewards, int k)\n{\n    vector<pair<int, int>> rewardGap(firstMouseRewards.size());\n    for(size_t index= 0; index < firstMouseRewards.size(); ++index)\n    {\n        rewardGap[index]= {secondMouseRewards[index] - firstMouseRewards[index], index};\n    }\n    sort(rewardGap.rbegin(), rewardGap.rend());\n    int totalFirstMousePoints= 0;\n    int totalSecondMousePoints= 0;\n    for(int i= 0; i < k; ++i)\n    {\n        totalFirstMousePoints+= firstMouseRewards[rewardGap[i].second];\n    }\n    for(int i= k; i < firstMouseRewards.size(); ++i)\n    {\n        totalSecondMousePoints+= secondMouseRewards[rewardGap[i].second];\n    }\n    return totalFirstMousePoints + totalSecondMousePoints;\n}",
    "output": "#include <bits/stdc++.h>\nint MaxPoints(const std::vector<int> &firstMouseRewards, const std::vector<int> &secondMouseRewards, int k)\n{\n    std::vector<std::pair<int, int>> rewardGap(firstMouseRewards.size());\n    for(size_t index= 0; index < firstMouseRewards.size(); ++index)\n    {\n        rewardGap[index]= {secondMouseRewards[index] - firstMouseRewards[index], index};\n    }\n    std::sort(rewardGap.rbegin(), rewardGap.rend());\n    int totalFirstMousePoints= 0;\n    int totalSecondMousePoints= 0;\n    for(int i= 0; i < k; ++i)\n    {\n        totalFirstMousePoints+= firstMouseRewards[rewardGap[i].second];\n    }\n    for(int i= k; i < firstMouseRewards.size(); ++i)\n    {\n        totalSecondMousePoints+= secondMouseRewards[rewardGap[i].second];\n    }\n    return totalFirstMousePoints + totalSecondMousePoints;\n}"
  },
  {
    "instruction": "Convert the following cpp code to 1) prefix all identifiers from the standard namespace with an 'std::' prefix 2) use UpperCamelCase for function names",
    "input": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> reachPosition(int totalPositions, int targetPosition, vector<int> &bannedPositions, int stepSize)\n{\n    set<int> bannedSet(bannedPositions.begin(), bannedPositions.end());\n    vector<int> result(totalPositions, 0);\n\n    for(int currentPosition= 0; currentPosition < totalPositions; ++currentPosition)\n    {\n        if(bannedSet.find(currentPosition) != bannedSet.end() || currentPosition == targetPosition)\n        {\n            result[currentPosition]= -1;\n            continue;\n        }\n\n        int stepsRequired= 0;\n        int distance= abs(targetPosition - currentPosition) / stepSize;\n        if((abs(targetPosition - currentPosition) % stepSize == 0) && ((distance & 1) == (((totalPositions - 1) & 1) ^ (stepSize & 1))))\n        {\n            stepsRequired= distance;\n        }\n        else\n        {\n            stepsRequired= -1;\n        }\n\n        result[currentPosition]= stepsRequired;\n    }\n\n    result[targetPosition]= 0;\n    return result;\n}",
    "output": "#include <bits/stdc++.h>\nstd::vector<int> ReachPosition(int totalPositions, int targetPosition, std::vector<int> &bannedPositions, int stepSize)\n{\n    std::set<int> bannedSet(bannedPositions.begin(), bannedPositions.end());\n    std::vector<int> result(totalPositions, 0);\n\n    for(int currentPosition= 0; currentPosition < totalPositions; ++currentPosition)\n    {\n        if(bannedSet.find(currentPosition) != bannedSet.end() || currentPosition == targetPosition)\n        {\n            result[currentPosition]= -1;\n            continue;\n        }\n\n        int stepsRequired= 0;\n        int distance= abs(targetPosition - currentPosition) / stepSize;\n        if((abs(targetPosition - currentPosition) % stepSize == 0) && ((distance & 1) == (((totalPositions - 1) & 1) ^ (stepSize & 1))))\n        {\n            stepsRequired= distance;\n        }\n        else\n        {\n            stepsRequired= -1;\n        }\n\n        result[currentPosition]= stepsRequired;\n    }\n\n    result[targetPosition]= 0;\n    return result;\n}"
  }
]